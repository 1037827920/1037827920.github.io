

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.png">
  <link rel="icon" href="/img/%E5%BE%AE%E4%BF%A1%E5%A4%B4%E5%83%8F.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="凌云行者">
  <meta name="keywords" content="">
  
    <meta name="description" content="Rust入门学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust入门学习笔记">
<meta property="og:url" content="http://example.com/2024/12/29/Rust%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="凌云行者的博客">
<meta property="og:description" content="Rust入门学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Rust%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.png">
<meta property="article:published_time" content="2024-12-29T13:38:19.000Z">
<meta property="article:modified_time" content="2025-05-17T11:03:15.075Z">
<meta property="article:author" content="凌云行者">
<meta property="article:tag" content="rust">
<meta property="article:tag" content="入门笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/Rust%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.png">
  
  
  
  <title>Rust入门学习笔记 - 凌云行者的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"wmN2DXdZ64UHbbAUn6oCgldr-gzGzoHsz","app_key":"U09w0L2CpXIR03ygOqzRyd7T","server_url":"https://wmn2dxdz.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>凌云行者</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust入门学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-29 21:38" pubdate>
          2024年12月29日, 9:38 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          27k 字
        
      </span>
    

    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Rust入门学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="rust简介">Rust简介</h1>
<h2 id="特点">特点</h2>
<p>即安全又高效，并发</p>
<p>是一种静态编译语言，要在写代码时声明数据类型</p>
<h2 id="擅长领域">擅长领域</h2>
<p>高性能Web Service</p>
<p>WebAssembly</p>
<p>命令行工具</p>
<p>网络编程</p>
<p>嵌入式设备</p>
<p>系统编程</p>
<h2 id="操作">操作</h2>
<p>更新rust：rustup update</p>
<p>卸载rust：rustup self uninstall</p>
<p>查看rust版本：rustc --version</p>
<p>查看本地文档：rustup doc</p>
<p>用vscode打开某项目：进入项目目录后 code .</p>
<h2 id="文件名">文件名</h2>
<p>后缀：rs</p>
<p>命名规范：hello_world.rs</p>
<h2 id="编译">编译</h2>
<p>rustc hello_world.rs（只适合简单的程序）</p>
<p>运行exe文件</p>
<h2 id="代码组织">代码组织</h2>
<p>代码组织主要包括： 哪些细节可以暴露，哪些细节是私有的
作用域内哪些名称有效</p>
<p>模块系统： Package(包)：cargo特性，让你构建、测试、共享crate
Crate(单元包)：一个模块树，它可产生一个library或可执行文件
Module(模块)、use：让你控制代码的组织、作用域、私有路径
Path(路径)：为struct、function或module等项命名的方式</p>
<p>Package包含Crate，Crate包含Module</p>
<h3 id="package">Package</h3>
<p>1、包含一个Cargo.toml，它描述如何构建这些Crates
2、只能包含0-1个library crate 3、可以包含任意数量的binary crate
4、但必须至少包含一个crate（library或binary）</p>
<h3 id="crate">Crate</h3>
<p>crate类型：library和binary</p>
<p>Crate Root： 是源代码文件
Rust编译器从这里开始，组成你的Crate的根Module</p>
<p>Cargo惯例： src/ main.rs: binary crate的crate root
crate名与package名相同 src/lib.rs: package 包含一个library crate library
crate 的 crate root crate名与package名相同</p>
<p>Cargo把crate root 文件交给rustc来构建library 或 binary</p>
<p>一个Package可以同时包含src/main.rs和src/lib.rs 一个binary
crate和一个library crate 名称与package名相同 一个Pacage可以有多个binary
crate： 文件放在src/bin 每个文件都是单独的binary crate</p>
<h3 id="module">Module</h3>
<p>在一个crate内，代码进行分组 增加可读性，易于复用
控制项目（item）的私有性，public、private</p>
<p>建立module： mod关键字 可嵌套
可包含其他项（struct、enum、常量、trait、函数等）的定义</p>
<p>实例代码： 单独创建一个文件lib.rs或其他名.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house&#123;<br>    <span class="hljs-keyword">mod</span> hosting&#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">seat_at_table</span>()&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">mod</span> serving&#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_order</span>()&#123;&#125;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">serve_order</span>()&#123;&#125;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_payment</span>()&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>src/main.rs和src/lib.rs叫做crate roots:
这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部</p>
<h3 id="私有边界">私有边界</h3>
<p>模块不仅可以组织代码，还可以定义私有边界
如果想把函数或结构体等设为私有，可以将它放到某个模块中
Rust中所有的条目（函数、方法、struct、enum、模块、常量）默认是私有的</p>
<p>父级模块无法访问子模块中的私有条目 子模块可以使用祖先模块中的条目</p>
<p>使用pub关键字可以将条目标记为公共的</p>
<p>pub strcut: pub放在struct前：
struct是公共的，但里面的字段默认是私有的</p>
<p>pub enum: enum是公共的，里面的变体也都是公共的</p>
<h3 id="路径">路径</h3>
<p>为了在Rust的模块中找到某个条目，需要使用<strong>路径</strong></p>
<p>路径的两种形式： 绝对路径：从crate root开始，使用crate名或字面值crate
相对路径：从当前模块开始，使用self，super或当前模块的标识符
路径至少由一个标识符组成，标识符之间使用::</p>
<p>在src下创建lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//都是crate文件下的同一级，可以互项调用</span><br><span class="hljs-keyword">mod</span> front_of_house&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting&#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>()&#123;<br>    <span class="hljs-comment">//绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    <span class="hljs-comment">//相对路径</span><br>    front_of_house::hosting::add_to_waitlist;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>super关键字： 用来访问父级模块路径中的内容，类似文件系统的..</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">serve_order</span>()&#123;&#125;<br><span class="hljs-keyword">mod</span> back_of_house&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fix_incorrect_order</span>()&#123;<br>        <span class="hljs-title function_ invoke__">cook_order</span>();<br>        <span class="hljs-comment">//使用super关键字</span><br>        super::<span class="hljs-title function_ invoke__">serve_order</span>();<br>        <span class="hljs-comment">//使用绝对路径</span><br>        crate::<span class="hljs-title function_ invoke__">serve_order</span>();<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cook_order</span>()&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="use关键字">use关键字</h3>
<p>可以使用use关键字将路径(可以用绝对路径和相对路径，一般用绝对路径)导入到作用域内，仍遵循私有性规则</p>
<p>use的习惯用法： 函数：将函数的父级模块引入作用域（指定到父级）
struct、enum、其他：指定到完整路径（指定到本身）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting&#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>()&#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collection::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    map.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而对于同名条目，则需要指定到父级。
或者使用as关键字为引入的路径指定本地别名</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br></code></pre></td></tr></table></figure>
<p>使用pub use重新导出名称
使用use将路径（名称）导入到作用域后，该名称在此作用域内是私有的。 pub
use：重导出
该条目引入作用域，该条目也可以被外部代码引入到它们的作用域</p>
<p>使用嵌套路径清理大量的use语句：
如果使用同一个包或模块下的多个条目，可使用嵌套路径在同一行内将上述条目引入：
路径相同的部分::{路径差异的部分}
如果两个use路径值意是另一个的子路径，使用self</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//use std::cmp::Ordering;</span><br><span class="hljs-comment">//use std::io;</span><br><span class="hljs-keyword">use</span> std::&#123;cmp::Ordering, io&#125;;<br><br><span class="hljs-comment">//use std::io</span><br><span class="hljs-comment">//use std::io::Write</span><br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br></code></pre></td></tr></table></figure>
<p>通配符<span class="math inline">\(*\)</span> 使用<span
class="math inline">\(*\)</span>可以把路径中所有公共条目都引入到作用域</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::*;<br></code></pre></td></tr></table></figure>
<p>应用场景： 测试。将所有测试代码引入到tests模块 有时用于预导入模块</p>
<h3 id="使用外部包">使用外部包</h3>
<p>1、Cargo.toml添加依赖的包 2、use将特定条目引入作用域</p>
<h3 id="将模块内容移动到其他文件">将模块内容移动到其他文件</h3>
<p>模块定义时，如果模块后边是";"，而不是代码块：
Rust会从与模块同名的文件中加载内容 模块树的结构不会变化</p>
<p>随着模块逐渐变大，该技术可以让你把模块的内容移动到其他文件中</p>
<p>lib.rs:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>()&#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>front_of_house.rs:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting;<br></code></pre></td></tr></table></figure>
<p>front_of_house/hosting.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br></code></pre></td></tr></table></figure>
<h1 id="宏">宏</h1>
<h2 id="简介">简介</h2>
<p>宏在rust里指的是一组相关特性的集合称谓：
1、使用macro_rules!构建的声明宏（可能要弃用，不深究） 2、3种过程宏：
自定义#[derive]宏，用于struct或enum，可以为其指定随derive属性添加的代码
类似属性的宏，在任何条目上添加自定义属性
类似函数的共，看起来像函数调用，对其指定为参数的token进行操作</p>
<p>函数与宏的差别：
1、本质上，宏是用来编写可以生成其他代码的代码（元编程）
2、函数在定义签名时，必须声明参数的个数和类型，宏可处理可变的参数
3、编译器会在解释代码前展开宏
4、宏的定义比函数复杂得多，难以阅读、理解、维护
5、在某个文件调用宏时，必须提前定义宏或将宏引入当前作用域内
6、函数可以在任何位置定义并在任何位置使用</p>
<h2 id="macro_rules-声明宏">macro_rules! 声明宏</h2>
<p>类似match模式匹配</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><span class="hljs-comment">//意味引入作用域后使用，这样就看可以声明有这个宏了</span><br><span class="hljs-built_in">macro_rules!</span> vec &#123;<br>( $( $x:expr ),* ) =&gt; &#123;<br>    	&#123;<br>			<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">temp_vec</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            $(<br>                temp_vec.<span class="hljs-title function_ invoke__">push</span>($x);<br>            )*<br>            temp_vec<br>    	&#125;<br>    &#125;;<br>&#125;<span class="hljs-comment">//实现vec!宏</span><br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">mod</span> macros &#123;<br>    <span class="hljs-built_in">macro_rules!</span> my_macro &#123;<br>        () =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Check out my macro!&quot;</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_macro!();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[rustfmt::skip]</span><br><span class="hljs-built_in">macro_rules!</span> my_macro &#123;<br>    () =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Check out my macro!&quot;</span>);<br>    &#125;;<br>    ($val:expr) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Look at this other macro: &#123;&#125;&quot;</span>, $val);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_macro!();<br>    my_macro!(<span class="hljs-number">7777</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="基于属性来生成代码的过程宏">基于属性来生成代码的过程宏</h2>
<p>1、这种形式更像函数一些： 接收并操作输入的rust代码
生成另外一些rust代码作为结果 2、三种过程宏： 自定义派生 属性宏 函数宏
3、创建过程宏时：
宏定义必须单独放在它们自己的包中，并使用特殊的包类型</p>
<p>自定义derivr宏： 需求：
1、创建一个hello_macro包，定义一个拥有关联函数hello_macro和HelloMacro
trait 2、提供一个能够自动实现trait的过程宏
3、在它们的类型上标注#[derive(HelloMacro)]，进而得到hello_macro的默认实现
（例子看不懂：BV1hp4y1k7SV的P107）</p>
<p>类似属性的宏： 1、属性宏与自定义derive宏类似： 允许创建新的属性
但不是为derive属性生成代码 2、属性宏更加灵活：
derive只能用于struct和enum 属性宏可以用于任意条目，例如函数</p>
<p>类似函数的宏： 1、函数定义类似于函数调用的宏，但比普通股函数更加灵活
2、函数宏可以接收TokenStream作为参数
3、与另外两种过程宏一样，在定义中使用rust代码来操作TokenStream</p>
<h1 id="cargo">Cargo</h1>
<h2 id="简介-1">简介</h2>
<p>Cargo是Rust的构建系统和包管理工具：用于构建代码，下载依赖的库、构建这些库。（安装rust会安装cargo）</p>
<p>查看cargo版本：cargo --version</p>
<h2 id="操作-1">操作</h2>
<h3 id="创建项目">创建项目</h3>
<p>cargo new 项目名称</p>
<p>Cargo.toml: 1、是Cargo的配置格式
2、package是一个区域标题，表示下方的内容是用来配置包的，name项目名，verstion项目版本，authors项目作者，edition使用的rust版本
3、dependencies是另一个区域的开始，它会列出项目的依赖项（依赖库）
4、在Rust里面，代码的包称作crate</p>
<p>cargo生成的main.rs在src目录下，而cargo.toml在项目顶层下，顶层目录可以防止README、许可信息、配置文件和其他</p>
<p>如果创建项目的时候没有使用cargo，也可以把项目转化为cargo：
1、把源代码移动到src下 2、创建Cargo.toml并填写相应的配置</p>
<p>创建库项目： cargo new 项目名称 --lib</p>
<h3 id="构建项目">构建项目</h3>
<p>在项目里cargo build即可</p>
<p>生成.lock文件和target文件夹</p>
<p>Cargo.lock:
1、首次构建时创建的文件，会找到该代码中符合要求的依赖项并写到lock文件
2、在以后构建，会先使用lock文件中指定的依赖项版本，而不是最新的版本，除非自己手动指定（在toml文件中指定）</p>
<p>为发布构建：cargo build --release</p>
<h3 id="构建并运行项目">构建并运行项目</h3>
<p>cargo run</p>
<h3 id="检查代码">检查代码</h3>
<p>cargo check</p>
<p>检查代码，确保能通过编译，但不产生可执行文件（比cargo build快）</p>
<h2 id="发布配置">发布配置</h2>
<p>通过发布配置（release profile）来自定义构建： 1、是预定义的
2、可自定义：可使用不同的配置，对代码编译拥有更多的控制
3、每个profile的配置都独立于其他的profile</p>
<p>cargo主要的两个profile： 1、dev profile：适用于开发，cargo build
2、release profile：适用于发布，cargo build --release</p>
<p>自定义profile： 1、针对每个profile，cargo都提供了默认的配置
2、如果想自定义xxxx
profile的配置：可以在cargo.toml里添加[profile.xxxx]区域，在里面覆盖默认配置的子集（有[profile.dev]和
[profile.release]）</p>
<p>在dev模式下，opt-level默认值是0（不要性能，编译快）
在release模式下，opt-level默认值是3（要性能，编译慢）</p>
<h2 id="发布crate">发布crate</h2>
<p>发布到crate.io： 1、可以通过发布包来共享代码
2、crate注册表在http://crates.io/</p>
<p>文档注释： 生成HTML文档 显式公共API的文档注释，如何使用API 使用///
支持markdowns 放置在被说明条目之前</p>
<p>生成HTML文档的命令：cargo doc 它会运行rustdoc工具（rust安装包自带）
把生成的HTML文档放在target/doc目录下 cargo doc
--open能生成并打开文档</p>
<p>文档注释常用章节：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">///# Examples</span><br><span class="hljs-comment">///```</span><br><span class="hljs-comment">///示例代码</span><br><span class="hljs-comment">///```</span><br></code></pre></td></tr></table></figure>
<p>其他常用章节： Panics：函数可能发生panic的场景
Errors：如果函数返回Result，描述可能的错误种类，以及可导致错误的条件
Safety：如果函数处于unsafe调用，就应该解释函数unsafe的原因，以及调用者确保的使用前提</p>
<p>文档注释作为测试： 示例代码块的附加值： 运行cargo
test：将把文档注释中示例代码作为测试来运行</p>
<p>为包含注释的项添加文档注释： 符号：//! 这类注释通常描述crate和模块：
crate root（按惯例为src/lib.rs）
一个模块内，将crate或模块作为一个整体进行记录</p>
<p>上面的示例(lib.rs文件中的代码)：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//! # CaoGao</span><br><span class="hljs-comment">//! Hello Wolrd!</span><br><span class="hljs-comment">//! </span><br><br><span class="hljs-comment">///Adds one to the number given</span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// # Examples</span><br><span class="hljs-comment">/// ```</span><br><span class="hljs-comment">/// let arg = 5;</span><br><span class="hljs-comment">/// let answer = my_crate::add_one(arg);</span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// assert_eq!(6, answer);</span><br><span class="hljs-comment">/// ```</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(arg: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    arg<br>&#125;<br></code></pre></td></tr></table></figure>
<p>详细关于发布代码到crate.io网站上的操作： 看b站BV1hp4y1k7SV 的P82</p>
<h2 id="pub-use">pub use</h2>
<p>使用pub use导出方便使用的公共API</p>
<p>问题：crate程序结构在开发时对于开发者
很合理，但对于它的使用者不够方便。 例如：
麻烦：my_crate::some_module::another_module::UsefulType
方便：my_crate::UsefulType 解决方案： 使用pub
use，可以重新导出，创建一个与内部私有结构不同的对外公共结构</p>
<p>lib.rs：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> self::kinds::PrimaryColor;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> kinds&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PrimaryColor</span> &#123;<br>        Red,<br>        Yellow,<br>		Blue,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//use crate::kinds::PrimaryColor;</span><br><span class="hljs-keyword">use</span> crate::PrimaryColor;<br></code></pre></td></tr></table></figure>
<h2 id="工作空间">工作空间</h2>
<p>cargo工作空间：帮助管理多个相互关联且需要协同开发的crate
cargo工作空间是一套共享同一个cargo.lock和输出文件夹的包</p>
<p>例子： 1个二进制crate，2个库crate</p>
<p>在项目最外边创建Cargo.toml文件并设置：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">[workspace]<br><br>members = [<br>    &quot;adder&quot;<br>    &quot;add-one&quot;<br>]<br></code></pre></td></tr></table></figure>
<p>adder是一个二进制crate，add-one是l库crate</p>
<p>指定运行二进制crate： cargo run -p adder</p>
<p>要写依赖项，在对应的crate的Cargo.toml的dependencies属性：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[dependencies]<br>add-one = &#123;path = &quot;../add-one&quot;&#125;<br></code></pre></td></tr></table></figure>
<p>整个工作空间只有一个Cargo.toml：保证不会出错</p>
<p>指定执行某个文件测试： cargo test -p add-one</p>
<h1 id="关键字">关键字</h1>
<h2 id="let">let</h2>
<p>定义变量</p>
<h2 id="mut">mut</h2>
<p>声明变量为可变的，rust中的变量默认都是不可变的</p>
<h2 id="const">const</h2>
<p>声明常量，常量与变量有很多区别： 1、不可以使用mut，常量永远是不可变的
2、声明常量使用const，而且类型必须被标注
3、常量可以在任何作用域内声明，包括全局作用域
4、常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值</p>
<p>命名规范：Rust中常量使用全大写字母，每个单词之间用下划线分开，例如：
MAX_POINTS</p>
<p>例子： const MAX_POINTS: u32 = 100_000;</p>
<h2 id="fn">fn</h2>
<p>声明函数</p>
<p>rust中，针对函数和变量名，rust使用snake
case命名规范，即所有的字母都是小写的，单词之间使用下划线分开</p>
<p>在rust中，不需要先声明函数才能进行调用，只要文件中有对该函数的定义，就能进行调用</p>
<p>在rust中，函数签名中必须声明每个形参的类型</p>
<p>函数的语句和表达式示例代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br>        x + <span class="hljs-number">3</span><span class="hljs-comment">//这里不加分号，表示这里是一个表达式，能将值赋值给y，如果加分号，表示这是一个语句，那程序就会报错</span><br>    &#125;;<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数的返回值：
1、在-&gt;符号后边声明函数返回的类型，但是不可以为返回值命名
2、在rust中，返回值就是函数体里面最后一个表达式的值
3、若想提前返回，需使用return关键字，并指定一个值（大多数函数都是默认使用最后一个表达式为返回值）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_five</span>(x:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    x + <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">plus_five</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>,x);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="match">match</h2>
<p>相当于c++中的switch，分支，对应不同情况（不同枚举）有不同的执行语句</p>
<p>match匹配必须穷举所有的可能</p>
<p>常规代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">UsState</span>&#123;<br>    Alabama,<br>    Alaska,<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coin</span>&#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    <span class="hljs-title function_ invoke__">Quarter</span>(UsState),<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">value_in_cents</span>(coin: Coin) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span>&#123;<br>    <span class="hljs-keyword">match</span> coin&#123;<br>        Coin::Penny =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Penny&quot;</span>);<br>            <span class="hljs-number">1</span><br>        &#125;<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        <span class="hljs-comment">//这里的state是临时创建的，可以表示传入的UsState的值</span><br>        Coin::<span class="hljs-title function_ invoke__">Quarter</span>(state) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quater from &#123;:?&#125;!&quot;</span>,state);<br>            <span class="hljs-number">25</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Coin::<span class="hljs-title function_ invoke__">Quarter</span>(UsState::Alaska);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-title function_ invoke__">value_in_cents</span>(c));<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//要相同类型才能比较哦</span><br>    <span class="hljs-keyword">match</span> a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b)&#123;<br>        <span class="hljs-comment">//判断是从上往下判断的</span><br>        <span class="hljs-comment">//注意是逗号不是分号</span><br>        Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a小于b&quot;</span>),<br>        Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a大于b&quot;</span>),<br>        Ordering::Equal =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a等于b&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通配符_：替代其余没列出的值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>:<span class="hljs-type">u8</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里的v传入后后面不能使用了，除非这里传入引用，即&amp;v</span><br>    <span class="hljs-keyword">match</span> v&#123;<br>        <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;One&quot;</span>),<br>        <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Two&quot;</span>),<br>        _ =&gt; (),<span class="hljs-comment">//要放在最后面</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">maybe_icecream</span>(time_of_day: <span class="hljs-type">u16</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt; &#123;<br>    <span class="hljs-keyword">match</span> time_of_day &#123;<br>        <span class="hljs-number">0</span>..=<span class="hljs-number">21</span> =&gt; <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>),<br>        <span class="hljs-number">22</span>..=<span class="hljs-number">23</span> =&gt; <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>),<br>        _ =&gt; <span class="hljs-literal">None</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>处理错误示例代码：</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br> 	std::io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;无法读取行&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>:<span class="hljs-type">i32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>()&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>    &#125;<br>    <span class="hljs-comment">//_表示不在乎括号里面的内容</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h2 id="if-let">if let</h2>
<p>相当于只匹配一种模式的match，代码更少但是放弃了穷举的可能</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0u8</span>);<br>    <span class="hljs-keyword">match</span> v &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Three&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Others&quot;</span>),<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-number">3</span>) = v&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Three&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Others&quot;</span>);<br>    &#125;<span class="hljs-comment">//后面这段else可加可不加，意义不大</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">option_value</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 使用 if let 检查 option_value 是否为 Some，并将其解构为内部的值</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(value) = option_value &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Option value is Some: &#123;&#125;&quot;</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Option value is None.&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="while-let">while let</h2>
<p>while
let循环会反复执行一个块，直到模式匹配失败，当模式匹配成功时，循环会进入块内部执行相关代码；当模式匹配失败时，循环会结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stack</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = stack.<span class="hljs-title function_ invoke__">top</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Popped item: &#123;&#125;&quot;</span>, item);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Stack is empty!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，Some(item) =
stack.top()，他会尝试从stack中弹出一个元素，并将其绑定到item。只要pop方法返回Some枚举的值，就会执行循环体内的代码。一旦pop方法返回None，循环就会终止</p>
<h2 id="loop">loop</h2>
<p>相当于c++中的循环</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">loop</span>&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//要相同类型才能比较哦</span><br>        <span class="hljs-keyword">match</span> a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b)&#123;<br>            <span class="hljs-comment">//判断是从上往下判断的</span><br>            <span class="hljs-comment">//注意是逗号不是分号</span><br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a小于b&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a大于b&quot;</span>),<br>            Ordering::Equal =&gt;&#123;<br>            	<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a等于b&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    	&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span>&#123;<br>        counter += <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span>&#123;<br>            <span class="hljs-keyword">break</span> counter*<span class="hljs-number">2</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is: &#123;&#125;&quot;</span>,result);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="if">if</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-number">3</span>;<br>     <br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">5</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was true&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was false&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-keyword">if</span> condition &#123;<span class="hljs-number">5</span>&#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-number">6</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="while">while</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">number</span> = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">while</span> number != <span class="hljs-number">3</span>&#123;<br>        number -= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="for">for</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is: &#123;&#125;&quot;</span>,element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">number</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">4</span>).<span class="hljs-title function_ invoke__">rev</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>,number);<br>    &#125;<br>    <span class="hljs-comment">/*结果：</span><br><span class="hljs-comment">    3!</span><br><span class="hljs-comment">    2!</span><br><span class="hljs-comment">    1!</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="struct">struct</h2>
<h3 id="定义">定义</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>&#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="实例化">实例化</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//一旦实例是可变的，那所有字段都是可变的</span><br>   	<span class="hljs-comment">//可以不按顺序实例化</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> = User&#123;<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1037827@qq.com&quot;</span>),<br>        usename: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mike&quot;</span>),<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">588</span>,<span class="hljs-comment">//不能缺少一个数据不赋值</span><br>    &#125;;<br>    <br>    <span class="hljs-comment">//使用点标记法取值</span><br>    user1.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;103@qq.com&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简写实例化结构：（形参名与字段名相同）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User&#123;<br>    User&#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">0</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="更新语法">更新语法</h3>
<p>当你想基于某个struct实例来创建一个新实例的时候，可以使用struct更新语法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User&#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;103&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bob&quot;</span>),<br>    active: user1.active,<br>    sign_in_count: user1.sign_in_count,<br>&#125;<br><br><span class="hljs-comment">//更新语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User&#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;103&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bob&quot;</span>),<br>    ..user1<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="tuple-struct">Tuple Struct</h3>
<p>Tuple Struct整体有名字，但里面的元素没有名字。
适用：想给整个tuple起名字，并让它不同于其他tuple，而且不需要给里面的每个元素起名字。
访问可以用：模式匹配或点标记法</p>
<p>例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>black.<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
<h3 id="unit-like-struct">Unit-Like Struct</h3>
<p>1、可以定义没有任何字段的struct，叫做Unit-Like Struct
2、适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnitLikeStruct</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">unit_like_struct</span> = UnitLikeStruct;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="struct数据所有权">struct数据所有权</h3>
<p>上面的User使用了String而不是&amp;str： 该struct实例拥有其所有的数据
只要struct实例是有效的，那么里面的字段数据也是有效的
struct里面也可以存放引用，但是需要使用生命周期，生命周期保证只要struct实例是有效的，那么里面的引用也是有效的</p>
<h3 id="调试打印结构体">调试打印结构体</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect</span> = Rectangle&#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-title function_ invoke__">area</span>(&amp;rect));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,rect);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(rect: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>    rect.width * rect.length <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-comment">//使用关键字impl实现方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-comment">//方法的第一个参数总是self，在调用时可以不写</span><br>	<span class="hljs-comment">//一般借用自己的实例化，而不是获得数据所有权，但不是强制的</span><br>    <span class="hljs-comment">//也可以是可变引用</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect</span> = Rectangle&#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,rect.<span class="hljs-title function_ invoke__">area</span>());<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法调用的运算符：
在c++中，调用指针对象的方法为object-&gt;或者(<em>object).
但在rust中会自动引用或解引用，即在调用方法时，rust根据情况自动添加&amp;、&amp;mut或</em>
例子： p1.distance(&amp;p2) 等价于 (*p1).distance(&amp;p2)</p>
<p>关联函数：
可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法）
例如：String::from()</p>
<p>关联函数通常用于构造器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.length &gt; other.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">square</span>(size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> Rectangle&#123;<br>        Rectangle&#123;<br>            width: size,<br>            length: size,<br>        &#125;   <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect</span> = Rectangle&#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Rectangle::<span class="hljs-title function_ invoke__">square</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,rect.<span class="hljs-title function_ invoke__">area</span>());<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个struct可以有多个impl块</p>
<h1 id="输入输出">输入输出</h1>
<h2 id="输出">输出</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="输入">输入</h2>
<h3 id="字符串输入">字符串输入</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>   	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    ios::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;无法读取行&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="依赖项">依赖项</h1>
<h2 id="rand">rand</h2>
<p>现在toml文件中依赖项区域加入rand = "版本号"</p>
<p>生成1~100的随机数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand::rng;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = rand::<span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">gen_range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="数据类型">数据类型</h1>
<h2 id="shadowing隐藏">Shadowing（隐藏）</h2>
<p>可以使用相同名字声明新的变量，新的变量就会shadow之前生民的同名变量</p>
<p>新变量的数据类型可以与旧变量的数据类型不同</p>
<h2 id="复合类型">复合类型</h2>
<p>rust提供两种基础的复合类型：元组(tuple)和数组</p>
<p>tuple可以将多个类型的多个值放在一个类型里，长度是固定的，一旦声明就无法修改。
获取Tuple的元素值：
1、可以使用模式匹配来解构（destructure）一个Tuple来获取元素的值
2、点标记法，后接元素的引号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>:(<span class="hljs-type">i32</span>,<span class="hljs-type">f64</span>,<span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">//使用模式匹配获取Tuple中的元素的值</span><br>    <span class="hljs-keyword">let</span> (x,y,z) = tup;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,x,y,z);<br>    <br>    <span class="hljs-comment">//使用点标记法</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,tup.<span class="hljs-number">0</span>,tup.<span class="hljs-number">1</span>,tup.<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>数组也可以将多个值放在一个类型里，但是数组中每个元素的类型必须是相同的，长度也是固定的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>:[<span class="hljs-type">i32</span>,<span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = [<span class="hljs-number">3</span>;<span class="hljs-number">5</span>];<span class="hljs-comment">// let b = [3,3,3,3,3];</span><br>    <br>    <span class="hljs-comment">//访问数组元素</span><br>    a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="字符串转化成整数">字符串转化成整数</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>	<span class="hljs-keyword">let</span>  <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;无法读取行&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">i32</span> = guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;不是整数&quot;</span>);<br>    <span class="hljs-comment">//let guess: u32 = 也是可以的</span><br>    <span class="hljs-comment">//注意只有单冒号，这种方式是声明变量为哪种类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>1、trim方法是去除"" 2、parse方法是将字符串转化为整型
3、rust中允许同名新变量隐藏旧变量</p>
<h1 id="所有权">所有权</h1>
<h2 id="简介-2">简介</h2>
<p>Rust的核心特性就是所有权</p>
<p>所有程序在运行时都必须管理它们使用计算机内存的方式
1、有些语言有垃圾收集机制，在程序运行时，它们会不断寻找不再使用的内存
2、在其他语言中，程序员必须显式地分配和释放内存</p>
<p>Rust采用了第三种方式：
1、内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则
2、当程序运行时，所有权特性不会减慢程序的运行速度</p>
<h2 id="stack-vs-heap">Stack vs Heap</h2>
<p>Stack按值的接收顺序来存储，按相反的顺序将它们移除
所有存储在Stack上的数据必须拥有已知的固定大小，编译时大小未知的数据或运行时大小可能发生变化的数据必须放在heap上</p>
<p>Heap内存组织性差一些： 1、当你把数据放入Heap时，会请求一定数量的空间
2、操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，是这个空间的地址
3、这个过程叫做在heap上进行分配</p>
<p>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中数据</p>
<p>当你的代码调用函数时，值被传入到函数。函数本地的变量被压到stack上。当函数结束后，这些值会从stack上弹出</p>
<h2 id="所有权存在的原因">所有权存在的原因</h2>
<p>所有权解决的问题： 1、跟踪代码的哪些部分正在使用heap的哪些数据
2、最小化heap上的重复数据量 3、清理heap上未使用的数据以避免空间不足</p>
<h2 id="所有权规则">所有权规则</h2>
<p>1、每个值都有一个变量，这个变量是该值的所有者
2、每个值同时只能有一个所有者
3、当所有者超出作用域(scope)时，该值将被删除</p>
<h2 id="内存和分配">内存和分配</h2>
<p>对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动地交换给操作系统</p>
<p>调用drop函数</p>
<h2 id="移动">移动</h2>
<p>存放在stack中数据进行移动时无碍，但是如果时复合类型进行移动，两个变量的数据指向的是同一块heap上的内容，当离开作用域时，会释放两次内存，rust的解决方案是尝试让第一个变量失效，即当第一个变量离开作用域时不会释放内存（此时已经不能使用第一个变量了，因为它已经失效了）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<span class="hljs-comment">//已经不能使用s1了</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="克隆">克隆</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<span class="hljs-comment">//在heap上复制了一份内容</span><br>    <span class="hljs-comment">//这样s1还能继续使用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="函数">函数</h2>
<p>把一个值赋给其他变量变量就会发生移动，形参传入实参，那实参就会发生移动
如果是stack上的数据，那么发生拷贝
如果是heap上的数据，那么发生移动，它的值就会被drop清理</p>
<p>如何让函数使用某个值，但不获得其所有权？就是把传入的实参作为返回值返回即可
转移所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> (s2,len) = <span class="hljs-title function_ invoke__">calculate_length</span>(s1);<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#123;&#125; is &#123;&#125;&quot;</span>,s2,len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>,<span class="hljs-type">usize</span>)&#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br>    (s,length)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="引用">引用</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#123;&#125; is &#123;&#125;&quot;</span>,s1,len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span>&#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>借用： 1、我们把引用作为函数参数的这个行为叫做借用
2、不可以修改借用的东西 3、因为和变量一样，引用默认也是不可变的</p>
<p>加入mut使其引用可变(&amp;mut)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;<span class="hljs-keyword">mut</span> s1);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span>&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;,world!&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<span class="hljs-comment">//这样就会报错</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>好处：可在编译时防止数据竞争</p>
<p>三种引发数据竞争的行为： 1、两个或多个指针同时访问同一个数据
2、至少有一个指针用于写入数据 3、没有使用任何机制来同步对数据的访问</p>
<p>解决方案：可以通过创建新的作用域，来允许非同时地创建多个可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另一个限制： 1、不可以同时拥有一个可变引用和一个不可变的引用
2、多个不可变的引用是允许的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s;<span class="hljs-comment">//没有错</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s;<span class="hljs-comment">//没有错</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<span class="hljs-comment">//报错，因为已经有不可变的引用了</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>悬空引用（Dangling References）：
1、一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了
2、在Rust中，编译器可保证引用永远都不是悬空引用，如果你引用了某些数据，编译器能保证在引用离开作用域之前数据不会离开作用域</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &amp;s<span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="切片">切片</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<br>	<span class="hljs-comment">//但是这里的wordIndex无法与s保持同步性</span><br>    <span class="hljs-comment">//例如s.clear()后,wordIndex已经无效了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,wordIndex);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>针对上面代码的缺陷，rust提供了一种解决方案：字符串切片
字符串切片是指向字符串中一部分内容的引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<span class="hljs-comment">//[..5]  语法糖</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];<span class="hljs-comment">//[6..]  语法糖</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">whole</span> = &amp;s[<span class="hljs-number">0</span>,s.<span class="hljs-title function_ invoke__">len</span>()];<span class="hljs-comment">//[..]  语法糖</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>形式：[开始索引..结束索引] 开始索引：切片起始位置的索引值
结束索引：切片终止位置的下一个索引值</p>
<p>解决最开始的问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<span class="hljs-comment">//wordIndex为不可变引用</span><br>	<br>    <span class="hljs-comment">//此时已经不能用s.clear()，因为s已经是不可变的了</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,wordIndex);<br>&#125;<br><br><span class="hljs-comment">//注意这里的返回是字符串切片&amp;str</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<span class="hljs-comment">//因为这里返回不可变引用了！！！！！！！！</span><br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>字符串字面值是切片，字符串字面值被直接存储在二进制程序中</p>
<p>将字符串切片作为参数传递，即： fn first_word(s: &amp;str) -&gt;
&amp;str {} 1、使用字符串切片，直接调用该函数
2、使用String，可以创建一个完整的String切片来调用该函数</p>
<p>因为这样就可以同时接收String和&amp;str类型的参数了，定义函数时使用字符串切片来代替字符串引用会是我们的API更加通用，而且不会损失任何功能</p>
<p>示例代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;my_string[..]);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_string_literal</span> = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(my_string_literal);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其他类型的切片：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="标准类">标准类</h1>
<h2 id="字符串">字符串</h2>
<p>Rust中字符串使用UTF-8编码</p>
<p>Rust的核心语言层面，只有一个字符串类型：字符串切片str（&amp;str）</p>
<p>字符串切片：对存储在其他地方、UTF-8编码的字符串的引用
字符串字面值：存储在二进制文件中，也是字符串切片</p>
<h3 id="string类">String类</h3>
<p>UTF-8编码</p>
<h4 id="创建">创建</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//无初始值创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s0</span> <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <br>    <span class="hljs-comment">//有初始值创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, World&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="str转换成string">&amp;str转换成String</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = <span class="hljs-string">&quot;Hello, world&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = data.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;Hello, world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = data.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = data.<span class="hljs-title function_ invoke__">into</span>();<br>    <span class="hljs-comment">//这三个方法基本是等效的，返回String</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="更新">更新</h4>
<p>push_str()：把一个字符串切片附加到String</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>    <span class="hljs-comment">//传入引用，即可以继续使用，下面的s1传入后还能继续使用</span><br>    <span class="hljs-comment">//let mut s1 = String::from(&quot;bar&quot;);</span><br>    <span class="hljs-comment">//s.push_str(&amp;s1);</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>push()方法：把单个字符附加到String</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;lo&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;l&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>+：连接字符串 使用了类似这个签名的方法：fn add(self, &amp;str) -&gt;
String{...} 解引用强制转化，把字符串引用转化成字符串切片</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello &quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;World&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = s1 + &amp;s2;<span class="hljs-comment">//这里取得s1的所有权给s3</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s3);<br>    <span class="hljs-comment">//println!(&quot;&#123;&#125;&quot;,s1);   s1已经不能使用了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s2);<span class="hljs-comment">//s2还可以使用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>format!：连接多个字符串(更灵活)
不会取得任何参数的所有权，这些参数后续都可以继续使用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;tic&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;tac&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;toe&quot;</span>);<br>    <br>    <span class="hljs-comment">//let s3 = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;</span><br>    <span class="hljs-comment">//println!(&quot;&#123;&#125;&quot;,s3);</span><br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>,s1,s2,s3);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="返回字符串长度">返回字符串长度</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s.<span class="hljs-title function_ invoke__">len</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s2.<span class="hljs-title function_ invoke__">len</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="访问">访问</h4>
<p>String类不能按索引的形式进行访问 String是对Vec<u8>的包装</p>
<p>Rust有三种看待字符串的方式：
字节、标量值、字形簇（最接近所谓的字母）</p>
<p>Rust不允许String进行索引的最后一个原因：
索引操作应消耗一个常量时间O(1)，而String无法保证，需要遍历所有内容来确定有多少个合法的字符</p>
<h4 id="切割string">切割String</h4>
<p>可以使用[]和一个范围来创建字符串的切片</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<span class="hljs-comment">//必须沿边界切割，因为有些文字一个字占了两个字节</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="遍历">遍历</h4>
<p>对于标量值：chars()方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,b);<br>    &#125;<br>    <span class="hljs-comment">//输出h e l l o</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于字节：bytes()方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于字形簇：很复杂，标准库未提供</p>
<h4 id="注意">注意</h4>
<p>Rust选择将正确处理String数据作为所有Rust程序的默认行为：程序员必须在处理UTF-8数据之前投入更多的精力</p>
<p>但却可以防止在开发后期处理涉及非ASCII字符的错误</p>
<h4 id="代替">代替</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;I think cars are cool&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = input.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">&quot;cars&quot;</span>. <span class="hljs-string">&quot;balloons&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="转化为小写字母">转化为小写字母</h4>
<p>to_lowercase() trait</p>
<p>返回值是String类型</p>
<h4 id="转化为大写字母">转化为大写字母</h4>
<p>to_uppercase() trait</p>
<h3 id="str字符串切片">&amp;str（字符串切片）</h3>
<h4 id="去除空格">去除空格</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-string">&quot;   Hello!   &quot;</span>;<br>    <span class="hljs-comment">//去除头尾的空格</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string0</span> = input.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-comment">//去除头部的空格</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = input.<span class="hljs-title function_ invoke__">trim_start</span>().<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-comment">//去除尾部的空格</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = input.<span class="hljs-title function_ invoke__">trim_end</span>().<span class="hljs-title function_ invoke__">to_string</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="连接">连接</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input1</span> = <span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-comment">//返回String类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,input,input1);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="代替-1">代替</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-string">&quot;I think cars are cool&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = input.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">&quot;cars&quot;</span>. <span class="hljs-string">&quot;balloons&quot;</span>).<span class="hljs-title function_ invoke__">to_string</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="转化为小写字母-1">转化为小写字母</h4>
<p>to_lowercase() trait</p>
<p>返回值是String类型</p>
<h2 id="vector">Vector</h2>
<p>Vec<T> 可存储相同类型的值，在堆上连续存放</p>
<h3 id="创建-1">创建</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//常规创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-comment">//使用宏创建，用初始值作为容器的数据类型 </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="添加">添加</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//编译器可以识别到就可以不用Vec&lt;T&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="读取元素">读取元素</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>   	<span class="hljs-comment">//使用索引  超出索引范围会报错</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">third1</span>: &amp;<span class="hljs-type">i32</span> = &amp;v[<span class="hljs-number">2</span>]<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;&#125;&quot;</span>,third);<br>    <br>    <span class="hljs-comment">//使用get方法  超出索引范围不会报错</span><br>    <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(thied2) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;&#125;&quot;</span>,third);<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no third element&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="所有权和借用规则">所有权和借用规则</h3>
<p>不能再同一作用域内同时拥有可变和不可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    ler first = &amp;v[<span class="hljs-number">0</span>];<br>	v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span><span class="hljs-comment">//这一行代码报错，不能同时拥有可变和不可变引用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="遍历元素">遍历元素</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v&#123;<br>        *item += <span class="hljs-number">50</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;v&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="存放不同数据类型">存放不同数据类型</h3>
<p>1、使用enum，因为enum的变体可以附加不同类型的数据，而enum变体定义在同一个enum类型下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SpreadSheetCell</span> &#123;  <br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">row</span>: <span class="hljs-type">Vec</span>&lt;SpreadSheetCell&gt; = <span class="hljs-built_in">vec!</span>[<br>        SpreadSheetCell::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">3</span>),<br>        SpreadSheetCell::<span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;blue&quot;</span>)),<br>        SpreadSheetCell::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">10.12</span>),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2、使用Box<dyn Any></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::any::Any;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Any&gt;&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>));<br>    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3.14</span>));<br>    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello, Rust!&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> vec &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(i) = item.downcast_ref::&lt;<span class="hljs-type">i32</span>&gt;() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Integer: &#123;&#125;&quot;</span>, i);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(f) = item.downcast_ref::&lt;<span class="hljs-type">f64</span>&gt;() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Float: &#123;&#125;&quot;</span>, f);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = item.downcast_ref::&lt;<span class="hljs-type">String</span>&gt;() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Text: &#123;&#125;&quot;</span>, s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法-1">方法</h3>
<h4 id="from_slice">from_slice</h4>
<p>函数定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_slice</span>(slice: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span><br></code></pre></td></tr></table></figure>
<p>接受一个切片，返回一个包含切片元素副本的新集合示例，这在需要从切片中构建集合时非常有用，因为它允许你在不修改原始数据的情况下创建一个新的集合</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">from_slice</span>(slice);<br></code></pre></td></tr></table></figure>
<h4 id="extend_from_slice">extend_from_slice</h4>
<p>定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">extend_from_slice</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: &amp;[T])<br></code></pre></td></tr></table></figure>
<p>接受一个切片，将切片中的元素追加到集合的末尾</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>vec.<span class="hljs-title function_ invoke__">extend_from_slice</span>(slice);<br></code></pre></td></tr></table></figure>
<h4 id="copy_from_slice">copy_from_slice</h4>
<p>定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">copy_from_slice</span>(src: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span><br></code></pre></td></tr></table></figure>
<p>接受一个切片作为参数，并将切片中的内容复制到调用者所代表的可变位置</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [<span class="hljs-number">0</span>;<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">src</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">copy_count</span> = array.<span class="hljs-title function_ invoke__">copy_from_slice</span>(&amp;src);<br></code></pre></td></tr></table></figure>
<h2 id="hashmap">HashMap</h2>
<h3 id="创建-2">创建</h3>
<p>创建空的HashMap：new()函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span>: HashMap&lt;<span class="hljs-type">String</span>,<span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用collect方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">teams</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>)];<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">initial_scores</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>,<span class="hljs-number">50</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scores</span>: HashMap&lt;_,_&gt; = <br>    teams.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(initial_scores.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="添加-1">添加</h3>
<p>insert()方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>),<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="所有权-1">所有权</h3>
<p>1、对于实现了Copy trait的类型（例如i32），值会被复制到HashMap中
2、对于拥有所有权的值（例如String），值会被移动，所有权会转移给HashMap
3、如果将值的引用插入到HashMap，值本身不会移动</p>
<h3 id="访问-1">访问</h3>
<p>get方法（返回Option&lt;&amp;T&gt;）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>),<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">team_name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">score</span> = scores.<span class="hljs-title function_ invoke__">get</span>(&amp;team_name);<br>    <span class="hljs-keyword">match</span> score&#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(s) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;team not exist&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="遍历-1">遍历</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    scores,<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>),<span class="hljs-number">50</span>);<br>    <br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> &amp;scores&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,k,v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="更新-1">更新</h3>
<p>1、HashMap大小可变 2、每个k对应一个v 3、更新数据
k已经存在，对应一个v： 替换现有的v 保留现有的v，忽略新的v
合并现存的v和新的v k不存在： 添加一对k，v</p>
<p>entry方法：检查指定的k是否对应一个v 参数为k，返回enum
Entry：代表值是否存在 or_insert方法： 如果k存在，返回到对应的v
的一个可变引用
如果k不存在，将方法参数作为k的新值插入进去，返回到这个值的可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    <br>    scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>)).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-comment">//let e = scores.entry(String::from(&quot;Yellow&quot;));</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,e);</span><br>    <span class="hljs-comment">//e.or_insert(50);</span><br>    scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>)).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,scores);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>字符串单词计数器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = <span class="hljs-string">&quot;hello wolrd wonderful world&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">split_whitespace</span>()&#123;<br>        <span class="hljs-comment">//返回value值的可变引用</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = map.<span class="hljs-title function_ invoke__">entry</span>(word).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>        *count += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,map);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="hash函数">Hash函数</h3>
<p>默认情况下，HashMap使用加密功能强大的Hash函数，可以抵抗拒绝服务（DOS）攻击
不是可用的最快的Hash算法，但具有更好的安全性</p>
<p>可以指定不同的Hasher来切换到另一个函数 hasher是实现BuildHasher
trait的类型</p>
<h3 id="计算长度">计算长度</h3>
<p>len() trait</p>
<h3 id="计算value的和">计算value的和</h3>
<p>values().sum::<T>()</p>
<h1 id="枚举">枚举</h1>
<h2 id="定义枚举">定义枚举</h2>
<p>IP地址：IPv4,IPv6</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//算是一种自定义类型</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span>&#123;<br>    V4,<br>    V6,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IpAddr</span>&#123;<br>    kind: IpAddrKind,<br>    address: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">four</span> = IpAddrKind::V4;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six</span> = IpAddrKind::V6;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddr&#123;<br>        kind: IpAddrKind::V4,<br>        address: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="将数据附加到枚举的变体中">将数据附加到枚举的变体中</h2>
<p>优点： 不需要使用额外的struct
每个变体可以拥有不同的类型以及关联的数据量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span>&#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>,<span class="hljs-type">u8</span>,<span class="hljs-type">u8</span>,<span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>    Move &#123;x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-number">127</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">loopback</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;::1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//标准库中的IpAddr</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ipv4Addr</span>&#123;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ipv6Addr</span>&#123;<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span>&#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(Ipv4Addr),<br>    <span class="hljs-title function_ invoke__">V6</span>(Ipv6Addr),<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&#123;<br>    Quit,<span class="hljs-comment">//无关联数据</span><br>    Move &#123;x: <span class="hljs-type">i32</span>,y: <span class="hljs-type">i32</span>&#125;,<span class="hljs-comment">//关联一个匿名结构体</span><br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = Message::Quit;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Message::Move&#123;x:<span class="hljs-number">12</span>,y:<span class="hljs-number">24</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;H&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="定义方法">定义方法</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&#123;<br>    Quit,<span class="hljs-comment">//无关联数据</span><br>    Move &#123;x: <span class="hljs-type">i32</span>,y: <span class="hljs-type">i32</span>&#125;,<span class="hljs-comment">//关联一个匿名结构体</span><br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>)&#123;&#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = Message::Quit;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Message::Move&#123;x:<span class="hljs-number">12</span>,y:<span class="hljs-number">24</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;H&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>);<br>    <br>    m.<span class="hljs-title function_ invoke__">call</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="打印枚举">打印枚举</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&#123;<br>    Quit,<br>    <span class="hljs-title function_ invoke__">Echo</span> (<span class="hljs-type">String</span>),<br>    Move &#123;x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>&#125;,<br>    <span class="hljs-title function_ invoke__">ChangeColor</span> (<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,<span class="hljs-keyword">self</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::Quit);</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::Echo);</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::Move);</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::ChangeColor);</span><br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">messages</span>: [Message;<span class="hljs-number">4</span>] = [<br>        Message::Move &#123;x:<span class="hljs-number">10</span>, y:<span class="hljs-number">30</span>&#125;,<br>        Message::<span class="hljs-title function_ invoke__">Echo</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>)),<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">200</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<br>        Message::Quit,<br>    ] <br>    <span class="hljs-keyword">for</span>  <span class="hljs-title class_">message</span>: &amp;Message <span class="hljs-keyword">in</span> &amp;messages&#123;<br>        message.<span class="hljs-title function_ invoke__">call</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="option枚举">Option枚举</h2>
<p>定义于标准库中，描述了某个值可能存在或不存在的情况
在预导入模块中，可直接使用</p>
<p>在rust中，没有null，但是有类似null概念的枚举也就是option</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt;&#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><span class="hljs-comment">//可直接使用</span><br><span class="hljs-comment">//Option&lt;T&gt;</span><br><span class="hljs-comment">//Some(T)</span><br><span class="hljs-comment">//None</span><br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_number</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;A String&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">absent_number</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br>    <span class="hljs-comment">//在定义None时，编译器无法确定变量类型，需要显式声明</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用Option<T>比null的好处：
Option<T>和T是不同的类型，如果要使用，必须将Option<T>转换成T</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six</span> = <span class="hljs-title function_ invoke__">plus_one</span>(five);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">none</span> = <span class="hljs-title function_ invoke__">plus_one</span>(none);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_one</span>(x: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;&#123;<br>    <span class="hljs-keyword">match</span> x&#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(i) =&gt; <span class="hljs-title function_ invoke__">Some</span>(i+<span class="hljs-number">1</span>),<br>        <span class="hljs-comment">//这里的i是临时创建的，可以表示Some中的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="错误处理">错误处理</h1>
<h2 id="概述">概述</h2>
<p>Rust的可靠性：大部分情况下，编译时提示错误并处理</p>
<p>错误的分类： 可恢复：例如文件未找到，可再次尝试
不可恢复：bug，例如访问的索引超出范围</p>
<p>Rust没有类似异常的机制： 可恢复错误：Result&lt;T,E&gt;
不可恢复错误：panic! 宏</p>
<h2 id="不可恢复错误">不可恢复错误</h2>
<p>当panic!宏执行： 1、程序会打印一个错误信息
2、展开（unwind）、清理调用栈（stack） 3、退出程序</p>
<p>为应对panic，展开或中止(abort)调用栈 默认情况下，当panic发生：
1、程序展开调用栈（工作量大）：Rust沿着调用栈往回走，清理每个遇到的函数中的数据
2、或立即中止调用栈：不进行清理，直接停止程序，内存需要OS进行清理</p>
<p>想让二进制文件更小，把设置从“展开”改为“中止”：
在Cargo.toml中的profile部分设置，panic = 'abort' 例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[profile.release]<br>panic = &#x27;abort&#x27;<br></code></pre></td></tr></table></figure>
<p>panic!可能出现在：我们写的代码中或我们所依赖的代码中
可通过调用panic!的函数的回溯信息来定位引起问题的代码。
通过设置环境变量RUST_BACKTRACE可得到回溯信息</p>
<h2 id="可恢复的错误">可恢复的错误</h2>
<h3 id="result枚举">Result枚举</h3>
<p>enum Result&lt;T, E&gt; { Ok(T), Err(E), }
T：操作成功情况下，Ok变体里返回的数据的类型
E：操作失败情况下，Err变体里返回的错误的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>()&#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)&#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>                <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error creating file: &#123;:?&#125;&quot;</span>, error),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error opening the file: &#123;:?&#125;&quot;</span>,other_error),<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用unwrap_or_else方法改良： 如果是Ok返回里面的变体
如果是Err调用后面的匿名函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error|&#123;<br>        <span class="hljs-keyword">if</span> error.<span class="hljs-title function_ invoke__">kind</span>() == ErrorKind::NotFound&#123;<br>            File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error|&#123;<br>                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="unwrap">unwrap</h3>
<p>match表达式的一个快捷方法： 如果Result结果是Ok，返回Ok里面的值
如果Result结果是Err，调用panic!宏</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">/*let f = File::open(&quot;hello.txt&quot;);</span><br><span class="hljs-comment">    let f = match f&#123;</span><br><span class="hljs-comment">        Ok(file) =&gt; file,</span><br><span class="hljs-comment">        Err(error) =&gt; &#123;</span><br><span class="hljs-comment">            panic!(&quot;Error opening file &#123;:?&#125;&quot;, error)</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;;*/</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="expect">expect</h3>
<p>和unwrap类似，但可指定错误信息</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">/*let f = File::open(&quot;hello.txt&quot;);</span><br><span class="hljs-comment">    let f = match f&#123;</span><br><span class="hljs-comment">        Ok(file) =&gt; file,</span><br><span class="hljs-comment">        Err(error) =&gt; &#123;</span><br><span class="hljs-comment">            panic!(&quot;Error opening file &#123;:?&#125;&quot;, error)</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;;*/</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;无法打开文件hello.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="传播错误">传播错误</h3>
<p>将错误返回给调用者</p>
<p>常规方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>,Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(error),<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-title function_ invoke__">Err</span>(error),<br>    &#125;<br>&#125;<br><span class="hljs-comment">//传播错误的Result枚举也可以是Result&lt;String, String&gt;</span><br><span class="hljs-comment">//或其他的</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">read_username_from_file</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>?运算符：传播错误的一种快捷方式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>,Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>()<span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>,io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果Result是Ok：Ok中的值就是表达式的结果，然后继续执行程序
如果Result是Err：Err就是整个函数的返回值，就像使用了return</p>
<p>?与from函数 Trait std::convert::From 上的from函数，用于错误之间的转换
被?所应用的错误,会隐式的被from函数处理，即它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</p>
<p>使用链式继续优化：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>,Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>,io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>?运算符只能用于返回Result的函数
main函数的默认返回类型是()，可以修改成返回Result类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><span class="hljs-comment">//Box&lt;dyn Error&gt;是trait对象，简单理解：任何可能的错误类型，这里如果是其他错误则写其他错误</span><br><span class="hljs-comment">//Box括号中的两个类型没有逗号</span><br></code></pre></td></tr></table></figure>
<h2 id="使用panic的时机">使用panic!的时机</h2>
<p>总体原则：
在定义一个可能失败的函数时，优先考虑返回Result，否则就panic!</p>
<p>编写示例、原型代码、测试代码可用unwrap、expect</p>
<p>可以确定Result是Ok，可以使用unwrap</p>
<p>错误处理的指导性建议： 当代码最终可能处于损坏状态时，最好使用panic!
损坏状态：某些假设、保证、约定或不可变性被打破
（例如非法的值、矛盾的值或空缺的值被传入代码，以及下列中的一条：这种损坏状态并不是预期能够偶尔发生的事情；在此之后，代码如果处于这种损坏状态就无法运行；在使用的类型中没有一个好的方法来将这些信息进行编码）</p>
<p>场景建议： 1、调用你的代码，传入无意义的参数值：panic!
2、调用外部不可控代码，返回非法状态，你无法修复：panic!
3、如果失败是可预期的：Result!
4、当你的代码对值进行操作，首先应该验证这些值：panic!</p>
<p>为验证创建自定义类型：
创建新的类型，把验证逻辑放在构造示例的函数里</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guess</span>&#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> || value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be between 1 and 100, got &#123;&#125;&quot;</span>, value);<br>        &#125;<br>        Guess &#123;value&#125;;<br>    &#125; <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">self</span>.value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="错误处理代码">错误处理代码</h2>
<h3 id="part1">part1</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ParsePosNonzeroError</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_creation</span>(err: CreationError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;<br>        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(err)<br>    &#125;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add another error conversion function here.</span><br>    <span class="hljs-comment">// fn from_parseint...</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_parseint</span>(err: ParseIntError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;<br>        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">ParseInt</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> change this to return an appropriate error instead of panicking</span><br>    <span class="hljs-comment">// when `parse()` returns an error.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i64</span> = s.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_parseint)?;<br>    PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="方法-2">方法</h2>
<h3 id="ok_or">ok_or</h3>
<p>接受一个参数，该参数是一个默认的错误值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">option_value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = option_value.<span class="hljs-title function_ invoke__">ok_or</span>(<span class="hljs-string">&quot;Default Error&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="ok_or_else">ok_or_else</h3>
<p>接受一个闭包作为参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">option_value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = option_value.<span class="hljs-title function_ invoke__">ok_or_else</span>(|| <span class="hljs-string">&quot;Defalut Error&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br></code></pre></td></tr></table></figure>
<p>ok_or方法更适合提供静态的错误值，而ok_or_else方法更适合提供需要计算的错误值。</p>
<h1 id="泛型">泛型</h1>
<h2 id="提取函数">提取函数</h2>
<p>作用：消除重复代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largerst</span>(list: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list &#123;<br>        <span class="hljs-keyword">if</span> item &gt; largerst &#123;<br>            largest = item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for item in list &#123;</span><br><span class="hljs-comment">    	if *item &gt; largerst &#123;</span><br><span class="hljs-comment">    		largest = *item; </span><br><span class="hljs-comment">    	&#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    largest<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number_list</span> = [<span class="hljs-number">34</span>,<span class="hljs-number">50</span>,<span class="hljs-number">25</span>,<span class="hljs-number">100</span>,<span class="hljs-number">65</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">largest</span>(&amp;number_list);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="简介-3">简介</h2>
<p>提高代码复用能力</p>
<p>泛型是具体类型或其他属性的抽象代替：
1、编写的代码不是最终的代码，而是一种模板，里面有一些“占位符”
2、编译器在编译时将“占位符”替换成具体的类型 例如：fn largest<T>(list:
&amp;[T]) -&gt; T {...}</p>
<p>示例代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largerst</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list &#123;<br>        <span class="hljs-comment">//这里的比较大小会报错，后面再了解</span><br>        <span class="hljs-keyword">if</span> item &gt; largerst &#123;<br>            largest = item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for item in list &#123;</span><br><span class="hljs-comment">    	if *item &gt; largerst &#123;</span><br><span class="hljs-comment">    		largest = *item; </span><br><span class="hljs-comment">    	&#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    largest<br>&#125;<br></code></pre></td></tr></table></figure>
<p>struct定义中的泛型可以使用多个泛型的类型参数，但太多类型参数说明你的代码需要重组为多个更小的单元：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T1, T2&gt; &#123;<br>    x: T1,<br>    y: T2,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>enum定义中的泛型，可以让枚举的变体持有泛型数据类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T,E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为struct或enum实现方法的时候， 可在定义中使用泛型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><span class="hljs-comment">//针对Point泛型实现的方法</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x1</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><span class="hljs-comment">//针对Point具体类型实现的方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x2</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>struct里的泛型类型参数可以和方法的泛型类型参数不同：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><span class="hljs-comment">//实现泛型结构体</span><br><span class="hljs-keyword">impl</span>&lt;T,U&gt; Point&lt;T,U&gt; &#123;<br>    <span class="hljs-comment">//泛型犯法</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mixup</span>&lt;V,W&gt;(<span class="hljs-keyword">self</span>, other: Point&lt;V,W&gt;) <span class="hljs-punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x,<br>            y: other.y,<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>泛型代码的性能：
1、使用泛型的代码和使用具体类型的代码运行速度是一样的
2、单态化：在编译时将泛型替换为具体类型的过程</p>
<h1 id="trait">Trait</h1>
<h2 id="简介-4">简介</h2>
<p>Trait告诉编译器某种类型具有哪些并且可以与其他类型共享的功能，抽象的定义共享行为，与其他语言的接口有点类似，但有些区别。</p>
<p>Trait bounds: 泛型类型参数指定为实现了特定行为的类型</p>
<h2 id="定义-1">定义</h2>
<p>把方法签名放在一起，来定义实现某种目的所需的一组行为。
1、只有方法签名，没有具体实现
2、trait可以有多个方法，每个方法签名占一行，以:结尾
3、实现该trait的类型必须提供具体的方法实现</p>
<p>示例：</p>
<p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize1</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>实现trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">pub</span> headline: <span class="hljs-type">String</span>, <br>    <span class="hljs-keyword">pub</span> location: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-comment">//NewsArticle可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.headline, <span class="hljs-keyword">self</span>.author, <span class="hljs-keyword">self</span>.location)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> reply: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-comment">//Tweet可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现trait的约束：
1、可以在某个类型上实现某个trait的前提条件是：这个类型或这个trait是在本地crate里定义的
2、无法为外部类型来实现外部的trait：
这个限制是程序属性的一部分（也就是一致性），更具体地说是孤儿原则，之所以这样命名是因为夫类型不存在。此规则确保其他人的代码不能破坏你的代码。
如果没有这个规则，两个crate可以为同一类型实现一个trait，rust就不知道应该使用哪个实现</p>
<p>默认实现代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-comment">//相当于c++中抽象类中函数的默认实现，即在抽象类（父类）方法中实现这个方法，这里也可以直接在接口实现方法</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>&#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Read more ...&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">pub</span> headline: <span class="hljs-type">String</span>, <br>    <span class="hljs-keyword">pub</span> location: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-comment">//NewsArticle可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> reply: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-comment">//Tweet可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Tweet</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="把trait作为函数参数">把trait作为函数参数</h2>
<p>示例代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">pub</span> headline: <span class="hljs-type">String</span>, <br>    <span class="hljs-keyword">pub</span> location: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-comment">//NewsArticle可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.headline, <span class="hljs-keyword">self</span>.author, <span class="hljs-keyword">self</span>.location)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> reply: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-comment">//Tweet可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//即可以传入NewsArticle，也可以传入Tweet,总而言之，可以传入实现了Summary这个trait的所有类型</span><br><span class="hljs-comment">//适用于简单的情况</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><br><span class="hljs-comment">//trait bound写法</span><br><span class="hljs-comment">//适用于复杂的情况，即传入参数多选trait bound</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>,item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><br><span class="hljs-comment">//指定多个trait bound</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> + Display)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary + Display&gt;(item: T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>,item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用where关键字优化代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notiyf</span>&lt;T: Summary + Display, U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>&gt;(a: T,b: U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify2</span>&lt;T,U&gt;(a:T, b:U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br><span class="hljs-keyword">where</span><br>	T: Summary + Display,<br>	U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>,<br>&#123;<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>,a.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="把trait当作返回类型">把trait当作返回类型</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-comment">//返回的类型只能是一个，不能是可能会出现两种类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="例子">例子</h2>
<p>修复上面的largest函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//PartialOrd trait用来比较，Copy用于基本类型的复制</span><br><span class="hljs-comment">//说明类型T实现了这两个trait</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt; (list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; largest &#123;<br>           largest = item; <br>        &#125;<br>    &#125;<br>    largest<br>&#125;<br><span class="hljs-comment">//如果要比较String</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt; (list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">clone</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> *item &gt; largest &#123;<br>           largest = item.<span class="hljs-title function_ invoke__">clone</span>(); <br>        &#125;<br>    &#125;<br>    largest<br>&#125;<br><span class="hljs-comment">//或</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt; (list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = &amp;list[<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; &amp;largest &#123;<br>           largest = item; <br>        &#125;<br>    &#125;<br>    largest<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以有条件地为实现了特定Trait的类型来实现方法：（即只有这个类型拥有了指定的Trait，才能使用这个方法）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T, y: Y) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>&#123;<br>        <span class="hljs-keyword">Self</span> &#123;x, y&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp_diplay</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt; <span class="hljs-keyword">self</span>.y &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.x);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也可以为实现了其他Trait的任意类型有条件地实现某个Trait，就是说某个类型如果实现了某个Trait，那么就为它实现另外一个Trait。</p>
<p>为满足Trait
Bound的所有类型上实现Trait叫做覆盖实现，就上面说的那句话的操作就是覆盖实现，</p>
<h1 id="生命周期">生命周期</h1>
<h2 id="简介-5">简介</h2>
<p>1、Rust的每个引用都有自己的生命周期 2、生命周期：引用保持有效的作用域
3、大多数情况：生命周期是隐式的、可被推断的
4、当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</p>
<p>生命周期的主要目标：避免悬垂引用</p>
<p>借用检查器：比较作用域判断所有的借用是否合法。（被借用的数据生命周期不小于借用数据的生命周期）</p>
<p>输入生命周期：函数/方法的参数 输出生命周期：函数/方法的返回值</p>
<h2 id="生命周期标注语法">生命周期标注语法</h2>
<p>无法比较时，需要显式注明生命周期：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(),string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-comment">//‘a的实际生命周期：</span><br><span class="hljs-comment">//x和y两个参数生命周期比较短的那个</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x : &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;a&#x27; <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期。</p>
<p>参数名：以'开头，通常全小写且非常短，很多人使用 'a 例子： &amp;i32
&amp;'a i32 &amp;'a mut i32 单个生命周期标注本身没有意义</p>
<h2 id="深入理解生命周期">深入理解生命周期</h2>
<p>指定生命周期参数的方式依赖于函数所做的事情：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(),string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-comment">//如果函数返回值只跟x有关，那不需要标注y的生命周期</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x : &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;a&#x27; <span class="hljs-type">str</span> &#123;<br>    x<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配，如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值，这就是悬垂引用，该值在函数结束时就走出了作用域：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(),string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x : &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;a&#x27; <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>    result.<span class="hljs-title function_ invoke__">as_str</span>();<br>&#125;<br><span class="hljs-comment">//如果想返回函数内创建的值，下面这样做</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>    result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="struct定义中的生命周期标注">Struct定义中的生命周期标注</h2>
<p>Struct里可以包括：自持有的类型；引用（需要在每个引用上添加生命周期标注）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//要保证里面的引用数据比sturct实例存活时间长</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcept</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">novel</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Call me Ishmael. Some years ago ...&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = ImportantExcept &#123;<br>        part: first_sentence,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="生命周期省略规则">生命周期省略规则</h2>
<p>在Rust引用分析中所编入的模式称为生命周期省略规则，这些规则无需开发者来遵循，它们是一些特殊情况，由编译器来考虑，如果你的代码符合这些特殊情况，那么就无需显式标注生命周期。</p>
<p>编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期，如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用，那就会报错。
这些规则适用于fn定义和impl块</p>
<p>规则： 1、每个引用类型的参数都有自己的生命周期
2、如果只有1个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数
3、如果有多个输入生命周期参数，但其中一个是&amp;self或&amp;mut
self（只适用于方法），那么self的生命周期会被赋给所有的输出生命周期参数</p>
<p>如果不遵循上面三个规则，就需要自己标注生命周期</p>
<p>方法定义中的生命周期标注
1、在struct上使用生命周期实现方法，语法和泛型参数的语法一样
2、在哪生命和使用生命周期参数，依赖于生命周期参数是否和字段、方法的参数和返回值有关
3、struct字段的生命周期名在impl后生命，在struct名后使用
4、生命周期省略规则经常使得方法中的生命周期标注不是必须的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcept</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcept&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">level</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">annouce_and_return_part</span>(&amp;<span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>. announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="静态生命周期">静态生命周期</h2>
<p>'static 是一个特殊的生命周期，即整个程序的持续时间。
例如：所有的字符串字面值都拥有'static生命周期</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>为引用指定'static生命周期前要三思：是否需要引用在程序整个生命周期内都存活</p>
<h2 id="例子-1">例子</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest_with_an</span>+announcement&lt;<span class="hljs-symbol">&#x27;a</span>,T&gt; (x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, ann: T) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span><br><span class="hljs-keyword">where</span><br>	T: Display,<br>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Anncouncement! &#123;&#125;&quot;</span>, ann);<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="测试">测试</h1>
<h2 id="简介-6">简介</h2>
<p>测试实际上就是一个函数，用来验证非测试代码的功能是否和预期一致</p>
<p>测试函数体通常执行的3个操作（3a）： 1、准备数据/状态
2、运行被测试的代码 3、断言(Assert)结果</p>
<p>如何使用：
测试函数需要使用test属性(attribute)进行标注，attribute就是一段Rust代码的元数据，在函数上加#[test]，可把函数变成测试函数</p>
<p>运行测试： 1、使用cargo test 命令运行所有测试函数，rust会构建一个test
runner 可执行文件，它会运行标注了test的函数，并报告其运行是否成功。
2、当使用cargo创建library项目时，会生成一个test
module，里面就有一个test函数。 3、你可以添加任意数量的test module 或
函数</p>
<p>测试失败： 1、测试函数panic就表示失败 2、每个测试运行在一个新线程
3、当主线程看见某个测试线程挂掉了，那个测试标记为失败了</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/* lib.rs */</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(left: <span class="hljs-type">usize</span>, right: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    left + right<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">another</span>() &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Make this test fail&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="断言assert">断言(assert)</h2>
<p>使用assert!宏检查测试结果，用来确定某个状态是否为true，如果返回false，调用panic，测试失败</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    length: <span class="hljs-type">u32</span>,<br>    width: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle)  <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.length &gt; other.length &amp;&amp; <span class="hljs-keyword">self</span>.width &gt; other.width<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">larger_can_hold_smaller</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">larger</span> = Rectangle &#123; length: <span class="hljs-number">8</span>, width: <span class="hljs-number">7</span> &#125;;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">smaller</span> = Rectangle &#123; length: <span class="hljs-number">5</span>, width: <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-built_in">assert!</span>(larger.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;smaller));<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">smaller_cannot_hold_larger</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">larger</span> = Rectangle &#123; length: <span class="hljs-number">8</span>, width: <span class="hljs-number">7</span> &#125;;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">smaller</span> = Rectangle &#123; length: <span class="hljs-number">5</span>, width: <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-built_in">assert!</span>(!smaller.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;larger));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用assert_eq!（相等）和assert_ne!（不等）测试相等性
断言失败：自动打印出两个参数的值，使用debug格式打印参数，要求参数实现了PartialEq和Debug
Traits（所有 基本类型和标准库里的大部分类型都实现了）</p>
<h2 id="自定义错误信息">自定义错误信息</h2>
<p>可以想assert!、assert_eq!、
assert_ne!添加可选的自定义信息，这些自定义信息和失败消息都会打印出来。</p>
<p>assert!：第一个参数必填，自定义消息作为第二个参数
assert_eq!和assert_nq!：前两个参数必填，自定义消息作为第三个参数</p>
<p>自定义消息参数会被传递给format!宏，可以使用{}占位符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <br></code></pre></td></tr></table></figure>
<h2 id="should_panic">should_panic</h2>
<p>验证错误处理的情况：
测试除了验证代码的返回值是否正确，还需验证代码是否如预期地处理了发生错误的情况。</p>
<p>可验证代码在特定情况下是否发生了panic</p>
<p>需要在代码中添加should_panic属性： 函数发生panic：测试通过
函数没有发生panic：测试失败</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guess</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> || value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be betwwen 1 and 100, got &#123;&#125;&quot;</span>, value);<br>        &#125;<br><br>        Guess &#123;<br>            value,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greater_than_100</span>() &#123;<br>        Guess::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>让should_panic更精确，为should_panic属性添加一个可选的expected参数，将检查失败消息中是否包含所指定的文字</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guess</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;&quot;</span>, value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>, value);<br>        &#125;<br><br>        Guess &#123;<br>            value,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greater_than_100</span>() &#123;<br>        Guess::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="在测试中使用result">在测试中使用Result</h2>
<p>无需panic，可使用Result&lt;T, E&gt;作为返回类型编写测试：
返回Ok：测试通过 返回Err：测试失败</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt;&#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span> &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;two plus does not equal four&quot;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：不要在使用Result&lt;T, E&gt;编写的测试上标注#<a
href="#should_panic">should_panic</a></p>
<h2 id="控制测试运行">控制测试运行</h2>
<p>改变cargo test的行为：添加命令行参数</p>
<p>如果不添加命令行参数，会执行默认行为： 1、并行运行所有测试
2、捕获（不显示）所有输出，使读取与测试结果相关的输出更容易</p>
<p>命令行参数： 1、针对cargo test的参数，紧跟在cargo test后
2、针对测试可执行程序：放在 --之后</p>
<p>cargo test --help（显示可以放在cargo test后面的参数） 和 cargo test
-- --help（显示可以放在cargo test --后面的参数）</p>
<h3 id="并行运行测试">并行运行测试</h3>
<p>默认使用多个线程并行运行</p>
<p>确保测试之间： 1、不会相互依赖
2、不依赖于某个共享状态（环境、工作目录、环境变量等等）</p>
<h3 id="test-threads-参数">--test-threads 参数</h3>
<p>1、传递给二进制文件
2、不想以并行方式运行测试，或想对线程数进行细粒度控制 3、可以使用
--test-threads 参数，后边跟着线程的数量</p>
<p>例如： cargo test -- --test-threads=1</p>
<h3 id="显式函数输出">显式函数输出</h3>
<p>默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容</p>
<p>例如：如果被测试段代码中用到了println!：
1、如果测试通过：不会在终端看到println!打印的内容
2、如果测试失败：会看到println!打印的内容和失败信息</p>
<p>如果想在成功的测试中看到打印的内容：cargo test -- --show-output</p>
<h2 id="按名称运行测试">按名称运行测试</h2>
<p>选择运行的测试：将测试的名称（一个或多个）作为cargo test的参数</p>
<p>运行单个测试：指定测试名 例子：cargo test 测试函数名称</p>
<p>运行多个测试：指定测试名的一部分（模块名也可以）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_two</span>(a: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_two_and_two</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, <span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">2</span>));<br>    &#125;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_three_and_two</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, <span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hundred</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">102</span>, <span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行多个测试： 1、cargo test add：
运行add_two_and_two和add_three_and_two两个测试 2、cargo test tests：
运行tests这个模块的测试</p>
<h2 id="忽略测试">忽略测试</h2>
<p>可以忽略运行比较耗时的测试</p>
<p>ignore属性</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[ignore]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">expensive_test</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>想要运行忽略的测试： cargo test -- --ignored</p>
<h2 id="测试的分类">测试的分类</h2>
<p>单元测试和集成测试</p>
<p>单元测试： 1、小、专注 2、一次对一个模块进行隔离的测试
3、可测试private接口</p>
<p>集成测试： 1、在库外部。和其他外部代码一样使用你的代码
2、只能使用public接口 3、可能在每个测试中使用到多个模块</p>
<h3 id="单元测试">单元测试</h3>
<p>单元测试用#[cfg(test)]标注：只有运行cargo test才编译和运行代码
集成测试则不需要#[cfg(test)]，集成测试在不同的目录</p>
<p>rust允许测试私有函数</p>
<h3 id="集成测试">集成测试</h3>
<p>在rust中，集成测试完全位于被测试库的外部</p>
<p>目的：是测试被测试库的多个部分是否能正确地一起工作</p>
<p>创建集成测试：创建tests目录，tests目录下的每个测试文件都是单独的一个crate（需要将被测试库导入）</p>
<p>无需标注#[cfg(test)]，tests目录被特殊对待，只有cargo
test，才会编译tests目录下的文件</p>
<p>运行指定的集成测试： 1、运行一个特定的集成测试： cargo test 函数名
2、运行某个测试文件内的所有测试：cargo test --test 文件名</p>
<p>如果想要在tests目录下创建其他辅助函数而不用进行测试运行，则在tests目录下重新创建一个文件夹，然后把辅助函数放在这个文件夹中。（文件命名可以为mod.rs）
（使用该模块要导入，在代码中用mod 文件夹名即可导入）</p>
<p>针对binary crate的集成测试： 如果项目是binary
crate，只有含有main.rs没有lib.rs，不能在tests目录下创建集成测试，无法把main.rs的函数导入作用域
只有library crate才能暴露函数给其他crate用，binary
crate意味着独立运行</p>
<h1 id="文件处理">文件处理</h1>
<h2 id="文件读取">文件读取</h2>
<p>用String类存储：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;文件读取失败！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="闭包">闭包</h1>
<h2 id="简介-7">简介</h2>
<p>闭包：可以捕获其所在环境的匿名函数</p>
<p>特性： 1、是匿名函数 2、保存为变量、作为参数
3、可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算
4、可从其定义的作用域捕获值</p>
<h2 id="例子-2">例子</h2>
<p>名称：生成自定义运动计划的程序</p>
<p>算法的逻辑并不是重点，重点是算法中的计算过程所耗费的时间</p>
<p>目标：仅在必要时调用该算法，只调用一次</p>
<p>原本代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">simulated_user_specified_value</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">simulated_random_number</span> = <span class="hljs-number">7</span>;<br><br>    <span class="hljs-title function_ invoke__">generate_workout</span>(simulated_user_specified_value, simulated_random_number);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">simulated_expensive_calculation</span>(intensity: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;正在计算……&quot;</span>);<br>    thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>    intensity<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity)<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity)<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity)<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第一步改进generate_workout函数：
（用变量存储函数的返回值，但是不需要的情况又造成浪费）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity);<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            result<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            result<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                result<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>用闭包改进： （可以用闭包的特性继续改进）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-comment">//这里只是定义了函数，并没有执行</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">expensive_closure</span> = |num: <span class="hljs-type">u32</span>| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;calculating slowly...&quot;</span>);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        num<br>    &#125;;<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">expensive_closure</span>(intensity)<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">expensive_closure</span>(intensity)<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                <span class="hljs-title function_ invoke__">expensive_closure</span>(intensity)<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="闭包类型推断和标注">闭包类型推断和标注</h2>
<p>闭包的类型推断： 1、闭包不要求标注参数和返回值的类型
2、闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型
3、可以手动添加类型标注
注意：闭包的定义最终只会为参数/返回值推断出唯一具体的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">example_closure</span> = |x| x;<br>    <br>    <span class="hljs-comment">//let s = example_closure(String::from(&quot;hello&quot;));</span><br>    <span class="hljs-comment">//let n = example_closure(5);</span><br>    <span class="hljs-comment">//取消第一个注释，编译器不会报错，并把x定义为String类型，取消第二个注释会报错，因为编译器已经把x定义为String类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="存储闭包">存储闭包</h2>
<p>使用泛型参数和fn trait来存储闭包</p>
<p>记忆化/延迟计算：
创建一个struct，它持有闭包及其调用结果，只会在需要结果时才执行该闭包，可缓存结果</p>
<p>如何让struct持有闭包：
struct的定义需要知道所有字段的类型：需要指明闭包的类型，每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样，所以需要使用泛型和trait
bound</p>
<p>fn traits由标准库提供 所有的闭包都至少实现了以下trait之一：Fn FnMut
FnOnce</p>
<p>改进上面的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>	T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt; <br><span class="hljs-keyword">where</span><br>	T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;<br>        Cacher &#123;<br>            calculation,<br>            value: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>,arg: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.value &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; v,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = (<span class="hljs-keyword">self</span>.calculation)(arg);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(v);<br>                v<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">expensive_closure</span> = Cacher::<span class="hljs-title function_ invoke__">new</span>(|num|&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;calculating slowly ...&quot;</span>);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        num<br>    &#125;);<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            expensive_closure.<span class="hljs-title function_ invoke__">value</span>(intensity)<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            expensive_closure.<span class="hljs-title function_ invoke__">value</span>(intensity)<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                expensive_closure.<span class="hljs-title function_ invoke__">value</span>(intensity)<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用Cacher实现的限制：
1、Cacher实例假定针对不同的参数arg，value方法总会得到同样的值，可以使用HashMap，key：arg参数，value：执行闭包的结果
2、只能接收一个u32类型的参数和u32类型的返回值</p>
<h2 id="使用闭包捕获上下文">使用闭包捕获上下文</h2>
<p>闭包可以捕获它们所在的环境：闭包可以访问定义它的作用域内的变量，而普通函数则不能。但会产生内存开销。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = |z| z == x;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>闭包从所在环境捕获值得方式： 与函数获得参数的三种方式一样：
1、取得所有权：FnOnce 2、可变借用：FnMut 3、不可变借用：Fn</p>
<p>创建闭包时，通过闭包对环境值的使用，rust能推断出具体使用哪个trait：
所有闭包都实现了FnOnce 没有移动捕获变量的实现了FnMut
无需可变访问捕获变量的闭包实现了Fn</p>
<p>move关键字：
在参数列表前使用move关键字，可以强制闭包取得它所使用的环境值得所有权。当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = <span class="hljs-keyword">move</span> |z| z == x; <br>    <span class="hljs-comment">//println!(&quot;can&#x27;t use x here: &#123;:?&#125;&quot;,x);</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最佳实践： 当指定Fn trait bound
之一时，首先用Fn，基于闭包体里的情况，如果需要FnOnce或FnMut，编译器会再告诉你</p>
<h1 id="迭代器">迭代器</h1>
<h2 id="简介-8">简介</h2>
<p>迭代器模式：对一系列执行某些任务</p>
<p>迭代器负责：遍历每个项；确定序列（遍历）何时完成</p>
<p>rust的迭代器：
懒惰的：除非调用消费迭代器的方法，否则迭代器本省没有任何效果</p>
<h2 id="iterator-trait和next方法">iterator trait和next方法</h2>
<h3 id="iterator-trait">iterator trait</h3>
<p>所有迭代器都实现了iterator trait</p>
<p>iterator trait定义与标准库，定义大致如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>type Item和 Self::Item定义了与此该trait关联的类型： 实现Iterator
trait需要你定义一个Item类型，它用于next方法的放回类型</p>
<h3 id="next">next</h3>
<p>每次返回迭代器中的一项，返回结果包裹在Some里，迭代结束，返回None</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iterator_demonstration</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1_iter</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>        <br>        <span class="hljs-built_in">assert_eq!</span>(v1_iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(v1_iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(v1_iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="几个迭代方法">几个迭代方法</h3>
<p>iter方法：在不可变引用上创建迭代器
into_iter方法：创建的迭代器会获得所有权 iter_mut方法：迭代可变的引用</p>
<h2 id="消耗产生迭代器">消耗/产生迭代器</h2>
<p>消耗迭代器的方法：
调用next方法的叫做“消耗型适配器”，因为调用它会把迭代器耗尽
例如：sum方法，取得迭代器的所有权，通过反复调用next，遍历所有元素，每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iterator_sum</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1_iter</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span>: <span class="hljs-type">i32</span> = v1_iter.<span class="hljs-title function_ invoke__">sum</span>();<br>        <span class="hljs-built_in">assert_eq!</span>(total,<span class="hljs-number">6</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>产生其他迭代器的方法： 定义在iterator
trait上的另外一些方法叫做”迭代器适配器“：把迭代器转换为不同种类的迭代器
可以通过链式调用使用多个迭代器适配器来执行复杂的操作，且可读性较高
例如：map，接收一个闭包，闭包作用于每个元素</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iterator_sum</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = v1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x|&#123;x+<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_ invoke__">collect</span>();<br>        <span class="hljs-built_in">assert_eq!</span>(v2, <span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>map方法是产生，接收一个闭包</p>
<p>collect方法：消耗性适配器，把结果收集到一个集合类型中，返回时Vec类型</p>
<h2 id="使用闭包捕获环境">使用闭包捕获环境</h2>
<p>filter方法： 接收一个闭包
这个闭包在遍历迭代器的每个元素时，返回bool类型
如果闭包返回true，当前元素将会包含在filter产生的迭代器中
如果闭包返回false，当前元素将不会包含在filter产生的迭代器中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shoe</span> &#123;<br>    size: <span class="hljs-type">u32</span>,<br>    style: <span class="hljs-type">String</span>, <br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">shoe_in_my_size</span>(shoes: <span class="hljs-type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;Shoe&gt; &#123;<br>    shoes.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|x| x.size == shoe_size).<span class="hljs-title function_ invoke__">collect</span>()<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">filter_by_size</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">shoes</span> = <span class="hljs-built_in">vec!</span>[<br>        Shoe &#123;<br>            size: <span class="hljs-number">10</span>,<br>            style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sneaker&quot;</span>),<br>        &#125;,<br>        Shoe &#123;<br>            size: <span class="hljs-number">13</span>,<br>            style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sandal&quot;</span>),<br>        &#125;,<br>        Shoe &#123;<br>            size: <span class="hljs-number">10</span>,<br>            style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boot&quot;</span>),<br>        &#125;<br>    ];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">in_my_size</span> = <span class="hljs-title function_ invoke__">shoe_in_my_size</span>(shoes, <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            in_my_size,<br>            <span class="hljs-built_in">vec!</span>[<br>                Shoe &#123;<br>                    size: <span class="hljs-number">10</span>,<br>                    style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sneaker&quot;</span>),<br>                &#125;,<br>                Shoe &#123;<br>                    size: <span class="hljs-number">10</span>,<br>                    style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boot&quot;</span>),<br>                &#125;<br>            ]<br>        );<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="创建自定义迭代器">创建自定义迭代器</h2>
<p>实现next方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;<br>    count : <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Counter &#123;<br>        Counter &#123;<br>            count: <span class="hljs-number">0</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实现Iterator这个trait</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.count &lt; <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-keyword">self</span>.count += <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.count)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_next_directly</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = Counter::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-literal">None</span>);<br>&#125;<br><br><span class="hljs-comment">//zip是将两个迭代器的元素分别组成一个元素然后放入集合</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">using_other_iterator_trait_methods</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span>: <span class="hljs-type">u32</span> = Counter::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">zip</span>(Counter::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">1</span>))<br>        .<span class="hljs-title function_ invoke__">map</span>(|(a,b)| a*b)<br>        .<span class="hljs-title function_ invoke__">filter</span>(|x| x%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>        .<span class="hljs-title function_ invoke__">sum</span>();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">18</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="循环和迭代器">循环和迭代器</h2>
<p>迭代器更快</p>
<p>零开销抽象：使用抽象时不会引入额外的运行时开销</p>
<p>放心多多使用迭代器</p>
<h2 id="迭代器方法">迭代器方法</h2>
<h3 id="join">join</h3>
<p>作用：将一个可迭代对象的元素连接成一个字符串的方法，它接受一个分隔符作为参数，并将可迭代对象中的每个元素以该分隔符连接起来，最终返回一个包含所有元素的字符串</p>
<p>函数签名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">join</span>&lt;Separator&gt;(&amp;<span class="hljs-keyword">self</span>, sep: Separator) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> <br><span class="hljs-keyword">where</span><br>	Separator: Display + <span class="hljs-built_in">Clone</span>,<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;rust&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = words.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;, &quot;</span>); <span class="hljs-comment">// 使用 &quot;, &quot; 作为分隔符</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result); <span class="hljs-comment">// 输出：hello, world, rust</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="product">product</h3>
<p>计算从1到num之间所有整数的成绩，并将结果存储在变量v中</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = (<span class="hljs-number">1</span>..=num).<span class="hljs-title function_ invoke__">product</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="智能指针">智能指针</h1>
<h2 id="简介-9">简介</h2>
<p>指针：一个变量在内存中包含的是一个地址（指向其他数据）</p>
<p>rust中最常见的指针就是引用&amp;</p>
<p>智能指针： 行为和指针相似 有额外的元数据和功能</p>
<p>引用计数智能指针类型：
1、通过记录所有者的数量，使一份数据被多个所有者同时持有
2、并在没有任何所有者时自动清理数据</p>
<p>智能指针的例子： 1、String和Vec
2、都拥有一片内存区域，且允许用户对其操作 3、还拥有元数据
4、提供额外的功能或保障（String保障其数据是合法的UTD-8编码）</p>
<p>智能指针的实现：
1、通常使用struct实现，并实现了Deref和Drop这两个trait 2、Deref
trait：允许智能指针struct的实例项引用一样使用 3、Drop
trait：允许你自定义当智能指针实例走出作用域时的代码</p>
<p>标准库中常见的智能指针： Box<T>：在heap内存上分配值
Rc<T>：启用多重所有权的引用计数类型
Ret<T>和RefMut<T>：通过RefCell<T>访问；在运行时而不是编译时强制借用规则的类型</p>
<p>内部可变模式： 不可变类型暴露出可修改其内部值的API</p>
<p>引用循环： 它们如何泄露内存，以及如何防止其发生</p>
<table>
<thead>
<tr>
<th></th>
<th>Box</th>
<th>Rc</th>
<th>refcell</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一数据的所有者</td>
<td>一个</td>
<td>多个</td>
<td>一个</td>
</tr>
<tr>
<td>可变性、借用检查</td>
<td>可变、不可变借用</td>
<td>不可变借用</td>
<td>可变、不可变借用</td>
</tr>
</tbody>
</table>
<p>Box和Rc都在编译时检查，RefCell在运行时检查</p>
<h2 id="box">Box</h2>
<p>最简单的智能指针： 1、允许在heap上存储数据
2、stack上是指向heap数据的指针 3、没有性能开销和没有其他额外的功能</p>
<p>常用场景：
1、在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小
2、当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制
3、使用某个值时，只关心它是否实现了特定的trait，而不关心它的具体类型</p>
<p>存储数据的简单例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b = &#123;&#125;&quot;</span>, b);<br>&#125;<span class="hljs-comment">//作用域结束b内存会释放</span><br></code></pre></td></tr></table></figure>
<p>使用Box赋能递归类型： 1、在编译时，rust需要知道一个类型所占空间的大小
2、而递归类型的大小无法在编译时确定 3、当Box类型的大小确定</p>
<p>关于Cons List： 1、来自Lisp语言的一种数据结构
2、两个元素：当前项的值，下一个元素
3、最后一个成员只包含Nil值，没有下一个元素</p>
<p>Cons List并不是rust的常用集合，而是Vec<T></p>
<p>使用Box来获得确定大小的递归类型：
Box<T>是一个指针，rust知道它需要多少空间，因为指针的大小不会基于它指向的数据的大小变化而变化（间接存储）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">1</span>,<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">2</span>,<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>,<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Nil))))));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Box<T>解引用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(x);<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>,x);<br>    <span class="hljs-built_in">assert_ne!</span>(<span class="hljs-number">5</span>,*y);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="deref-trait">Deref Trait</h2>
<p>1、实现Deref Trait使我们可以自定义解引用运算符*的行为
2、通过实现Deref，智能指针可像常规引用一样来处理</p>
<p>定义自己的智能指针：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; (T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(x);<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>,*y);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数和方法的隐式解引用转化：
1、隐式解引用转换是为函数和方法提供的一种便捷特性 2、假设T实现了Deref
trait：Deref Coercion 可以把T的引用转化为T经过Deref操作后生成的引用
3、当某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配：
Deref Coercion就会自动发生
编译器会对deref进行一系列调用，来吧它转为所需的参数类型，且在编译时完成，没有额外开销</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; (T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Rust&quot;</span>));<br><br>    <span class="hljs-comment">// &amp;m =&gt; &amp;MyBox&lt;Stirng&gt;</span><br>    <span class="hljs-comment">// deref =&gt; &amp;String</span><br>    <span class="hljs-comment">// deref =&gt; &amp;str</span><br>    <span class="hljs-title function_ invoke__">hello</span>(&amp;m);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello</span>(name: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;&#125;&quot;</span>,name);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解引用与可变性： 1、可使用DerefMut trait重载可变引用的*运算符
2、在类型和triat在下列三种情况发生时，rust会执行deref coercion： 当T:
Deref&lt;Target=U&gt;，允许&amp;T转换为&amp;U 当T:
DerefMut&lt;Target=U&gt;，允许&amp;mut T转换为&amp;mut U 当T:
Deref&lt;Target=U&gt;，允许&amp;mut T转换为&amp;U</p>
<h2 id="drop-trait">Drop Trait</h2>
<p>实现Drop Trait，可以让我们自定义当值将要离开作用域时发生的动作：
例如：文件、网络资源释放等 任何类型都可以实现Drop Trait</p>
<p>Drop Trait只要求你实现drop方法： 参数：对self的可变引用</p>
<p>Drop trait在预导入模块中，不用引入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    data: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping CustomSmartPointer with data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.data);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;My stuff&quot;</span>),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;other stuff&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;CustomSmartPointers created.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以使用std::mem::drop来提前drop值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//use std::mem::drop;可写可不写</span><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    data: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping CustomSmartPointer with data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.data);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;My stuff&quot;</span>),<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">drop</span>(c);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;other stuff&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;CustomSmartPointers created.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="rc引用计数智能指针">Rc引用计数智能指针</h2>
<p>只有当数据为零引用时，这个智能指针才会被清理</p>
<p>使用场景：
1、需要在heap上分配数据，这些数据被程序的多个部分读取（只读），但在编译时无法确定哪个部分使用完这些数据
2、Rc<T>智能用于单线程场景</p>
<p>Rc不在预导入模块 Rc::clone(&amp;a)函数：增加引用计数
Rc::strong_count(&amp;a)：获得引用计数（强引用），还有Rc::weak_count函数</p>
<p>例子： 两个List共享另一个List 的所有权：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, Rc&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">5</span>, <br>        Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">10</span>, <br>            Rc::<span class="hljs-title function_ invoke__">new</span>(Nil)))));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    <span class="hljs-comment">//使用引用不会获得a的所有权，使用clone函数增加Rc计数</span><br>    <span class="hljs-comment">//Rc::clone不会进行深度拷贝，增加效率</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">4</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after c gose out of scope = &#123;&#125;&quot;</span>,<br>        Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Rc通过<strong>不可变</strong>引用，使你可以在程序不同部分之间共享只读数据</p>
<h2 id="refcell和内部可变性">RefCell和内部可变性</h2>
<p>内部可变性： 1、是rust的设计模式之一
2、它允许你在只持有不可变引用的前提下对数据进行修改：
数据结构中使用了unsafe代码来绕过rust正常的可变性和借用规则</p>
<p>与Rc不同，RefCell类型代表了其持有数据的唯一所有权，但二者都只能适用于单线程场景</p>
<p>Box和RefCell的区别：
1、Box在编译阶段强制代码遵守借用规则，否则出现错误
2、RefCell只在运行时检查借用规则，否则触发panic</p>
<p>内部可变性：可变的借用一个不可变的值</p>
<p>没看懂，后面有需要再看： BV1hp4y1k7SV 的P91</p>
<h2 id="循环引用导致内存泄漏">循环引用导致内存泄漏</h2>
<p>使用Rc和RefCell接可能创造出循环引用，从而发生内存泄漏</p>
<p>没看懂，后面有需要再看： BV1hp4y1k7SV 的P92</p>
<h1 id="无畏并发">无畏并发</h1>
<h2 id="简介-10">简介</h2>
<p>concurrent：程序的不同部分之间独立地执行（并发）
parallel：程序的不同部分同时执行（并行）</p>
<p>本章统称为并发</p>
<p>rust无畏并发：允许编写没有细微bug的代码，并再不引入新bug的情况下易于重构</p>
<h2 id="多线程运行代码">多线程运行代码</h2>
<p>多线程导致的问题： 竞争状态：线程以不一致的顺序访问数据或资源
死锁：两个线程彼此等待对方使用完所持有的资源，线程无法继续
只有在某些情况下发生的bug，很难可靠地复制现象和修复</p>
<p>实现线程的方式： 1、通过调用OS的API来创建线程：1：1模型：
需要较小的运行时 2、语言自己实现的线程（绿色线程）：M：N模型：
需要更大的运行时</p>
<p>rust标准库只提供1：1模型</p>
<p>通过thread::spawn函数可以创建新线程：
参数：一个闭包（在新线程里运行的代码）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-comment">//没法等待所有线程的完成</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过join Handle等待所有线程的完成：
1、thread::spawn函数的返回值类型是JoinHandle
2、JoinHandle持有值得所有权：调用其join方法，可以等待对应的其他线程的完成
3、join方法：调用handle的join方法会阻止当前运行线程的执行，直到handle所表示的这些线程终结</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>)); <br>    &#125;<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 等待子线程结束</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用move闭包：
1、move闭包通常和thread::spawn函数一起使用，它允许使用其他线程的数据
2、创建线程时，把值的所有权从一个线程转移到另一个线程</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>,v);<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 等待线程结束</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="消息传递跨线程传递数据">消息传递跨线程传递数据</h2>
<p>Go语言的名言：不要用共享内存来通信，要用通信来共享内存</p>
<p>流行且能保证安全并发的技术：消息传递
线程通过彼此发送信息来进行通信</p>
<p>Channel： 1、发送端、接收端
2、如果两端中有一端被关闭，那Channel就被关闭</p>
<p>使用mpsc::channel函数创建Channel： mpsc表示multiple producer，single
consumer（多个生产者，一个消费者）
返回一个tuple，里面的元素分别是发送端、接收端</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>        tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">received</span> = rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>发送端send方法： 参数：想要发送的数据
返回：Result&lt;T,E&gt;，如果有问题，返回一个错误</p>
<p>接收端方法： 1、recv方法：阻止当前线程执行，直到Channel中有值被送来
一旦有值收到，就返回Result&lt;T, E&gt; 当发送端关闭，就会收到一个错误
2、try_recv方法，不会阻塞： 立即返回Result&lt;T, E&gt;
通常会使用循环调用检查try_recv的结果</p>
<p>当使用Channel发送数据值，该数据的所有权已经发送出去了</p>
<p>发送多个值，看到接受者在等待：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::btree_map::Values;<br><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx,rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;thread&quot;</span>),<br>        ];<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过克隆创建多个发布者：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::btree_map::Values;<br><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx,rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tx1</span> = mpsc::Sender::<span class="hljs-title function_ invoke__">clone</span>(&amp;tx);<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: thread&quot;</span>),<br>        ];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx1.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;thread&quot;</span>),<br>        ];<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="共享状态的并发">共享状态的并发</h2>
<p>Channel类似单所有权：一旦将值的所有权转移至Channel，就无法使用它
共享内存并发类似多所有权：多个线程可以同时访问同一块内存</p>
<p>使用Mutex来每次只允许一个线程访问数据 1、Mutex是mutual
exclusion（互斥锁）的简写
2、在同一时刻，Mutex只允许一个线程来访问某些数据 3、想要访问数据：
线程必须首先获取互斥锁，lock数据结构是mutex的一部分，它能跟踪谁对数据有用独占访问权
mutex通常被描述为：通过锁定系统来保护它所持有的数据</p>
<p>mutex的两条规则： 1、在使用数据之前，必须尝试获取锁
2、使用完mutex所保护的数据，必须对数据进行解锁，以便其他线程可以获取锁</p>
<p>Mutex<T>的API： 1、通过Mutex::new来创建（智能指针）
2、访问数据前，通过lock方法来获取锁 会阻塞当前线程 lock可能会失败
返回的是MutexGuard（智能指针）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">//要共享的数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num = <span class="hljs-number">6</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>多线程多重所有权： （错误的代码）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *num += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Counter: &#123;&#125;&quot;</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>多线程的多重所有权： Arc和Rc类似，但是它可以用于并发情景</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *num += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, temp);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也就是说，要共享的数据，就用Mutex<T>创建就可以了，然后再多个线程锁住它、使用它、解锁它</p>
<h2 id="send-和-sync-trait">Send 和 Sync trait</h2>
<p>Send：允许线程间转移所有权 只有Rc没有实现Send</p>
<p>Sync：允许从多线程访问 实现Sync类型可以安全的被多个线程引用
Mutex实现了Sync</p>
<p>手动来实现Send和Sync是不安全的</p>
<h1 id="模式匹配">模式匹配</h1>
<h2 id="简介-11">简介</h2>
<p>1、模式是rust中一种特殊语法，用于匹配复杂和简单类型的结构
2、将模式与匹配表达式和其他构造结合使用，可以更地控制程序的控制流
3、模式将由以下元素（的一些组合）组成：字面值、结构的数组、enum、struct和tuple、变量、通配符、占位符
4、想要使用模式，需要将其与某个值进行比较：如果模式匹配，就可以在代码中使用这个值的相应部分</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br>   	<span class="hljs-keyword">for</span>(index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>,value,index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>	<span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> (x,y,z) = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模式的两种形式">模式的两种形式</h2>
<p>不可辨驳的：能匹配任何可能传递的模式 例如：let x = 5;</p>
<p>可辩驳的：对某些可能的值，无法进行匹配的模式 例如：if let Some(x) =
a_value;</p>
<h2 id="语法">语法</h2>
<p>或：符号“|”</p>
<p>表示范围：..=</p>
<p>加条件：if关键字</p>
<h1 id="高级特性">高级特性</h1>
<h2 id="unsafe-rust">unsafe rust</h2>
<p>rust隐藏着第二个语言，它没有强制内存安全保证：Unsafe
rust和普通的rust一样，但是提供了额外的“超能力”</p>
<p>存在的原因： 1、静态分析是保守的：使用unsafe
rust：我知道自己在做什么，并承担相应风险
2、计算机硬件本身就是不安全的，rust需要能够进行底层系统编程</p>
<p>使用unsafe关键字来切换到unsafe
rust，开启一个块，里面放着unsafe代码</p>
<p>unsafe rust可执行的四个动作： 1、解引用原指针 2、调用unsafe函数或方法
3、访问或修改可变的静态变量 4、实现unsafe trait</p>
<p>注意： 1、unsafe并没有关闭借用检查或停用其他安全检查
2、任何内存安全相关的错误必须留在unsafe块里
3、尽可能隔离unsafe代码，最好将其封装在安全的抽象里，提供安全的API</p>
<p>原始指针： 可变的：<span class="math inline">\(*\)</span>mut T
不可变的：<span class="math inline">\(*const\)</span>
T。意味着解引用后不能直接对其进行赋值</p>
<p>与引用不同，原始指针：
1、允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针来忽略借用规则
2、无法保证指向合理的内存 3、允许为null 4、不实现任何自动清理
5、放弃保证的安全，换取更好的性能/与其他语言或硬件接口的能力</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r1: &#123;&#125;&quot;</span>, *r1);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r2: &#123;&#125;&quot;</span>, *r2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为什么要使用原始指针： 1、与C语言进行接口
2、构建借用检查器无法理解的安全抽象</p>
<p>unsafe函数或方法：在定义前加上了unsafe关键字：
1、调用前需要手动满足一些条件（主要靠看文档），因为rust无法对这些条件进行验证
2、需要在unsafe块里进行调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangerous</span>() &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>	<span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-title function_ invoke__">dangerous</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建unsafe代码的安全抽象：
1、函数包含unsafe代码并不意味着需要将整个函数标记为unsafe
2、将unsafe代码包裹在安全函数中是一个常见的抽象</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::slice;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">split_at_mut</span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], mid: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = slice.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = slice.<span class="hljs-title function_ invoke__">as_mut_ptr</span>();<br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        (slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),<br>         slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="hljs-title function_ invoke__">offset</span>(mid <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>), len - mid))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">let</span> (a, b) = <span class="hljs-title function_ invoke__">split_at_mut</span>(&amp;<span class="hljs-keyword">mut</span> v, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(a, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(b, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用extern函数调用外部代码：
1、extern关键字：简化创建和使用外部函数接口的过程
2、外部函数接口：它允许一种编程语言定义函数，并让其他编程语言能调用这些函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">abs</span>(input: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>; <span class="hljs-comment">// 声明外部函数</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">abs</span>(-<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从其他语言调用rust函数：
1、可以使用extern创建接口，其他语言通过它们调用rust函数
2、在fn前添加extern关键字，并指定ABI
3、还需添加#[no_mangle]注解：避免rust在编译时改变它的名称</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_from_c</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Just called a Rust function from C&quot;</span>);<br>&#125;<br><span class="hljs-comment">//可以被C语言调用，不需要unsafe</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>访问或修改一个可变静态变量：
1、rust支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争
2、在rust里，全局变量叫做静态变量</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> HELLO_WORLD: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-comment">//命名规范如上</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, HELLO_WORLD);<br>    <span class="hljs-comment">// 编译器会提示错误，因为不能修改一个`static`绑定</span><br>    <span class="hljs-comment">// HELLO_WORLD = &quot;Hello, Rust!&quot;;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>常量：允许使用它们的时候对数据进行复制 静态变量：
1、有固定的内存地址，使用它的值总会访问同样的数据
2、可以是可变的，访问和修改静态可变变量是不安全的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-type">u32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_count</span>(inc: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        COUNTER += inc;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">add_to_count</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实现不安全trait：
1、当某个trait中存在至少一个方法拥有编译器无法校验的不安全因素时，就称这个trait是不安全的
2、声明unsafe trait：在定义前加unsafe</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">i32</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高级trait">高级trait</h2>
<p>在trait定义中使用关联类型来指定占位类型：
关联类型是trait中的类型占位符，它可以用于trait的方法签名中：
可以定义出包含某些类型的trait，而在实现前无需知道这些类型是什么</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>关联类型与泛型的区别：</p>
<table>
<thead>
<tr>
<th>泛型</th>
<th>关联类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>每次实现triat时标注类型</td>
<td>无需标注类型</td>
</tr>
<tr>
<td>可以为一个类型多次实现某个trait</td>
<td>无法为单个类型多次实现某个trait</td>
</tr>
</tbody>
</table>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::path::Iter;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator2</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator2</span>&lt;<span class="hljs-type">u32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator2</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>默认泛型参数和运算符重载：
1、可以在使用泛型参数时为泛型指定一个默认的具体类型
2、语法：&lt;PlaceholderType=ConcreteType&gt;
3、这种技术常用于运算符重载
4、rust不允许创建自己的运算符及重载任意的运算符
5、但可以通过实现std::ops中列出的那些trait来重载一部分相应的预算符</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span> &#125; + Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span> &#125;, Point &#123; x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>指定默认类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Millimeter</span>(<span class="hljs-type">u32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meters</span>(<span class="hljs-type">u32</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span>&lt;Meters&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Millimeter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Millimeter;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Meters) <span class="hljs-punctuation">-&gt;</span> Millimeter &#123;<br>        <span class="hljs-title function_ invoke__">Millimeter</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br>    <br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span> () &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>调用同名方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Pilot</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Human</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Pilot</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is your captain speaking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Wizard</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Up!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*waving arms furiously*&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person</span> = Human;<br>    person.<span class="hljs-title function_ invoke__">fly</span>(); <span class="hljs-comment">// 调用结构体中的函数</span><br>    Pilot::<span class="hljs-title function_ invoke__">fly</span>(&amp;person);<br>    Wizard::<span class="hljs-title function_ invoke__">fly</span>(&amp;person);<br>    Human::<span class="hljs-title function_ invoke__">fly</span>(&amp;person); <span class="hljs-comment">// 调用关联函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法参数没有传入自身类型，使用完全限定语法：
1、可以在任何调用函数或方法的地方使用
2、允许忽略那些从其他上下文能推导出来的部分
3、当rust无法区分你期望调用哪个具体实现的时候，才需要使用这种语法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Spot&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;puppy&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dog: &#123;&#125;&quot;</span>, Dog::<span class="hljs-title function_ invoke__">baby_name</span>()); <span class="hljs-comment">// 输出 “Dog: spot”</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Animal: &#123;&#125;&quot;</span>, &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">baby_name</span>()); <span class="hljs-comment">// 输出 “Animal: puppy”</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>完全限定语法：<Type as Trait>::function()</p>
<p>使用supertrait来要求trait附带其他trait的功能：
需要在一个trait中使用其他trait的功能： 1、需要被依赖的triat也被实现
2、那个被间接依赖的trait就是当前trait的supertrait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">OutlinePrint</span>: fmt::Display &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">outline_print</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = output.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">4</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;* &#123;&#125; *&quot;</span>, output);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">4</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>    &#125;<br>&#125;<br>    <br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">OutlinePrint</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>使用newtype模式在外部类型上实现外部trait：
1、孤儿规则：只有当trait或类型定义在本地包时，才能为该类型实现这个trait
2、可以通过newtype模式来绕过这一规则： 利用tuple
struct创建一个新的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::&#123;<span class="hljs-keyword">self</span>, write&#125;;<br><br><span class="hljs-comment">//把vec包裹在wrapper中，可以实现display这个trait</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;[&#123;&#125;]&quot;</span>,<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;, &quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = <span class="hljs-title function_ invoke__">Wrapper</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>)]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;w = &#123;&#125;&quot;</span>, w);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高级类型">高级类型</h2>
<p>使用newtype模式实现类型安全和抽象： newtype模式可以：
1、用来静态地保证各种值之间不会混淆并表明值的单位
2、为类型的某些细节提供抽象能力
3、通过轻量级的封装来隐藏内部实现细节</p>
<p>使用类型别名创建类型同义词： 1、rust提供了类型别名的功能：
为现有类型生产另外的名称 并不是一个独立的类型 使用type关键字
2、主要用途：较少代码字符重复输入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Kilometers</span> = <span class="hljs-type">i32</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: Kilometers = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Thunk</span> = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_long_type</span>(f: Thunk) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Error;<span class="hljs-comment">//错误的类型的通称</span><br><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-comment">//type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;这个已经声明在std::io::Result&lt;T&gt;了</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = std::io::<span class="hljs-type">Result</span>&lt;T&gt;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Write</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">Write</span>(&amp;<span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">usize</span>&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">flush</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_all</span>(&amp;<span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_fmt</span>(&amp;<span class="hljs-keyword">self</span>, fmt: fmt::Arguments) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>Never类型： 1、有一个名为!的特殊类型： 它没有任何值，空类型
也称Never类型，因为它在不返回的函数中充当返回类型
2、不返回值的函数也称作发散函数
（Never类型可以是continue，可以是panic）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span> = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>            <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Sized trait: 为了处理动态大小的类型：rust提供了一个Sized
triat来确定一个类型的大小在编译时是否已知：
1、编译时可计算出大小的类型会自动实现这个trait
2、rust还会为每一个泛型函数隐式地添加Sized约束</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T&gt;(t: T) &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: <span class="hljs-built_in">Sized</span>&gt;(t: T) &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>默认情况下，泛型函数只能用于编译时已经知道大小的类型，可以通过特殊语法解除这一限制</p>
<p>即?Sized trait约束：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T&gt;(t: T) &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: <span class="hljs-built_in">Sized</span>&gt;(t: T) &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;<span class="hljs-comment">//可能不是Sized也可能是</span><br></code></pre></td></tr></table></figure>
<h2 id="高级函数和闭包">高级函数和闭包</h2>
<p>函数指针： 1、可以将函数传递给其他函数
2、函数在传递过程中会被强制转换成fn类型 3、fn类型就是“函数指针”</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do_twice</span>(f: <span class="hljs-title function_ invoke__">fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>, arg: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-title function_ invoke__">f</span>(arg) + <span class="hljs-title function_ invoke__">f</span>(arg)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">answer</span> = <span class="hljs-title function_ invoke__">do_twice</span>(add_one, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,answer);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数指针与闭包的不同：
1、fn是一个类型，不是一个trait：可以直接指定fn为参数类型，不用声明一个以Fn
trait为约束的泛型参数 2、函数指针实现了全部3中闭包trait：
总是可以把函数指针作为参数传递给一个接受闭包的函数
所以，倾向于搭配闭包trait的泛型来编写函数，可以同时接收闭包和普通函数
3、某些情景，只想接收fn而不接收闭包：
与外部不支持闭包的代码交互：C函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_numbers</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_strings</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = list_of_numbers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|i| i.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_numbers</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_strings</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = list_of_numbers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(<span class="hljs-built_in">ToString</span>::to_string).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>        <span class="hljs-title function_ invoke__">Value</span>(<span class="hljs-type">u32</span>),<br>        Stop,<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Status::<span class="hljs-title function_ invoke__">Value</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_statuses</span>:<span class="hljs-type">Vec</span>&lt;Status&gt; = (<span class="hljs-number">0u32</span>..<span class="hljs-number">20</span>)<br>        .<span class="hljs-title function_ invoke__">map</span>(Status::Value)<br>        .<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回闭包：
闭包使用trait进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该trait的具体类型作为返回值</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*fn return_closure() -&gt; Fn(i32) -&gt; i32 &#123;</span><br><span class="hljs-comment">    |x| x + 1</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_closure</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|x| x + <span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure>
<h1 id="类型转换">类型转换</h1>
<h2 id="as">as</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">average</span>(values: &amp;[<span class="hljs-type">f64</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = values.<span class="hljs-title function_ invoke__">iter</span>().sum::&lt;<span class="hljs-type">f64</span>&gt;();<br>    (total / values.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="as_mut">as_mut</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">num_sq</span>&lt;T: <span class="hljs-built_in">AsMut</span>&lt;<span class="hljs-type">u32</span>&gt;&gt;(arg: &amp;<span class="hljs-keyword">mut</span> T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement the function body.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = *arg.<span class="hljs-title function_ invoke__">as_mut</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">squared</span> = num * num;<br>    *arg.<span class="hljs-title function_ invoke__">as_mut</span>() = squared;<br>    squared<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="as_bytes">as_bytes()</h2>
<p>将字符串转换为一个字符数组（&amp;[u8]）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_bytes</span> = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="as_ptr">as_ptr()</h2>
<p>将目标转换为指针</p>
<p>例子：将C字符串转换为*const c_char</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;<br><span class="hljs-keyword">use</span> std::ffi:CString;<br><span class="hljs-keyword">use</span> libc::c_char;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = CString::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>:*<span class="hljs-keyword">const</span> c_char = a.<span class="hljs-title function_ invoke__">as_ptr</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="as_mut_ptr">as_mut_ptr()</h2>
<p>将目标转换为可变指针</p>
<h1 id="文件系统">文件系统</h1>
<h2 id="结构体">结构体</h2>
<h3 id="pathbuf">PathBuf</h3>
<p>用于操作路径的结构体，它提供了方便的方法来构建、操作和转换文件系统路径</p>
<p>定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PathBuf</span> &#123;<br>    inner: OsString,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OsString</span> &#123;<br>    inner: Buf,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::path::PathBuf;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">path</span> = PathBuf::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-comment">//添加路径</span><br>    path.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&quot;dir&quot;</span>);<br>    <span class="hljs-comment">//path.push(&quot;dir1&quot;);</span><br>    path.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Path: &#123;&#125;&quot;</span>, path.<span class="hljs-title function_ invoke__">display</span>());<span class="hljs-comment">//dir\file.txt</span><br><br>    <span class="hljs-comment">//在路径添加扩展名</span><br>    path.<span class="hljs-title function_ invoke__">set_extension</span>(<span class="hljs-string">&quot;dat&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Path: &#123;&#125;&quot;</span>, path.<span class="hljs-title function_ invoke__">display</span>());<span class="hljs-comment">//dir\file.dat</span><br><br>    <span class="hljs-comment">//获取路径的父目录</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(parent) = path.<span class="hljs-title function_ invoke__">parent</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Parent directory: &#123;&#125;&quot;</span>, parent.<span class="hljs-title function_ invoke__">display</span>());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;No parent directory found&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将路径转换为字符串</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path_str</span> = path.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Path as string: &#123;&#125;&quot;</span>,path_str);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="path">Path</h3>
<p>定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Path</span> &#123;<br>    inner: OsStr,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OsStr</span> &#123;<br>    inner: Slice,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = Path::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br></code></pre></td></tr></table></figure>
<h2 id="输入输出-1">输入输出</h2>
<h3 id="一些重命名">一些重命名</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = result::<span class="hljs-type">Result</span>&lt;T, Error&gt;;<br></code></pre></td></tr></table></figure>
<h1 id="优化相关">优化相关</h1>
<h2 id="编译器相关">编译器相关</h2>
<h3 id="coreintrinsicsunlikely">core::intrinsics::unlikely</h3>
<p>是一个用于指示编译器优化的内置函数(intrinsc)。它用于标记条件分支的分支预测，提示编译器某个分支的执行效率较低，以便编译器在生成机器代码时进行优化，使得执行效率高的分支更可能处于CPU流水线的“预取阶段”</p>
<p>当某一个执行效率明显高于另一个时，使用unlikely可以帮助编译器生成更优化的代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">unsafe</span> &#123; core::intrinsics::<span class="hljs-title function_ invoke__">unlikely</span>(condition) &#125; &#123;<br>    <span class="hljs-comment">// 条件为假的情况</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 条件为真的情况</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是一个unsafe函数。</p>
<h1 id="属性">属性</h1>
<h2 id="debug">debug</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[drive(Debug)]</span><br></code></pre></td></tr></table></figure>
<p>为结构体自动生成dubug
trait的实现，可以使得结构体使用"println!("{:?}",
locked_inode)等宏来打印调试信息</p>
<h1 id="内存管理">内存管理</h1>
<h2 id="弱引用">弱引用</h2>
<p>定义：弱引用不会阻止被引用对象被回收，如果被引用对象只有弱引用指向它，则可以自由地释放这个对象，即使还有弱引用指向它，因为弱引用==不会增加引用计数==。</p>
<p>功能：解决循环引用导致的内存泄漏问题，由于两个对象互相引用造成了循环引用，无法判断对象是否可以被释放</p>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Weak&#125;;<br><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    next: RefCell&lt;<span class="hljs-type">Option</span>&lt;Weak&lt;Node&gt;&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">node1</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>        next: RefCell::<span class="hljs-title function_ invoke__">new</span>(Nonw),<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">node2</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>        next: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">None</span>),<br>    &#125;);<br><br>    *node1.next.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;node2));<br>    *node2.next.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;node1));<br>    <span class="hljs-comment">//如果没有其他强引用指向它们，它们会被释放</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意事项：
确保不会在没有强引用的情况下使用弱引用指向的对象，否则可能会出现空指针错误</p>
<h2 id="原子引用计数">原子引用计数</h2>
<p>功能：用于在多线程环境中共享数据的所有权，提供一种安全地在多线程之间共享数据所有权的方式</p>
<p>引用计数：当Arc的引用计数为0时，它会释放内部数据并销毁自身。</p>
<p>内部可变性：与Rc类似，Arc不能提供内部可变性，如果需要在多线程环境下修改数据，可以使用Mutex、RwLock等同步原语结合Arc使用</p>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sycn::Arc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">data_clone</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;data);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Thread &#123;&#125;: &#123;:?&#125;&quot;</span>,i,data_clone);<br>        &#125;)<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/rust/" class="category-chain-item">rust</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/rust/" class="print-no-link">#rust</a>
      
        <a href="/tags/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/" class="print-no-link">#入门笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust入门学习笔记</div>
      <div>http://example.com/2024/12/29/Rust入门学习笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>凌云行者</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年12月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/12/29/ACPI-PM-Timer/" title="ACPI_PM_Timer">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ACPI_PM_Timer</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/12/29/C-%E4%B8%AD%E7%9A%84STL/" title="C++中的STL">
                        <span class="hidden-mobile">C++中的STL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/1037827920" target="_blank" rel="nofollow noopener"><span>个人Github</span></a> <i class="iconfont icon-comment"></i> <text>邮箱: 1037827920@qq.com</text> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        本站总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        本站总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
