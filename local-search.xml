<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何追踪追踪程序</title>
    <link href="/2025/05/19/%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F/"/>
    <url>/2025/05/19/%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="如何追踪追踪程序">如何追踪追踪程序</h1><p><strong>概述：</strong>就是如何去追踪自己写的ebpf程序的性能。举个例子，你写了一个ebpf程序，想要将其附加到内核函数后，看看内核函数的延迟变大了多少。</p><p><strong>说明：</strong>本文章以测试<code>tcp_v4_send_reset()</code>函数延迟为例子，我们可以知道<code>tcp_send_reset()</code>本身是作为一个tracepoint的，而且<code>tcp_v4_send_reset()</code>会调用它。所以我们将epbf程序通过tracepoint附加到<code>tcp_send_reset()</code>，通过kprobe/fentry附加到<code>tcp_v4_send_reset()</code>，只需要通过测试<code>tcp_v4_send_reset()</code>延迟即可比较二者性能差异</p><p><strong>相关仓库：</strong> - 测试负载代码仓库：https://github.com/1037827920/test-for-rstreason - ebpf程序代码仓库：https://github.com/1037827920/libbpf-template</p><p><strong>工具介绍：</strong> - <ahref="https://github.com/OpenCloudOS/perf-prof">perf-prof</a>，这是一个基于perf的工具，可以通过perfprobe来附加探针后进行统计内核函数运行时间。直接下载源码编译即可。 - <ahref="https://github.com/torvalds/linux/tree/master/tools/perf">perf</a>，用于系统性能调优，瓶颈定位和应用程序行为分析。利用硬件性能计数器(PMU)、软件事件、tracpoints、kprobes和uprobes等机制，提供对内核和用户空间的深入观察能力</p><h2 id="无探针情况">无探针情况</h2><p><strong>概述：</strong>首先我们要先测试在没有任何ebpf程序附加的情况下，内核函数的运行时间，以此来作为baseline。</p><p><strong>测试步骤：</strong> 1. 增加probe点： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf probe --add tcp_v4_send_reset<br>perf probe --add <span class="hljs-string">&quot;tcp_v4_send_reset%return&quot;</span><br></code></pre></td></tr></table></figure> 2.执行perf-prof工具： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf-prof multi-trace -e <span class="hljs-string">&quot;probe:tcp_v4_send_reset&quot;</span> -e <span class="hljs-string">&quot;probe:tcp_v4_send_reset__return&quot;</span><br></code></pre></td></tr></table></figure> 3. 执行测试负载： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库test-for-rstreason下的脚本</span><br>bash test-skb-performance.sh<br></code></pre></td></tr></table></figure></p><p><strong>测试结果：</strong> <img src="/2025/05/19/%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F/image-20250519115303350.png" class=""></p><h2 id="针对tracepoint类型">针对tracepoint类型</h2><p><strong>概述：</strong>在将ebpf程序附加到tracepoint上，测试内核函数的延迟</p><p><strong>测试步骤：</strong> 1.将ebpf程序附加到<code>tcp_send_reset()</code>tracepoint： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库libbpf-template examples/tracepoint/tcp_send_reset下的程序</span><br>./main<br></code></pre></td></tr></table></figure>2. 执行perf-prof工具： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf-prof multi-trace -e <span class="hljs-string">&quot;probe:tcp_v4_send_reset&quot;</span> -e <span class="hljs-string">&quot;probe:tcp_v4_send_reset__return&quot;</span><br></code></pre></td></tr></table></figure> 3. 执行测试负载： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库test-for-rstreason下的脚本</span><br>bash test-skb-performance.sh<br></code></pre></td></tr></table></figure></p><p><strong>测试结果：</strong> </p><h2 id="针对kprobe类型">针对kprobe类型</h2><p><strong>概述：</strong>在将ebpf程序附加到tracepoint上，测试内核函数的延迟。因为perfprobe机制其实就是通过给函数的入口和出口以kprobe的方式附加ebpf程序进行延迟计算，而内核是无法确定你注册的两个ebpf程序的执行顺序，所以在针对附加了kprobe类型ebpf程序的内核函数延迟计算，我想到的方法就是直接在要附加的ebpf程序的入口和出口都进行时间戳的记录然后计算delta值</p><p><strong>测试步骤：</strong> 1.将ebpf程序附加到<code>tcp_v4_send_reset()</code>kprobe： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库libbpf-template examples/kprobe/tcp_v4_send_reset下的程序</span><br>./main<br></code></pre></td></tr></table></figure>2. 执行perf-prof工具： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">perf-prof multi-trace -e <span class="hljs-string">&quot;probe:tcp_v4_send_reset&quot;</span> -e <span class="hljs-string">&quot;probe:tcp_v4_send_reset__return&quot;</span><br></code></pre></td></tr></table></figure> 3. 执行delta值计算脚本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库test-for-rstreason下的脚本</span><br>bash collect-delta.sh<br></code></pre></td></tr></table></figure> 4. 执行测试负载： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库test-for-rstreason下的脚本</span><br>bash test-skb-performance.sh<br></code></pre></td></tr></table></figure></p><p><strong>测试结果：</strong> </p><h2 id="结果">结果</h2><table><thead><tr><th>类型</th><th>无probe</th><th>tracepoint</th><th>kprobe</th></tr></thead><tbody><tr><td>时间(ns)</td><td>8.299</td><td>13.894</td><td>23.430</td></tr></tbody></table><p>可以看到kprobe的性能是要比tracepoint的差的</p><h2 id="fentry和kprobe谁先执行">fentry和kprobe谁先执行？</h2><p><strong>概述：</strong>在一开始的时候，作者想直接通过fentry的方式来计算带有kprobe类型ebpf程序的内核函数延迟，即通过funclatency（这是bcc中的一个工具）。但是想要这样测试，必须先验证一下二者的执行顺序，作者一开始没有做实验被坑惨了</p><p><strong>方法：</strong> 通过bpftrace快速编写ebpf程序进行测试</p><p><strong>测试步骤：</strong></p><ol type="1"><li>附加一个kprobe类型的ebpf程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">bpftrace -e <span class="hljs-string">&#x27;</span><br><span class="hljs-string">kprobe:tcp_v4_send_reset &#123;</span><br><span class="hljs-string">    debugf(&quot;kprobe Enter tcp_v4_send_reset&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">kretprobe:tcp_v4_send_reset &#123;</span><br><span class="hljs-string">    debugf(&quot;kretprobe Exit tcp_v4_send_reset&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>附加一个fentry类型的ebpf程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">bpftrace -e <span class="hljs-string">&#x27;</span><br><span class="hljs-string">kfunc:tcp_v4_send_reset &#123;</span><br><span class="hljs-string">    debugf(&quot;fentry Enter tcp_v4_send_reset&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">kretfunc:tcp_v4_send_reset &#123;</span><br><span class="hljs-string">    debugf(&quot;fexit Exit tcp_v4_send_reset&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>执行测试程序：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行仓库test-for-rstreason下的脚本</span><br>bash test-skb-reset-reason.sh<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>观察：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe<br></code></pre></td></tr></table></figure><p><strong>结果：</strong> <img src="/2025/05/19/%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E8%BF%BD%E8%B8%AA%E7%A8%8B%E5%BA%8F/image-20250519132704067.png" class=""></p><blockquote><p>可以看到是先执行kprobe类型的ebpf程序的，即使把kprobe和fentry的附加顺序换一下还是一样的结果</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ebpf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ebpf</tag>
      
      <tag>tracepoint</tag>
      
      <tag>kprobe</tag>
      
      <tag>tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统启动时开启选择内核菜单</title>
    <link href="/2025/05/18/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BC%80%E5%90%AF%E9%80%89%E6%8B%A9%E5%86%85%E6%A0%B8%E8%8F%9C%E5%8D%95/"/>
    <url>/2025/05/18/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BC%80%E5%90%AF%E9%80%89%E6%8B%A9%E5%86%85%E6%A0%B8%E8%8F%9C%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="系统启动时开启选择内核菜单">系统启动时开启选择内核菜单</h1><blockquote><p>也可以通过vnc登陆然后按esc</p></blockquote><p>修改<code>/etc/default/grub</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRUB_TIMEOUT_STYLE=menu      <span class="hljs-comment"># 强制显示菜单（非倒计时）</span><br>GRUB_TIMEOUT=60              <span class="hljs-comment"># 菜单显示10秒（可自定义）</span><br>GRUB_DEFAULT=saved           <span class="hljs-comment"># 不记住上次选择</span><br>GRUB_SAVEDEFAULT=<span class="hljs-literal">false</span>       <span class="hljs-comment"># 禁用自动保存选项</span><br></code></pre></td></tr></table></figure><p>使配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ubuntu</span><br><span class="hljs-built_in">sudo</span> update-grub<br><span class="hljs-comment"># centos</span><br>grub2-mkconfig -o /boot/grub2/grub.cfg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kernel</tag>
      
      <tag>reboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用lvm进行磁盘分区</title>
    <link href="/2025/05/17/%E4%BD%BF%E7%94%A8lvm%E8%BF%9B%E8%A1%8C%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <url>/2025/05/17/%E4%BD%BF%E7%94%A8lvm%E8%BF%9B%E8%A1%8C%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="使用lvm进行磁盘分区">使用lvm进行磁盘分区</h1><p><strong>目的：</strong>使用<code>/dev/vdb</code>创建一个5g的逻辑卷挂载到<code>/mnt/lvmtest</code></p><p><strong>前提：</strong><code>/dev/vdb</code>是一块干净的空磁盘，数据会被清空！！！</p><p><strong>1. 创建物理卷(PV)：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pvcreate /dev/sdb<br></code></pre></td></tr></table></figure><p><strong>2. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pvs<br></code></pre></td></tr></table></figure><p><strong>3. 创建卷组(VG)：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vgcreate vgtest /dev/vdb<br></code></pre></td></tr></table></figure><p><strong>4. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vgs<br></code></pre></td></tr></table></figure><p><strong>5. 创建逻辑卷(LV)：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lvcreate -L 10G -n lvtest vgtest<br></code></pre></td></tr></table></figure><p><strong>6. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lvs<br></code></pre></td></tr></table></figure><p><strong>7. 格式化并挂载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 /dev/vgtest/lvtest<br><span class="hljs-built_in">mkdir</span> -p /mnt/lvmtest<br>mount /dev/vgtest/lvtest /mnt/lvmtest<br></code></pre></td></tr></table></figure><p><strong>8. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h | grep lvmtest<br></code></pre></td></tr></table></figure><p><strong>9. 开机自动挂载：</strong></p><p>先查uuid：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">blkid /dev/vgtest/lvtest<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">/dev/vgdata/lvtest: <span class="hljs-type">UUID</span>=&quot;xxxx-xxxx&quot; <span class="hljs-keyword">TYPE</span>=&quot;ext4&quot;<br></code></pre></td></tr></table></figure><p>编辑<code>/etc/fstab</code>加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">UUID=xxxx-xxxx  /mnt/lvmtest  ext4  defaults  0 0<br></code></pre></td></tr></table></figure><p><strong>10. reboot验证</strong></p>]]></content>
    
    
    <categories>
      
      <category>磁盘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAID学习笔记</title>
    <link href="/2025/05/17/RAID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/05/17/RAID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p><strong>概述：</strong> RAID(Redundant Array of Independent Disks,独立磁盘冗余阵列)是一种将多个物理硬盘组合成一个逻辑单元的存储技术，旨在提升数据存储的性能、容量和可靠性。通过不同的组合方式（称为RAID级别），RAID可以实现数据冗余、提高读写速度或两者兼顾</p><p><strong>基本原理：</strong></p><ul><li>数据条带化：将数据分割并并行写入多个磁盘，提高读写性能</li><li>数据镜像：将相同的数据写入两块或多块磁盘，实现数据冗余，提高数据安全性</li><li>奇偶校验：通过计算校验信息存储在磁盘上，即使某一磁盘发生故障，也能通过校验信息恢复数据</li></ul><p><strong>实现方式：</strong></p><ul><li>硬件RAID：使用专用的RAID控制器卡来管理磁盘阵列，通常提供更高的性能和更多的高级功能，如热插拔、热备盘等</li><li>软件RAID：由操作系统通过软件方式实现RAID功能，例如linux中的<code>mdadm</code>工具，成本较低，灵活性高，但可能占用更多的cpu资源</li></ul><h1 id="raid级别">RAID级别</h1><h2 id="raid-0条带化">RAID 0(条带化)</h2><p><strong>最少磁盘数：</strong> 2</p><p><strong>特点：</strong>将数据分割并并行写入多个磁盘，提高读写性能，但不提供数据冗余，任一磁盘故障都会导致数据丢失</p><h2 id="raid-1镜像">RAID 1(镜像)</h2><p><strong>最少磁盘数：</strong> 2</p><p><strong>特点：</strong>将相同的数据写入两块磁盘，实现数据冗余，提高数据安全性，但存储利用率为50%</p><h2 id="raid-5带奇偶校验的条带化">RAID 5(带奇偶校验的条带化)</h2><p><strong>最少磁盘数：</strong> 3</p><p><strong>特点：</strong>数据和奇偶校验信息分布在所有磁盘上，提供较好的性能和容错能力，允许一块磁盘故障而不丢失数据</p><h2 id="raid-6双重奇偶校验">RAID 6(双重奇偶校验)</h2><p><strong>最少磁盘数：</strong> 4</p><p><strong>特点：</strong> 类似于RAID5，但增加了第二个奇偶校验块，允许同时两块磁盘故障而不丢失数据，提高了容错能力</p><h2 id="raid-10raid10">RAID 10(RAID1+0)</h2><p><strong>最少磁盘数：</strong> 4</p><p><strong>特点：</strong> 将RAID 1的镜像和RAID0的条带化结合，既提供高性能，又具有高数据冗余能力</p><h1 id="mdadm使用">mdadm使用</h1><h2 id="安装">安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install mdadm  <span class="hljs-comment"># 适用于 CentOS/RHEL</span><br><span class="hljs-built_in">sudo</span> apt install mdadm  <span class="hljs-comment"># 适用于 Debian/Ubuntu</span><br></code></pre></td></tr></table></figure><h2 id="创建软raid-0">创建软RAID 0</h2><p><strong>1. 检查两个硬盘是否有超级块：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -E /dev/sd[b-c]<br></code></pre></td></tr></table></figure><blockquote><p>没有超级块是正常的</p></blockquote><blockquote><p>这里可以对磁盘进行分区，这样的话可以让分区的磁盘来创建raid设备，而不是将整个裸磁盘来创建raid设备</p></blockquote><p><strong>2. 创建raid设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -Cv /dev/md0 -l raid0 -n 2 /dev/sd[b-c]<br></code></pre></td></tr></table></figure><ul><li>-C：--create，创建</li><li>-v：--verbose，输出详细创建过程的日志</li><li>-l：raid级别</li><li>-n：磁盘数量</li></ul><p><strong>3. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/mdstat<br></code></pre></td></tr></table></figure><blockquote><p>状态为active即正确</p></blockquote><p><strong>4. 检查两个磁盘是否有超级块：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -E /dev/sd[b-c]<br></code></pre></td></tr></table></figure><blockquote><p>有超级块是正常的</p></blockquote><p><strong>5. 查看raid设备详细信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -D /dev/md0<br></code></pre></td></tr></table></figure><p><strong>6. 给raid设备创建文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 /dev/md0<br></code></pre></td></tr></table></figure><p><strong>7. 挂载raid设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mnt/md0<br>mount /dev/md0 /mnt/md0<br></code></pre></td></tr></table></figure><p><strong>8. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p><strong>9. 配置启动自动挂载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/fstab<br><span class="hljs-comment"># /dev/md0/mnt/md0defaults0 0</span><br><br><span class="hljs-comment"># 使用一下命令验证</span><br>mount -a<br></code></pre></td></tr></table></figure><p><strong>10. 保存raid配置：</strong></p><blockquote><p>如果你想要重启raid设备，这一步是必须的。如果只是重启系统的话，并不会关闭raid设备，所以也可以不用这一步，如果你保证你的raid设备不会被关闭。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -E -s -v &gt;&gt; /etc/mdadm.conf<br><span class="hljs-built_in">cat</span> /etc/mdadm.conf<br></code></pre></td></tr></table></figure><h2 id="创建软raid-10">创建软RAID 10</h2><p><strong>1. 检查四个硬盘是否有超级块：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -E /dev/sd[b-e]<br></code></pre></td></tr></table></figure><blockquote><p>没有超级块是正常的</p></blockquote><p><strong>2. 创建raid设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -Cv /dev/md0 -l raid10 -n 4 /dev/sd[b-e]<br></code></pre></td></tr></table></figure><ul><li>-C：--create，创建</li><li>-v：--verbose，输出详细创建过程的日志</li><li>-l：raid级别</li><li>-n：磁盘数量</li></ul><p><strong>3. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/mdstat<br></code></pre></td></tr></table></figure><blockquote><p>状态为active即正确</p></blockquote><p><strong>4. 检查四个磁盘是否有超级块：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -E /dev/sd[b-c]<br></code></pre></td></tr></table></figure><blockquote><p>有超级块是正常的</p></blockquote><p><strong>5. 查看raid设备详细信息：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -D /dev/md0<br></code></pre></td></tr></table></figure><p><strong>6. 给raid设备创建文件系统：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.ext4 /dev/md0<br></code></pre></td></tr></table></figure><p><strong>7. 挂载raid设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mnt/md0<br>mount /dev/md0 /mnt/md0<br></code></pre></td></tr></table></figure><p><strong>8. 验证：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h<br></code></pre></td></tr></table></figure><p><strong>9. 配置启动自动挂载：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/fstab<br><span class="hljs-comment"># /dev/md0/mnt/md0defaults0 0</span><br><br><span class="hljs-comment"># 使用一下命令验证</span><br>mount -a<br></code></pre></td></tr></table></figure><p><strong>10. 保存raid配置：</strong></p><blockquote><p>如果你想要重启raid设备，这一步是必须的。如果只是重启系统的话，并不会关闭raid设备，所以也可以不用这一步，如果你保证你的raid设备不会被关闭。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -E -s -v &gt;&gt; /etc/mdadm.conf<br><span class="hljs-built_in">cat</span> /etc/mdadm.conf<br></code></pre></td></tr></table></figure><h2 id="删除软raid设备">删除软RAID设备</h2><p><strong>1. 卸载raid设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">umount /dev/md0<br></code></pre></td></tr></table></figure><p><strong>2. 关闭raid设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm -S /dev/md0<br></code></pre></td></tr></table></figure><p><strong>3. 卸载raid设备中的所有磁盘：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mdadm --misc --zero-superblock /dev/sd[b-c]<br></code></pre></td></tr></table></figure><h2 id="使用loop设备创建raid">使用loop设备创建raid</h2><p><strong>1. 创建几个用于模拟磁盘的文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /raid-test<br><span class="hljs-built_in">cd</span> /raid-test<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=disk1.img bs=100M count=10<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=disk2.img bs=100M count=10<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=disk3.img bs=100M count=10<br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=disk4.img bs=100M count=10<br></code></pre></td></tr></table></figure><p><strong>2. 通过loop设备将这些文件映射为块设备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">losetup -fP disk1.img<br>losetup -fP disk2.img<br>losetup -fP disk3.img<br>losetup -fP disk4.img<br></code></pre></td></tr></table></figure><p><strong>3. 查看分配结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">losetup -a<br></code></pre></td></tr></table></figure><p><strong>4. 然后创建raid的时候选择loop0-3设备即可</strong></p>]]></content>
    
    
    <categories>
      
      <category>磁盘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RAID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中的SMEP&amp;SMAP</title>
    <link href="/2025/03/06/Linux%E4%B8%AD%E7%9A%84SMEP/"/>
    <url>/2025/03/06/Linux%E4%B8%AD%E7%9A%84SMEP/</url>
    
    <content type="html"><![CDATA[<h1 id="smepsmap">SMEP/SMAP</h1><p><strong>概述：</strong>是x86处理器提供的硬件安全特性，目的是防止一些常见的内核攻击</p><h2 id="smep">SMEP</h2><blockquote><p>Supervisor Mode Execution Prevention</p></blockquote><p><strong>作用：</strong>防止内核模式代码意外或恶意执行位于用户空间的代码。</p><p><strong>实现方式：</strong>通过控制寄存器CR4中设置特定位（位20）来启用的。linux内核在启动时会检测CPU是否支持SMEP，如果支持，则在早期初始化阶段启用该特定。这样，即时由于漏洞泄露导致内核错误地跳转到用户空间地址，CPU也会产生异常，阻止这种执行。</p><h2 id="smap">SMAP</h2><blockquote><p>Supervisor Mode Access Prevention</p></blockquote><p><strong>作用：</strong>它禁止内核模式代码在没有明确许可的情况下访问用户空间内存。</p><p><strong>实现方式：</strong>通过控制寄存器CR4设置特定位（位21）来启用的。由于内核有时确实需要访问用户空间（例如执行copy_to_user/copy_from_user操作），内核在需要访问用户数据时，会暂时关闭SMAP保护。具体来说，内核会使用特殊的指令（如stac 和 clac）来临时禁用 SMAP，访问完成后再恢复保护状态。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>time</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux时间子系统学习笔记</title>
    <link href="/2025/03/06/Linux%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/06/Linux%E6%97%B6%E9%97%B4%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="时间子系统">时间子系统</h1><p><strong>概述：</strong>主要负责时间管理、时钟源选择、计时器事件处理、时间同步等核心功能。</p><h2 id="时钟源">时钟源</h2><h3 id="简介">简介</h3><p><strong>概述：</strong>是硬件计时器，用于提供高精度、连续不断的计数值，常用的时钟源包括TSC（跟cpu频率相关，且通过hpet等其他时钟源校准tsc频率）、HPET、ACPI定时器等。内核在启动过程中会探测可用的时钟源，并选择精度高、稳定性好的作为系统的主要时间计数器。</p><p><strong>作用：</strong>内核利用时钟源的计数值计算经过的时间，通过将计数器的变化量转换为实际时间（通常通过除以配置的时钟频率CONFIG_HZ），从而维护系统时间和其他时间相关功能。</p><p><strong>物理时钟源：</strong></p><ul><li>rtc：独立于CPU的实时时钟，通常用于保存系统时间。由电池供电，即使在系统断电时也能持续运行。系统会在启动时从RTC读取当前时间，作为系统时间的初始值，并在关机或定期校正时将系统时间写回RTC。</li><li>tsc：x86CPU内置的时间戳计数器，精度高但可能不稳定（多核同步问题）</li><li>hpet：高精度定时器</li><li>acpi pm timer：用于acpi电源管理，精度低但稳定</li></ul><p><strong>虚拟时钟源：</strong></p><ul><li>kvm-clock：KVM提供的高效时钟源，适用于KVM/QEMU虚拟机，减少VM-Exit，提高精度</li><li>xen-clocksource：Xen虚拟机环境下的时钟源</li><li>hypervclock：Microsoft Hyper-V提供的时钟源</li></ul><p><strong>时钟源选择：</strong></p><ul><li>通过/sys/devices/system/clocksource/clocksource0/current_clocksource选择时钟源</li><li>cat /proc/uptime也可以间接反映时钟源的精度</li></ul><h3 id="tsc">TSC</h3><p><strong>概述：</strong> 现代cpu通常支持invarianttsc，即TSC的计数速率固定，不受CPU频率变化影响，如果硬件满足这一条件，linux内核通常会优先选择TSC作为主时钟源，因为其开销低且读取迅速</p><p><strong>怎么读取tsc值：</strong></p><ul><li>直接使用汇编指令<code>rdtsc</code>：tsc是一个64位的寄存器，自系统启动后开始计数，每个时钟周期递增。rdtsc的作用就是将这个计数器的当前值读取出来。</li><li>内核态中可以使用<code>tsc_read_refs</code>函数：这个在上面汇编指令的基础上进一步做一个高级抽象的时钟源，原因：<ul><li>linux内核不仅可能使用tsc，也可能使用hpet等其他时钟源，这样做抽象方便管理</li><li>校准与转换：直接读取返回的是时钟周期数，要需要进一步进行转换为标准的时间单位（如纳秒），以便在调度、定时器和用户空间应用中使用一致的时间格式</li><li>保证单调性与跨核一致性：多核系统中，各个核心tsc可能不同步或存在细微差别，在tsc抽象实现中会采取相应措施保证单调性和一致性（比如rdtsc指令本身是非序列化的，可以配合其他指令（CPUID或RDTSCP）确保时间戳读取的顺序）</li></ul></li><li>用户态可以使用<code>clock_gettime</code>系统调用：linux内核一般会选tsc</li></ul><h3 id="稳定性检测">稳定性检测</h3><p><strong>频率漂移检测：</strong></p><ul><li>内核会定期测量不同时钟源的频率，并对比它们之间的偏差</li><li>例如，TSC可能会受到CPU频率调节影响，因此会与HPET、ACPI PMTimer等参考时钟进行对比</li><li>若发现某个时钟源的频率偏差超出允许范围，则可能会被降级或禁用</li></ul><p><strong>单调性检查：</strong>内核会确保时钟源的时间值是单调递增的，不能出现回退现象</p><p><strong>时间跳变检测：</strong>通过定期对比系统时间与参考时钟（如NTP服务器），检测是否出现了异常跳变</p><p><strong>多核一致性检测：</strong>对于TSC，linux会检测多个CPU核心的TSC是否同步，以防止不同核心返回的TSC不一致</p><p><strong>定期重新校准：</strong>linux可能会周期性地使用hpet活外部时钟（NTP）重新校准TSC</p><h3 id="kvm-clock">kvm-clock</h3><p><strong>概述：</strong>KVM提供的一个半虚拟化时钟源，其核心目的是为guestos提供一个高效、低开销、尽可能准确的计时机制。避免传统硬件时钟（如TSC、HPET）在虚拟化场景中可能遇到的同步、漂移或性能问题。【本质上其实也依赖于TSC吧，只是依赖的hostos的tsc，可能误差更小】</p><p><strong>工作原理：</strong></p><ul><li>共享内存区域：<ul><li>GuestOS在初始化时会为kvm-clock分配一段共享内存，这块内存区域是由hypervisor（例如qemu/kvm）映射给guest</li><li>该区域存储一个数据结构（<code>pvclock_vcpu_time_info</code>），其中包含当前的tsc值，系统时间、以及一些转换参数（如<code>tsc_to_system_mul</code>和<code>tsc_shift</code>）</li><li>Guest通过读取这个共享区域，就可以直接获得当前时间，而不需要进行昂贵的系统调用或VMExit</li></ul></li><li>主机与客机时间同步：<ul><li>Hypervisor定期更新这块共享内存区域，确保guest看到的时间与host系统时间保持一致</li><li>不仅降低了guestos对硬件时钟的依赖，而且可以减少虚拟化带来的时间漂移问题</li></ul></li><li>效率与精度：<ul><li>由于 kvm-clock 利用共享内存而非每次调用硬件寄存器（如TSC），因此能够避免频繁的虚拟机退出（VM Exit），降低延迟。</li><li>同时，通过对 TSC 值进行适当转换，kvm-clock能够提供一个相对稳定、单调递增的时钟源，即使在 CPU频率变动或多核环境下也能维持较高的精度。</li></ul></li></ul><p><strong>实现细节：</strong></p><ul><li><p>数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pvclock_vcpu_time_info</span> &#123;</span><br>    u32   version;<br>    u32   pad0;<br>    u64   tsc_timestamp;<br>    u64   system_time;<br>    u32   tsc_to_system_mul;<br>    s8    tsc_shift;<br>    u8    flags;<br>    u8    pad[<span class="hljs-number">2</span>];<br>&#125; __attribute__((__packed__));<br></code></pre></td></tr></table></figure><ul><li>version：用于保证读取时的一致性（类似双缓冲机制）</li><li>tsc_timestamp：记录了上次更新时间时的 TSC 值。</li><li>system_time：对应的系统时间（通常以纳秒为单位）</li><li>tsc_to_system_mul和tsc_shift：用于将 TSC增量转换为系统时间的比例因子</li></ul></li><li><p>更新策略：Hypervisor并不会在每次时间查询时都更新这块区域，而是在关键事件（如 VM启动、迁移、或其他时间敏感操作后）进行更新，以减少性能开销。</p></li></ul><p><strong>优缺点：</strong></p><ul><li><p>优点：</p><ul><li>低开销：共享内存的访问非常快，避免了 VM Exit</li><li>高效性：减少了依赖传统硬件时钟带来的额外延迟</li><li>单调性：提供一个单调递增的时间源，对时间敏感型应用（例如网络协议、会话管理）非常关键</li></ul></li><li><p>缺点：</p><ul><li><p>依赖host os更新：如果 hypervisor 更新不及时，guest可能会遇到时间漂移问题。</p></li><li><p>特殊场景问题：在某些情况下（如热添加 CPU 等操作），kvm-clock可能会暴露出时间回退或不一致的问题，需要内核补丁或额外配置加以解决</p><blockquote><p>新加入的vCPU并不会立即与已有的vCPU同步它们的kvm-clock状态</p></blockquote></li></ul></li></ul><h2 id="时钟事件">时钟事件</h2><h3 id="简介-1">简介</h3><p><strong>功能：</strong>时钟事件设备负责生成定时中断，用以触发内核中断各类定时任务，例如，任务调度、定时器超时处理以及高精度定时器的触发都依赖于时钟事件设备（比如APIC定时器设备）</p><p><strong>抽象接口：</strong>linux为了兼容不同硬件平台，定义了统一的时钟事件接口，这样无论底层硬件如何差异化，内核上层的定时器管理和调度代码都能以相同的方式调用，极大提高代码的可移植性和维护性</p><h2 id="计时器">计时器</h2><p><strong>周期性计时器：</strong></p><ul><li>jiffies：是一个全局计时变量，用来记录自系统启动以来经过的时钟tick数，虽然jiffies本身不是以秒为单位的，但通过与时钟频率(HZ)的结合，可以方便地将其转换为秒数或其他时间单位。本身单位是ticks，在内核中通过HZ来定义，一个tick通常是100或1000，这意味着每秒会有100或1000次jiffies更新，可以说是0.1ms或1ms（而HPET和ACPIPM Timer的单位为ns，可见精度更高）</li><li>tickless（NO_HZ模式）：允许系统在空闲时关闭定时器，降低功耗。系统在空闲状态下不再产生周期性中断，而是根据定时器的到期时间动态安排中断，从而减少不必要的中断开销，并改善系统在低功耗状态下的表现。</li></ul><p><strong>高精度计时器：</strong></p><ul><li>提供纳秒级精度，例如hpet等</li></ul><p><strong>定时器中断：</strong></p><ul><li>由硬件触发，如APIC timer、PIT（可编程间隔定时器）</li></ul><h2 id="时间管理">时间管理</h2><h3 id="系统时间">系统时间</h3><p><strong>墙上时间：</strong>指的是系统的“当前时间”，通常由<code>CLOCK_REALTIME</code>表示。反映了真实世界的时间，这个时间可以通过系统管理员手动设置、从硬件实时时钟(RTC)读取，或者通过网络时间协议（NTP）以及HPET等进行矫正</p><p><strong>单调时间：</strong>是一个只会不断递增、不受外部时间调整影响的时间计数。通常由CLOCK_MONOTONIC提供，主要特点：</p><ul><li>始终递增：无论系统时间如何调整，它总是保证不会倒退</li><li>适合测量时间间隔：用于计算事件之间的持续时间、超时或调度，而不必担心因墙上时间被修改而导致错误</li></ul><p><strong>二者区别：</strong></p><ul><li>使用场景：<ul><li>墙上时间：适合需要显示或记录“真实”时间的应用，如日志记录、文件时间戳、用户界面显示等</li><li>单调时间：适合需要精确测量事件间隔的长i纪念馆，如性能测试、任务调度、超时管理等</li></ul></li><li>底层实现：<ul><li>墙上时间：依赖于硬件时钟(RTC)以及系统软件对时间的同步和矫正机制</li><li>单调时间：依赖于系统内部的高精度计时器（如TSC、HPET或其他硬件时钟），并经过内核抽象层保证其单调性和一致性</li></ul></li></ul><h3 id="时钟同步">时钟同步</h3><p><strong>NTP与时间平滑调整：</strong>系统时间可能会因网络时间同步(NTP)而进行调整，为了防止时间突然跳变（如突然回调或前移），内核采用slewing算法来平滑调整系统时间，使得时间校正过程对应用层的影响降到最低</p><p><strong>多处理器同步：</strong>在SMP系统中，确保各个CPU核心时间一致性是非常关键的。内核通过同步机制使得所有核心共享同一时间基准，避免因各核心时间不同步而引发调度和资源竞争问题</p><h2 id="watchdog">Watchdog</h2><p><strong>目的：</strong>确保系统使用的时钟源稳定且精确。因为时钟源直接影响到系统时间的计算和更新，所以必须排除那些在短时间内发生大幅偏差的不可靠时钟源</p><p><strong>背景：</strong>在系统启动过程中，内核会注册多个clocksource，每个clocksource都会被赋予一个rating，表示它的精度和稳定性。为了避免由于硬件故障或环境因素导致某个时钟源计数异常，内核引入了watchdog机制来动态监控各个clocksource的表现</p><p><strong>实现原理：</strong></p><ol type="1"><li>周期性检测：watchdog会定期检查所有支持watchdog功能的clocksource。他会读取当前的周期计数值，并与前一次检查时保存的值进行比较</li><li>预期增量计算：根据clocksource的已知频率、mult和shift参数，内核可以将计数器的增量转换为经过的时间，此时就有一个“预期”的时间增量值</li><li>偏差比较：如果实际读出的增量与预期值之间的差异超过了预定义的阈值，则认为该时钟源存在问题。</li><li>动态降级与选择：在检测到偏差过大时，watchdog会降低clocksource的rating，从而防止它被选为当前系统的主要时钟源。然后watchdog会选择rating更高的时钟源作为系统时间的基础</li></ol><blockquote><p>简单来说，所有支持watchdog的clocksource都会被加入一个list，内核利用定时器或专用内核线程定期遍历该列表</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>time</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间通信的方式</title>
    <link href="/2025/02/27/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/02/27/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="进程间通信的方式">进程间通信的方式</h1><h2 id="管道">管道</h2><p><strong>概述：</strong>用于在父子进程之间传递数据，管道在操作系统内部提供了一个缓冲区，进程可以通过该缓冲区交换数据</p><p><strong>形式：</strong></p><ul><li>匿名管道：用于父子进程之间的通信</li><li>命名管道(FIFO)：允许无关的进程之间进行通信</li></ul><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-comment">// 创建管道</span><br>    pipe(pipefd);<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        close(pipefd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        read(pipefd[<span class="hljs-number">0</span>], buffer, <span class="hljs-keyword">sizeof</span>(buffer)); <span class="hljs-comment">// 读取管道数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child received: %s\n&quot;</span>, buffer);<br>        close(pipefd[<span class="hljs-number">0</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(pipefd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        write(pipefd[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Hello from parent&quot;</span>, <span class="hljs-number">18</span>); <span class="hljs-comment">// 写入管道</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息队列">消息队列</h2><p><strong>概述：</strong>允许不同的进程之间通过发送和接收消息进行通信，消息队列支持异步通信，发送者和接收者可以不在同一时刻，通过FIFO的方式排列消息</p><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mqueue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_NAME <span class="hljs-string">&quot;/example_queue&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">mqd_t</span> mq;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mq_attr</span> <span class="hljs-title">attr</span>;</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br><br>    <span class="hljs-comment">// 创建消息队列</span><br>    attr.mq_flags = <span class="hljs-number">0</span>;<br>    attr.mq_maxmsg = <span class="hljs-number">10</span>;<br>    attr.mq_msgsize = <span class="hljs-number">256</span>;<br>    attr.mq_curmsgs = <span class="hljs-number">0</span>;<br><br>    mq = mq_open(QUEUE_NAME, O_CREAT | O_RDWR, <span class="hljs-number">0644</span>, &amp;attr);<br>    <span class="hljs-keyword">if</span> (mq == (<span class="hljs-type">mqd_t</span>)<span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mq_open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 发送消息</span><br>    <span class="hljs-type">char</span>* message = <span class="hljs-string">&quot;Hello, message queue!&quot;</span>;<br>    <span class="hljs-keyword">if</span> (mq_send(mq, message, <span class="hljs-built_in">strlen</span>(message) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;me_send&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 接收消息</span><br>    <span class="hljs-keyword">if</span> (mq_receive(mq, buffer, <span class="hljs-number">256</span>, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mq_receive&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, buffer);<br><br>    <span class="hljs-comment">// 关闭和删除消息队列</span><br>    mq_close(mq);<br>    mq_unlink(QUEUE_NAME);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享内存">共享内存</h2><p><strong>概述：</strong>允许多个进程直接访问同一块内存区域，通过共享内存，不同进程可以以读写的方式直接修改共享区域的数据</p><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHM_NAME <span class="hljs-string">&quot;/shm_example&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> shm_fd;<br>    <span class="hljs-type">char</span>* shm_ptr;<br><br>    <span class="hljs-comment">// 创建共享内存对象</span><br>    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="hljs-number">0666</span>);<br>    ftruncate(shm_fd, <span class="hljs-number">256</span>); <span class="hljs-comment">// 设置共享内存大小</span><br><br>    <span class="hljs-comment">// 映射共享内存</span><br>    shm_ptr = mmap(<span class="hljs-number">0</span>, <span class="hljs-number">256</span>, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (shm_ptr == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 写入共享内存</span><br>    <span class="hljs-built_in">sprintf</span>(shm_ptr, <span class="hljs-string">&quot;Hello, shared memory!&quot;</span>);<br><br>    <span class="hljs-comment">// 读取共享内存</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Shared memory content: %s\n&quot;</span>, shm_ptr);<br><br>    <span class="hljs-comment">// 解除映射和关闭文件描述符</span><br>    munmap(shm_ptr, <span class="hljs-number">256</span>);<br>    close(shm_fd);<br>    shm_unlink(SHM_NAME);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量">信号量</h2><p><strong>概述：</strong>用于控制对共享资源的访问呢，解决进程之间的互斥问题，防止多个进程同时访问同一资源</p><ul><li>二进制信号量：只能取值0或1，常用于互斥锁</li><li>计数信号量：信号量的值大于1，常用于管理多个共享资源</li></ul><p><strong>使用示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-type">sem_t</span> sem;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    sem_wait(&amp;sem);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Worker started\n&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    sem_post(&amp;sem);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> t1, t2;<br>    sem_init(&amp;sem, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>    pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;t2, <span class="hljs-literal">NULL</span>, worker, <span class="hljs-literal">NULL</span>);<br><br>    pthread_join(t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(t2, <span class="hljs-literal">NULL</span>);<br><br>    sem_destroy(&amp;sem);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="socket">socket</h2><p><strong>概述：</strong>可用于本地进程间通信(Unix域套接字)或跨机器通信(基于TCP/IP协议)</p><p><strong>服务端示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-type">char</span>* message = <span class="hljs-string">&quot;Hello from client&quot;</span>;<br><br>    <span class="hljs-comment">// 创建socket</span><br>    sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置服务器地址</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = htons(<span class="hljs-number">8080</span>);<br>    server_addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><br>    <span class="hljs-comment">// 连接服务器</span><br>    connect(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));<br><br>    <span class="hljs-comment">// 发送数据</span><br>    send(sock, message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    close(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> sock;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_addr</span>;</span><br>    <span class="hljs-type">char</span>* message = <span class="hljs-string">&quot;Hello from client&quot;</span>;<br><br>    <span class="hljs-comment">// 创建socket</span><br>    sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置服务器地址</span><br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = htons(<span class="hljs-number">8080</span>);<br>    server_addr.sin_addr.s_addr = inet_addr(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><br>    <span class="hljs-comment">// 连接服务器</span><br>    connect(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));<br><br>    <span class="hljs-comment">// 发送数据</span><br>    send(sock, message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    close(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>进程间的通信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存泄漏</title>
    <link href="/2025/02/19/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2025/02/19/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="内存泄漏">内存泄漏</h1><p><strong>概述：</strong>程序在运行过程中，动态分配的内存未被及时释放，导致这些内存无法再次使用，最终导致系统内存耗尽，影响程序性能，甚至导致程序崩溃</p><p><strong>原因：</strong></p><ul><li>未释放已分配的内存：在使用malloc、new等动态分配内存后，未使用free或delete进行释放</li><li>丢失对已分配内存的引用：如果指针指向的内存被丢弃或覆盖，且没有释放该内存，导致无法访问和释放</li><li>异常导致的内存未释放：在函数执行过程中发生异常，导致提前退出，未执行释放内存的代码</li></ul><p><strong>危害：</strong></p><ul><li>性能下降</li><li>系统崩溃</li></ul><p><strong>避免内存泄漏的方法：</strong></p><ul><li>即时释放内存</li><li>使用智能指针</li><li>异常安全的内存管理，即使用RAII原则，将资源的获取和释放绑定到对象的构造和析构当中，确保异常发生时资源能够被正确释放</li><li>避免循环引用：在使用智能指针时，避免对象之间的循环引用，防止内存无法释放</li><li>定期检查和测试，使用内存分析工具如Valgrind</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存泄漏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆和栈</title>
    <link href="/2025/02/19/%E5%A0%86%E5%92%8C%E6%A0%88/"/>
    <url>/2025/02/19/%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="堆和栈">堆和栈</h1><p><strong>不同点：</strong></p><ul><li>内存分配方式不同：<ul><li>栈：栈上的内存是自动分配和释放的，通常用于存储函数调用过程中的局部变量、调用参数和使用的寄存器状态等信息。</li><li>堆：堆上的内存是动态分配的，程序在运行时可以根据需要分配和释放内存。在C++中可以通过new/new[]分配堆内存，使用delete/delete[]释放堆内存。在C中可以使用malloc、calloc和realloc函数分配堆内存，使用free函数释放堆内存</li></ul></li><li>内存大小不同：<ul><li>栈：栈的大小相对较小，适用于存储较小的数据结构和对象。分配和释放栈内存的操作非常快速，但栈空间有限，可能导致栈溢出错误</li><li>堆：堆的大小通常比栈大得多，因此可以用于存储较大的数据结构和对象。然而，分配和释放堆内存的操作相对较慢（涉及到内存管理搜索合适的内存块），可能导致程序性能下降</li></ul></li><li>内存管理不同：<ul><li>栈：栈上的内存由操作系统和编译器自动管理</li><li>堆：堆上的内存需要程序员手动管理。可能导致错误，如内存泄露、野指针、重复释放等</li></ul></li><li>生命周期不同：<ul><li>栈：栈上的内存生命周期与函数调用相关。局部变量在函数被调用时自动分配内存，函数返回时自动释放内存</li><li>堆：堆上内存的生命周期取决于程序员手动分配和释放。分配的内存在程序运行过程中一直存在，直到被显式释放或程序结束</li></ul></li></ul><p><strong>为什么栈速度比堆上的快：</strong></p><ul><li>数据结构的特点：栈是一种线性数据结构，可以通过简单的栈指针来读取栈上的数据；而堆是一种树形数据结构，要读取堆上的数据可能需要进行指针的跳转和内存的查找操作。</li><li>内存布局的连续性：栈上的内存分配是连续的；而堆上的内存可能是分散的</li><li>硬件优化：由于栈的读取比较频繁且简单，因此处理器和编译器通常会对栈上的操作进行优化，比如采用特定的指令集或硬件机制来提高栈操作的执行效率。相比之下，堆上的内存操作较为复杂，难以进行同样程序的优化</li></ul><p><strong>什么情况下必须使用堆内存？</strong></p><p>只有大小确定的时候才能在栈上分配，因为栈上分配是编译时就确定的，栈指针需要移动多少，就去给他分配多少内存。比较常见的场景就是分配一个动态数组，不确定大小就不能将其分配在栈上面，因为栈指针不知道要移动多少。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>堆</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust中的collections</title>
    <link href="/2025/02/19/Rust%E4%B8%AD%E7%9A%84collections/"/>
    <url>/2025/02/19/Rust%E4%B8%AD%E7%9A%84collections/</url>
    
    <content type="html"><![CDATA[<h1 id="collections">collections</h1><h2 id="hashmap">HashMap</h2><p><strong>概述：</strong>用于存储键值对的数据结构，底层实现是哈希表，因此是无序的。使用开放寻址法处理冲突。</p><p><strong>插入数据：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">50</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">60</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">70</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;scores: &#123;:?&#125;&quot;</span>, scores);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>如果insert的key已经存在，那就会更新value</p></blockquote><p><strong>获取值：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">50</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">60</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">70</span>);<br><br>    <span class="hljs-keyword">match</span> scores.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;Bob&quot;</span>) &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(&amp;score) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Bob&#x27;s score: &#123;&#125;&quot;</span>, score),<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Bob not found&quot;</span>),<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>如果key存在，则返回对应的值的引用；否则返回None</p></blockquote><p><strong>检查key是否存在：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">50</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">60</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">70</span>);<br><br>    <span class="hljs-keyword">if</span> scores.<span class="hljs-title function_ invoke__">contains_key</span>(<span class="hljs-string">&quot;Alice&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Alice is in the map&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Alice is not in the map&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>移除元素：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">50</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">60</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">70</span>);<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(score) = scores.<span class="hljs-title function_ invoke__">remove</span>(<span class="hljs-string">&quot;Alice&quot;</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Removed Alice with score: &#123;&#125;&quot;</span>, score);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Alice not found&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;scores: &#123;:?&#125;&quot;</span>, scores);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>删除成功返回该键对应的值(Some(value))，否则返回None</p></blockquote><p><strong>遍历HashMap：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">50</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">60</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">70</span>);<br><br>    <span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> scores &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取或插入值：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-comment">// 如果键不存在，插入一个默认值</span><br>    scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-string">&quot;Alice&quot;</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;socres: &#123;:?&#125;&quot;</span>, scores);<br><br>    <span class="hljs-comment">// 如果键已经存在，修改它的值</span><br>    *scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-string">&quot;Alice&quot;</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>) += <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;scores: &#123;:?&#125;&quot;</span>, scores);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在键不存在时插入默认值，或者获取某个键的值并进行修改</p></blockquote><h2 id="linkedlist">LinkedList</h2><p><strong>概述：</strong>双向链表，在插入和删除元素时不会导致元素的移动（相对于Vec），从而提供了更好的性能，特别是对大规模数据结构</p><p><strong>创建LinkedList：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::LinkedList;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 正常创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list</span>: LinkedList&lt;<span class="hljs-type">i32</span>&gt; = LinkedList::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, list);<br><br>    <span class="hljs-comment">// 从现有的Vec创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list2</span> = vec.<span class="hljs-title function_ invoke__">into_iter</span>().collect::&lt;LinkedList&lt;<span class="hljs-type">i32</span>&gt;&gt;();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, list2);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>插入元素：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">use std::collections::LinkedList;<br><br><span class="hljs-function">fn <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    let mut list = LinkedList::<span class="hljs-built_in">new</span>();<br><br>    <span class="hljs-comment">// 插入到list前面</span><br>    list.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 插入到list后面</span><br>    list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>    println!(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, list);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除元素：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::LinkedList;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">list</span> = LinkedList::<span class="hljs-title function_ invoke__">new</span>();<br>    list.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-number">1</span>);<br>    list.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-number">2</span>);<br>    list.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 删除前面的元素</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">removed</span> = list.<span class="hljs-title function_ invoke__">pop_front</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Removed: &#123;:?&#125;&quot;</span>, removed);<br><br>    <span class="hljs-comment">// 删除后面的元素</span><br>    removed = list.<span class="hljs-title function_ invoke__">pop_back</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Removed: &#123;:?&#125;&quot;</span>, removed);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, list);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>访问元素：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::LinkedList;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">list</span> = LinkedList::<span class="hljs-title function_ invoke__">new</span>();<br>    list.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-number">1</span>);<br>    list.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-number">2</span>);<br>    list.<span class="hljs-title function_ invoke__">push_back</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 通过迭代器遍历元素</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">value</span> <span class="hljs-keyword">in</span> &amp;list &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125; &quot;</span>, value);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>();<br><br>    <span class="hljs-comment">// 获取头尾元素</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(front) = list.<span class="hljs-title function_ invoke__">front</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Front: &#123;&#125;&quot;</span>, front);<br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(back) = list.<span class="hljs-title function_ invoke__">back</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Back: &#123;&#125;&quot;</span>, back);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>入门笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的线程同步方式</title>
    <link href="/2025/02/18/C-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/02/18/C-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步方式">线程同步方式</h1><h2 id="互斥锁">互斥锁</h2><p><strong>概述：</strong>用于保护临界区，确保同一时间只有一个线程可以访问共享资源。常见的互斥锁有std::mutex，std::lock_guard和std::unique_lock</p><h3 id="mutex">mutex</h3><p><strong>概述：</strong>用于管理多个线程对共享资源的互斥访问，防止数据竞争和并发问题</p><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享变量资源</span><br>std::mutex mtx; <span class="hljs-comment">// 共享变量的互斥锁</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        mtx.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// 加锁</span><br>        ++cnt; <span class="hljs-comment">// 临界区</span><br>        mtx.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 解锁</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(increment)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(increment)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Final cnt: &quot;</span> &lt;&lt; cnt &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果不想阻塞线程，可以使用try_lock()</p></blockquote><p><strong>std::recursive_lock：</strong>允许同一线程多次加锁，但是必须匹配相同次数的unlock()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::recursive_mutex rmtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursiveFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    rmtx.<span class="hljs-built_in">lock</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Lokcing &quot;</span> &lt;&lt; n &lt;&lt; std::endl;<br>    <span class="hljs-built_in">recursiveFunction</span>(n<span class="hljs-number">-1</span>);<br>    rmtx.<span class="hljs-built_in">unlock</span>(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(recursiveFunction, <span class="hljs-number">3</span>)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lock_guard">lock_guard</h3><p><strong>概述：</strong>一个轻量级的互斥锁管理器，确保在作用域结束时自动释放</p><p><strong>主要特点：</strong></p><ul><li>自动管理锁的获取和释放</li><li>不支持手动解锁</li><li>适用于短时间加锁的场景</li></ul><p><strong>基本用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex mtx; <span class="hljs-comment">// 共享互斥锁</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMessaga</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 加锁，作用域结束时自动释放</span><br>    std::cout &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(printMessaga, <span class="hljs-string">&quot;Hello from thread 1&quot;</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(printMessaga, <span class="hljs-string">&quot;Hello from thread 2&quot;</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造函数：</strong>会在构造函数时自动加锁，如果不想立刻加锁，可以使用std::adopt_lock</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::mutex mtx;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx, std::adopt_lock)</span></span>; <span class="hljs-comment">// 采用已有的锁</span><br></code></pre></td></tr></table></figure><blockquote><p>此时mtx必须在lock_guard之前已经被手动lock()，否则会导致未定义行为</p></blockquote><h3 id="unique_lock">unique_lock</h3><p><strong>概述：</strong>一种互斥锁管理器，比std::lock_guard更加灵活，主要用于管理std::mutex或其他BasicLockable类型的互斥锁</p><p><strong>主要特点：</strong></p><ul><li>支持延迟锁定：std::unique_lock可以在构造时不立即获取锁，而是在稍后在需要时显式地lock()</li><li>支持显式解锁：可以在持有锁的情况下调用unlock()释放锁，而不像std::lock_guard那样必须等到作用域结束时释放锁</li><li>支持所有权的转移：可以同故宫std::move进行所有权的转移</li></ul><p><strong>直接锁定互斥锁：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 自动加锁</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; is working\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadFunc)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadFunc)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>延迟锁定：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>; <span class="hljs-comment">// 不自动加锁</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 模拟其他操作</span><br>    lock.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// 需要时手动加锁</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread&quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; is working\n&quot;</span>;<br>&#125; <span class="hljs-comment">// 离开作用域时自动解锁</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadFunc)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadFunc)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>显式解锁：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br>std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; acquired lock\n&quot;</span>;<br><br>    lock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 显式解锁</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; <span class="hljs-string">&quot; released lock\n&quot;</span>;<br><br>    <span class="hljs-comment">// 其他操作，不受互斥锁保护</span><br>&#125; <span class="hljs-comment">// 离开作用域时不会再次解锁</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadFunc)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadFunc)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量">条件变量</h2><p><strong>概述：</strong>允许线程在不满足条件时挂起等待，在条件满足时被唤醒继续执行。通常与互斥锁一起使用，确保在修改共享数据不会出现竞态条件，常见的条件变量有std::condition_variable和std::condition_variable_any</p><h3 id="condition_variable">condition_variable</h3><p><strong>概述：</strong>在多线程环境下，通常会遇到生产者-消费者问题：线程A需要等数据准备后再执行，但它不能一直忙等，线程B生成数据后需要通知线程A继续执行。而std::condition_variable允许一个线程等待某个条件变为真，而另一个线程可以通知它条件已满足</p><p><strong>主要方法：</strong></p><ul><li>wait(std::unique_lock&lt;std::mutex&gt;&amp;lock)：让当前线程等待，直到被notify_one()或notify_all()唤醒</li><li>wait(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicatepred)：和上面的方法类似，但会在等待前和被唤醒后检查pred是否为true</li><li>notify_one()：唤醒一个等待的线程</li><li>notify_all()：唤醒所有等待的线程</li></ul><p><strong>基本用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; dataQueue; <span class="hljs-comment">// 共享数据队列</span><br>std::mutex mtx; <span class="hljs-comment">// dataQueue的互斥锁</span><br>std::condition_variable cv;<br><span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 生产者是否已经生产数据</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 模拟数据生成</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        dataQueue.<span class="hljs-built_in">push</span>(i);<br>        ready = <span class="hljs-literal">true</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Produced &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>        cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> ready || !dataQueue.<span class="hljs-built_in">empty</span>(); &#125;); <span class="hljs-comment">// 等待通知</span><br><br>        <span class="hljs-keyword">while</span> (!dataQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> value = dataQueue.<span class="hljs-built_in">front</span>();<br>            dataQueue.<span class="hljs-built_in">pop</span>();<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Consumed: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>        &#125;<br><br>        ready = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(producer)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(consumer)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实战练习：</strong>多线程顺序打印数字：创建3个线程，按顺序依次打印1-100，即线程1打印1，线程2打印2，线程3打印3，然后线程1打印4，线程2打印5，线程3打印6...</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-type">int</span> current = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前打印的数字</span><br>std::mutex mtx; <span class="hljs-comment">// current变量的互斥锁</span><br>std::condition_variable cv; <span class="hljs-comment">// 保证线程的同步（也就是保证线程任务执行的顺序）</span><br><br><span class="hljs-comment">// 线程任务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> threadId)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(lock, [threadId] &#123; <span class="hljs-keyword">return</span> current &gt; <span class="hljs-number">100</span> || (current - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> == threadId; &#125;);<br><br>        <span class="hljs-keyword">if</span> (current &gt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 线程终止条件</span><br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread&quot;</span> &lt;&lt; threadId &lt;&lt; <span class="hljs-string">&quot; prints &quot;</span> &lt;&lt; current &lt;&lt; std::endl;<br>        current++;<br><br>        cv.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 唤醒所有等待的线程</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(printNumber, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(printNumber, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(printNumber, <span class="hljs-number">2</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="condition_variable_any">condition_variable_any</h3><p><strong>概述：</strong>跟condition_variable类似，但是比其更灵活。condition_variable只能和std::unique_lock&lt;std::mutex&gt;搭配，而condition_variable_any可以与任何满足Lockable概念的锁搭配使用，适用于自定义锁、std::shared_mutex等，但性能就差了一些</p><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br>std::condition_variable_any cv_any;<br>std::shared_mutex shared_mtx;<br><span class="hljs-type">int</span> data = <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享变量</span><br><span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 条件变量判断</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 模拟生产数据</span><br>    <span class="hljs-function">std::unique_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(shared_mtx)</span></span>;<br>    data = <span class="hljs-number">42</span>;<br>    ready = <span class="hljs-literal">true</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Producer: Data ready\n&quot;</span>;<br>    cv_any.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(shared_mtx)</span></span>;<br>    cv_any.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> ready; &#125;);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(producer)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(consumer)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量">信号量</h2><p><strong>概述：</strong>是一个计数器，用于控制多个线程对于共享资源的访问。信号量包括二进制信号量和计数信号量。常见的信号量有std::binary_semaphore（C++20引入）和std::couting_semaphore&lt;N&gt;</p><h3 id="binary_semaphore">binary_semaphore</h3><p><strong>概述：</strong>类似于std::mutex，也具有非阻塞的try_acquire()（mutex是try_lock），但是可以手动释放（不像mutex只能由持有锁的线程释放）</p><p><strong>主要特点：</strong></p><ul><li>值域仅为0或1：<ul><li>0：表示资源不可用，线程阻塞等待</li><li>1：表示资源可用，允许线程访问</li></ul></li><li>支持手动release()：不像mutex由持有者释放，binary_semaphore可以由任何线程释放</li><li>支持try_acquire()：非阻塞获取信号量</li><li>适用于控制访问：适用于单个资源的独占访问，比mutex更灵活</li></ul><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><br><br><span class="hljs-function">std::binary_semaphore <span class="hljs-title">sem</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始状态为0，表示资源不可用</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Worker: Waiting for signal...\n&quot;</span>;<br>    sem.<span class="hljs-built_in">acquire</span>(); <span class="hljs-comment">// 等待信号量变为1</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Worker: Acquired semaphore! Doing work...\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(worker)</span></span>;<br><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main: Releasing semaphore\n&quot;</span>;<br>    sem.<span class="hljs-built_in">release</span>();<br><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="counting_semaphoren">counting_semaphore&lt;N&gt;</h3><p><strong>概述：</strong> 允许多个线程同时获取资源</p><p><strong>主要特点：</strong></p><ul><li>允许最多N个线程同时访问</li><li>acquire()减少信号量（如果为0，阻塞）</li><li>release()增加信号量（最多到N）</li><li>try_acquire()非阻塞获取</li></ul><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><br><br><span class="hljs-function">std::counting_semaphore&lt;3&gt; <span class="hljs-title">sem</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 最多允许3个线程同时执行</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    sem.<span class="hljs-built_in">acquire</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; is working...\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 模拟工作</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; done.\n&quot;</span>;<br>    sem.<span class="hljs-built_in">release</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::thread threads[<span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        threads[i] = std::<span class="hljs-built_in">thread</span>(worker, i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : threads) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="屏障">屏障</h2><p><strong>概述：</strong>用于在多个线程中所有线程都达到某个点时进行同步，然后继续执行。常见的屏障有std::barrier（C++20引入）</p><p><strong>主要特点：</strong></p><ul><li>需要设置固定数量的线程（称为count）</li><li>线程到达barrier后必须等待，直到所有线程都到达</li><li>线程全部到达，自动解除barrier，所有线程继续执行</li><li>支持阶段同步，可以在每轮barrier完成后执行回调函数</li></ul><p><strong>主要方法：</strong></p><ul><li>barrier(std::ptrdiff_t count, CompletionFunction f ={})：创建barrier，count是线程数，f是可选的阶段回调</li><li>arrive_and_wait()：线程到达barrier并等待，直到所有线程到达</li><li>arrive_and_drop()：线程达到后退出屏障，减少屏障计数</li><li>arrive(n)：线程到达n次（不等待）</li></ul><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><br><span class="hljs-function">std::barrier <span class="hljs-title">syncPoint</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 3个线程必须到达屏障</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; waiting at barrier...\n&quot;</span>;<br>    syncPoint.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 等待所有线程到达</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; passed the barrier!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(worker, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(worker, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(worker, <span class="hljs-number">3</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>带回调函数的用法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onPhaseComplete</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;All threads reached the barrier. Proceeding to next phase...\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function">std::barrier <span class="hljs-title">syncPoint</span><span class="hljs-params">(<span class="hljs-number">3</span>, onPhaseComplete)</span></span>; <span class="hljs-comment">// 3个线程必须到达屏障</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; waiting at barrier...\n&quot;</span>;<br>    syncPoint.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 等待所有线程到达</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; passed the barrier!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(worker, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(worker, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(worker, <span class="hljs-number">3</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>arrive_and_drop()让一个线程退出barrier：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><br><span class="hljs-function">std::barrier <span class="hljs-title">syncPoint</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 3个线程必须到达屏障</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (id == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; leaving the barrier parmanently...\n&quot;</span>;<br>        syncPoint.<span class="hljs-built_in">arrive_and_drop</span>(); <span class="hljs-comment">// 线程1退出</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; waiting at barrier...\n&quot;</span>;<br>    syncPoint.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 线程2和3继续同步</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; passed the barrier!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(worker, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(worker, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">(worker, <span class="hljs-number">3</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子操作">原子操作</h2><p><strong>概述：</strong>是一种保证不会被中断的操作。常见的原子操作有std::atomic和C++11中引入的原子操作函数</p><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) &#123;<br>        counter.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(increment)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(increment)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Final counter: &quot;</span> &lt;&lt; counter.<span class="hljs-built_in">load</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>支持的类型：</strong></p><ul><li>整数：int_t等</li><li>指针：T*</li><li>布尔值</li><li>浮点数</li></ul><p><strong>主要方法：</strong></p><ul><li>load()：获取原子变量的值</li><li>store(x)：设置原子变量的值</li><li>fetch_add(x)：原子加法</li><li>fetch_sub(x)：原子减法</li><li>fetch_or(x)：原子或</li><li>fetch_and(x)：原子与</li><li>exchange(x)：原子赋值并返回旧值</li><li>compare_exchange_weak(x, y)：CAS操作，比较并交换值</li></ul><p><strong>std::memory_order内存模型：</strong></p><ul><li>memory_order_relaxed：只保证原子性，不保证顺序</li><li>memory_order_consume：依赖load()的指令不会被重排序（很少使用）</li><li>memory_order_acquire：读取前的所有读写不会被重排序</li><li>memory_order_release：释放前的所有读写不会被重排序</li><li>memory_order_acq_rel：组合acquire和release</li><li>memory_order_seq_cst：默认，保证全局顺序一致</li></ul><h2 id="读写锁">读写锁</h2><p><strong>概述：</strong>允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。常见的读写锁有std::shared_mutex（C++17引入）</p><p><strong>基础用法示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br>std::shared_mutex rwMtx;<br><span class="hljs-type">int</span> sharedData = <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享数据</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock <span class="hljs-title">lock</span><span class="hljs-params">(rwMtx)</span></span>; <span class="hljs-comment">// 共享锁</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Reader &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; read value: &quot;</span> &lt;&lt; sharedData &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(rwMtx)</span></span>; <span class="hljs-comment">// 独占锁</span><br>    sharedData = value;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Writer &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; updated value to: &quot;</span> &lt;&lt; sharedData &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::thread&gt; threads;<br><br>    <span class="hljs-comment">// 启动多个读线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>(reader, i);<br>    &#125;<br><br>    <span class="hljs-comment">// 启动一个写线程</span><br>    threads.<span class="hljs-built_in">emplace_back</span>(writer, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 启动更多的读线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>(reader, i);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : threads) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>线程同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2025/02/02/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2025/02/02/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>代码仓库：</strong> <ahref="https://github.com/1037827920/AlgorithmZoo">1037827920/AlgorithmZoo</a></p><h1 id="快速排序">快速排序</h1><h2 id="算法步骤">算法步骤</h2><ol type="1"><li>选择基准元素，从数组中选择一个元素作为基准，通常选择方式有：<ul><li>第一个元素</li><li>最后一个元素</li><li>中间元素</li><li>随机选择</li></ul></li><li>分区操作，将数组元素根据基准分为两部分，一部分小于基准，另一部分大于基准</li><li>递归排序，对基准左边和右边的子数组都进行快速排序，每次递归都会进行分区操作</li><li>终止条件：当子数组的大小为1或0时，也就是左指针索引大于等于右指针索引时，递归终止</li></ol><h2 id="时间复杂度">时间复杂度</h2><p><strong>平均情况：</strong> O(N logN)</p><p>假设每次分区操作都能把数组划分成大约两半，这样递归的深度大概就是logN（以2为底，每次除以2，直到除到1，就是递归深度，如log8=3，如果每次对半分，8个元素递归深度为3），所以时间复杂度为O(logN)</p><p>每一层递归都需要对数组进行分区操作，这个通过for循环可以看出时间复杂度为O(N)</p><p>因此平均情况的时间复杂度为O(NlogN)</p><p><strong>最坏情况：</strong> O(N^2)</p><p>每次选择的基准元素总是数据中的最大或最小元素，如果是这样，分区操作会把数组分成一个空数组和一个包含所有其余元素的数组，递归深度会达到N，每次递归减少一个元素。分区操作复杂度也为O(N)，所以最坏情况的时间复杂度为O(N^2)</p><h2 id="稳定性">稳定性</h2><p>当两个相等的元素在排序后保持原来的相对顺序，说明这个排序算法是稳定的。</p><p>而快速排序不是稳定的排序算法</p><p>举个具体的例子，对数组[5, 2,5]进行分区操作，选择第二个5作为基准，对数组进行遍历，第一个5保持不变，2会跟第一个5交换位置([2,5,5])，然后要把基准放到正确的位置（这时候小于基准的元素的索引是0，+1后是基准要放置的索引），所以第一个5会跟第二个5进行交换，这时候两个相等的元素已经不是原来的相对顺序了，所以快速排序不是稳定的</p><h2 id="c">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::vector;<br><span class="hljs-keyword">using</span> std::swap;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::totally_ordered;<br><br><span class="hljs-comment">// 快速排序的分区函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;totally_ordered T&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr, <span class="hljs-type">size_t</span> left, <span class="hljs-type">size_t</span> right)</span> </span>&#123;<br>    <span class="hljs-comment">// 选择最右边的元素作为基准</span><br>    T pivot = arr[right];<br>    <span class="hljs-comment">// 小于基准的元素的索引</span><br>    <span class="hljs-type">size_t</span> i = left;<br><br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-comment">// 将小于基准的元素放到左边</span><br>    <span class="hljs-comment">// 将大于基准的元素放到右边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = left; j &lt; right; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; pivot) &#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>            ++i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将基准元素放到正确的位置</span><br>    <span class="hljs-built_in">swap</span>(arr[i], arr[right]);<br>    <span class="hljs-comment">// 返回基准元素的索引</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;totally_ordered T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;T&gt;&amp; arr, <span class="hljs-type">size_t</span> left, <span class="hljs-type">size_t</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 分区操作</span><br>        <span class="hljs-type">size_t</span> pivot_index = <span class="hljs-built_in">partition</span>&lt;T&gt;(arr, left, right);<br><br>        <span class="hljs-comment">// 对两边进行递归</span><br>        <span class="hljs-built_in">quick_sort</span>(arr, left, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quick_sort</span>(arr, pivot_index + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123; <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span> &#125;;<br><br>    <span class="hljs-built_in">quick_sort</span>&lt;<span class="hljs-type">int</span>&gt;(arr, <span class="hljs-number">0</span>, arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; num : arr) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c-1">C</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;<br>    <span class="hljs-type">int</span> tmp = *b;<br>    *b = *a;<br>    *a = tmp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">// 确定基准元素</span><br>    <span class="hljs-type">int</span> pivot = arr[right];<br>    <span class="hljs-comment">// 小于基准的元素的索引</span><br>    <span class="hljs-type">int</span> i = left;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = left; j &lt; right; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; pivot) &#123;<br>            swap(&amp;arr[i], &amp;arr[j]);<br>            i++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将基准元素放到正确的位置</span><br>    swap(&amp;arr[i], &amp;arr[right]);<br>    <span class="hljs-comment">// 返回基准元素的索引</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> pivot_index = partition(arr, left, right);<br>        quick_sort(arr, left, pivot_index - <span class="hljs-number">1</span>);<br>        quick_sort(arr, pivot_index + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>* arr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>    arr[<span class="hljs-number">1</span>] = <span class="hljs-number">7</span>;<br>    arr[<span class="hljs-number">2</span>] = <span class="hljs-number">8</span>;<br>    arr[<span class="hljs-number">3</span>] = <span class="hljs-number">9</span>;<br>    arr[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">5</span>;<br><br>    quick_sort(arr, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(arr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="rust">Rust</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::vec::<span class="hljs-type">Vec</span>;<br><br><span class="hljs-comment">// 快速排序的分区函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">partition</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt;(arr: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;T&gt;, left: <span class="hljs-type">usize</span>, right: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-comment">// 选择最右边的元素作为基准</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pivot</span> = arr[right <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>];<br>    <span class="hljs-comment">// 小于基准的元素的索引</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = left;<br><br>    <span class="hljs-comment">// 遍历数组</span><br>    <span class="hljs-comment">// 将小于基准的元素放到左边</span><br>    <span class="hljs-comment">// 将大于基准的元素放到右边</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> left..right &#123;<br>        <span class="hljs-keyword">if</span> arr[j] &lt; pivot &#123;<br>            arr.<span class="hljs-title function_ invoke__">swap</span>(i, j);<br>            i += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将基准元素放到正确的位置</span><br>    arr.<span class="hljs-title function_ invoke__">swap</span>(i, right);<br>    <span class="hljs-comment">// 返回基准元素的索引</span><br>    i<br>&#125;<br><br><span class="hljs-comment">// 快排函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">quick_sort</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt;(arr: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;T&gt;, left: <span class="hljs-type">usize</span>, right: <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">if</span> left &lt; right &#123;<br>        <span class="hljs-comment">// 分区操作</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">pivot_index</span> = <span class="hljs-title function_ invoke__">partition</span>(arr, left, right);<br>        <span class="hljs-comment">// 对两边执行递归</span><br>        <span class="hljs-title function_ invoke__">quick_sort</span>(arr, left, pivot_index - <span class="hljs-number">1</span>);<br>        <span class="hljs-title function_ invoke__">quick_sort</span>(arr, pivot_index + <span class="hljs-number">1</span>, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arr</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = arr.<span class="hljs-title function_ invoke__">len</span>();<br><br>    <span class="hljs-title function_ invoke__">quick_sort</span>(&amp;<span class="hljs-keyword">mut</span> arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br><br>    arr.<span class="hljs-title function_ invoke__">iter</span>().for_each(|x| <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;x&#125; &quot;</span>));<br>    <span class="hljs-built_in">println!</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 快速排序的分区函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr, left, right</span>):<br>    <span class="hljs-comment"># 选择最右边的元素作为基准</span><br>    pivot = arr[right]<br>    <span class="hljs-comment"># 小于基准的元素的索引</span><br>    i = left<br><br>    <span class="hljs-comment"># 遍历数组</span><br>    <span class="hljs-comment"># 将小于基准的元素放到左边</span><br>    <span class="hljs-comment"># 将大于基准的元素放到右边</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right):<br>        <span class="hljs-keyword">if</span> arr[j] &lt; pivot:<br>            arr[i], arr[j] = arr[j], arr[i]<br>            i += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 将基准元素放到正确的位置</span><br>    arr[i], arr[right] = arr[right], arr[i]<br>    <span class="hljs-comment"># 返回基准元素的索引</span><br>    <span class="hljs-keyword">return</span> i<br><br><br><span class="hljs-comment"># 递归函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">arr, left, right</span>):<br>    <span class="hljs-keyword">if</span> left &lt; right:<br>        <span class="hljs-comment"># 分区操作</span><br>        pivot_index = partition(arr, left, right)<br>        <span class="hljs-comment"># 对两边进行递归</span><br>        quick_sort(arr, left, pivot_index - <span class="hljs-number">1</span>)<br>        quick_sort(arr, pivot_index + <span class="hljs-number">1</span>, right)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    arr = [<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]<br><br>    quick_sort(arr, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr:<br>        <span class="hljs-built_in">print</span>(num, end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-built_in">print</span>()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页表(Page Table)</title>
    <link href="/2025/02/01/%E9%A1%B5%E8%A1%A8/"/>
    <url>/2025/02/01/%E9%A1%B5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="页表page-table">页表(Page Table)</h2><p><strong>概述：</strong>实现虚拟内存的重要数据结构，作用是将虚拟地址映射到物理地址，从而允许操作系统和硬件进行有效的内存管理。虚拟内存技术允许程序使用比物理内存更大的地址空间</p><p><strong>基本结构：</strong></p><p>虚拟内存被划分为固定大小的页面（通常是4KB、8KB），物理内存被划分为固定大小的页框。然后页表保存着虚拟页面到物理页框的映射关系。</p><p>虚拟地址和物理地址都可以分成两部分：</p><ul><li>页号：页面的编号</li><li>页内偏移：页面内的偏移量</li></ul><p><strong>页表的层级结构：</strong>单一的页表结构可能非常大，查找效率较低。为了优化内存使用和查找速度，操作系统通常会使用多级页表结构：</p><ul><li>一级页表：包含虚拟地址空间的最上层的页号映射</li><li>二级页表：用于映射一级页表中的页号进一步细分</li><li>三级页表：类似地，进一步细化映射关系</li></ul><p><strong>页表项(Page Table Entry, PTE)：</strong> 通常包含</p><ul><li>物理页框号：该PTE映射到的物理内存页框地址</li><li>有效位：标记该PTE是否有效。若无效，表示该虚拟页面没有映射到物理内存，可能需要缺页中断(PageFault)。</li><li>访问权限：如可读、可写、可执行等权限</li><li>脏位：标记该页面是否被修改过。若修改过且没有写回磁盘，则表示该页面为脏页面，需进行写回操作</li><li>引用位：在页交换算法中使用，表示该页面是否最近被访问过</li><li>缓存控制：指示该页面的缓存行为，如是否允许缓存</li></ul><p><strong>页表管理的关键操作：</strong></p><ul><li>页表的创建与销毁：每个进程通常都会有自己的页表，操作系统在进行进程创建时为其分配页表，在进程结束时销毁页表。</li><li>页表更新：当进程访问某个虚拟地址时，操作系统需要检查该地址是否有对应的PTE，如果没有，则发生缺页中断，操作系统需要更新页表</li><li>页表切换：每个进程都有独立的虚拟地址空间。因此，切换进程时需要切换页表。这通常是通过更新页表基址寄存器来完成。</li><li>页表缓存：为了加速地址转换，现代CPU通常会使用快表(TLB, TranslationLookasideBuffer)，这是一个小型缓存，用于存储最近访问的PTE，每次进行地址转换时，CPU会先查询TLB，若为命中，则需要访问页表</li></ul><p><strong>页表的管理策略：</strong></p><ul><li>分页与段式管理：分页和分段式两种不同的内存管理方式，现代操作系统通常结合这两种方式，分页提供了一种均匀的虚拟地址空间，而分段则根据程序的逻辑结构划分地址空间</li><li>分配策略：操作系统通常根据需求将内存分配给页表，包括动态分配和按需分配。多级页表可以动态地分配内存，提高内存利用率</li><li>页交换：操作系统可能将一些页表项映射到磁盘的swap空间中，称为虚拟内存的交换。当物理内存不足时，操作系统会将不活跃的页面交换出去，腾出空间给新的页面</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>页表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Robust-Futex学习笔记</title>
    <link href="/2025/01/30/Linux-Robust-Futex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/30/Linux-Robust-Futex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="robust-futex">robust futex</h1><h2 id="简介">简介</h2><p><strong>概述：</strong>为了保证futex的robustness，添加了一种能够用于处理进程异常终止时锁状态的机制，就是当拥有锁的线程异常终止时，该线程能够将锁进行释放</p><p><strong>基本原理：</strong> 每个线程都有一个私有的robustlist，这个list在线程生命周期只能注册一次。在线程退出时，kernel会检查这个list，并进行相应的清理操作。</p><p><strong>线程在执行do_exit()时常见的情况以及相应的处理方式：</strong></p><ul><li>常见情况：在大多数情况下，在线程执行do_exit函数时，kernel并没有注册任何list，因此对于robustlist的处理成本仅仅是进行一个简单的比较，即检查当前线程的robustlist是否为空</li><li>已注册list的情况：如果线程已经注册了list，通常这个list也大概率是空的，如果是正常退出的</li><li>线程异常退出的情况：如果注册的list不为空，则kernel会遍历这个list，并将所有由该线程拥有的锁标记为FUTEX_OWNER_DIED，然后唤醒一个waiter</li></ul><p><strong>潜在的竞争条件：</strong>由于添加和删除list是在获取锁之后进行的，所以给线程留下了一个小窗口，在此期间可能导致线程异常退出，从而使锁被悬挂，为了防止这种可能性，还需要多维护一个list_op_pending字段，并在完成列表的添加或删除操作后将其清除【存在疑惑】</p><h2 id="实现细节">实现细节</h2><p><strong>新系统调用：</strong></p><ul><li><p>sys_set_robust_list：注册robust list，接收一个指向robust listhead的指针和list head的长度作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">get_robust_list</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, <span class="hljs-keyword">struct</span> robust_list_head **head_ptr, <span class="hljs-type">size_t</span> *len_ptr)</span>;<br></code></pre></td></tr></table></figure></li><li><p>sys_get_robust_list：查询已注册的robustlist，接收一个PID作为参数，并返回指向robust listhead的指针和len指针。</p><ul><li><p>如果传入的PID为0，则返回调用线程自身的robust list head指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">set_robust_list</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> robust_list_head *head, <span class="hljs-type">size_t</span> len)</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>当操作成功，返回0，否则返回错误码：</p><ul><li>set_robust_list()：<ul><li>EINVAL：len和kernel预期的结构体robust_list_head的大小不匹配</li></ul></li><li>get_robust_list()：<ul><li>ERERM：调用进程无权查看TID为PID的线程的robustlist，并且不具有CAP_SYS_PTRACE功能（这是一个linux中的特权能力，用于允许进程进行调试和trace其他进程，具有该能力的成可以使用ptrace()系统调用来观察和控制其他进程的执行，包括读取和修改其内存、寄存器和指令流）</li><li>ESRCH：找不到TID为PID的线程</li><li>EFALUT：robust list head不能存储在location head中</li></ul></li></ul></li></ul><p><strong>注册list：</strong> robustlist指针简单存储在robust_list字段中，如果robusfutex比较普通，可以通过扩展sys_clone来为新线程注册robust listhead，而无需通过sys_set_robust_list注册</p><p><strong>系统调用开销：</strong></p><ul><li>不使用robust futex的任务：几乎没有额外开销</li><li>使用robustfutex的任务：每个线程的生命周期只会增加一个额外的系统调用，清理futex的操作时快速且简单的</li></ul><h2 id="futex字段值">Futex字段值</h2><ul><li>如果未获取锁，futex值的后面30位（即TID位）为0，所以只需要看后面30位是否有值就知道该futex是否被上锁</li><li>如果锁被获取，futex值的后面30位（即TID位）为拥有该锁的线程的TID</li><li>如果锁时拥有的，并且有线程争用锁，则应在futex中标识FUTEX_WAITERS位，即FUTEX_WAITERS| TID（FUTEX_WAITERS为0x8000_0000，也就是第一位）</li><li>如果线程退出时发现某个robustfutex仍被持有，kernel会设置相应的futex字段的FUTEX_OWNER_DIED位（0x4000_0000，也就是第二位），然后唤醒下一个waiter（如果存在）。其余清理工作由用户空间完成</li></ul><h2 id="代码示例">代码示例</h2><h3 id="使用示例程序">使用示例程序</h3><p><strong>代码仓库：</strong> <ahref="https://github.com/1037827920/Futex-Example-Program">1037827920/Futex-Example-Program</a></p><p><strong>Rust示例程序：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> libc::&#123;<br>    syscall, SYS_futex, SYS_get_robust_list, SYS_gettid, SYS_set_robust_list, FUTEX_WAIT,<br>    FUTEX_WAKE,<br>&#125;;<br><span class="hljs-keyword">use</span> std::&#123;<br>    io, mem, panic, ptr,<br>    sync::&#123;<br>        atomic::&#123;AtomicU32, Ordering&#125;,<br>        Arc, Mutex,<br>    &#125;,<br>    thread,<br>    time::Duration,<br>&#125;;<br><br><span class="hljs-keyword">const</span> FUTEX_INIT: <span class="hljs-type">u32</span> = <span class="hljs-number">0x0000_0000</span>;<br><span class="hljs-keyword">const</span> FUTEX_WAITERS: <span class="hljs-type">u32</span> = <span class="hljs-number">0x8000_0000</span>;<br><span class="hljs-keyword">const</span> FUTEX_TID_MASK: <span class="hljs-type">u32</span> = <span class="hljs-number">0x3fff_ffff</span>;<br><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RobustList</span> &#123;<br>    next: *<span class="hljs-keyword">mut</span> RobustList,<br>    <span class="hljs-comment">// futex: u32, (通过偏移量访问)</span><br>&#125;<br><br><span class="hljs-meta">#[repr(C)]</span><br><span class="hljs-meta">#[derive(Debug, Clone)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RobustListHead</span> &#123;<br>    list: RobustList,<br>    <span class="hljs-comment">/// 这个偏移量的作用是为了能够通过（list项的地址+偏移量）得到futex用户空间地址</span><br>    <span class="hljs-comment">/// futex_offset的单位为字节，即1表示一个字节的偏移量</span><br>    <span class="hljs-comment">/// 在用户空间添加这个字段还能进行灵活编码偏移量而不是在内核硬编码</span><br>    futex_offset: <span class="hljs-type">i64</span>,<br>    list_op_pending: *<span class="hljs-keyword">mut</span> RobustList,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RobustListHead</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(futex_offset: <span class="hljs-type">i64</span>) <span class="hljs-punctuation">-&gt;</span> RobustListHead &#123;<br>        RobustListHead &#123;<br>            list: RobustList &#123;<br>                next: ptr::<span class="hljs-title function_ invoke__">null_mut</span>(),<br>            &#125;,<br>            futex_offset,<br>            list_op_pending: ptr::<span class="hljs-title function_ invoke__">null_mut</span>(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, futex: AtomicU32) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">into_raw</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(RobustList &#123;<br>            next: <span class="hljs-keyword">self</span>.list.next,<br>        &#125;));<br>        <span class="hljs-keyword">unsafe</span> &#123;<br>            ((new_node <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u8</span>).<span class="hljs-title function_ invoke__">offset</span>(<span class="hljs-keyword">self</span>.futex_offset <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> AtomicU32)<br>                .<span class="hljs-title function_ invoke__">write</span>(futex);<br>        &#125;<br>        <span class="hljs-keyword">self</span>.list.next = new_node;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_robust_list</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">current</span> = <span class="hljs-keyword">self</span>.list.next;<br>        <span class="hljs-keyword">while</span> !current.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                <span class="hljs-built_in">print!</span>(<br>                    <span class="hljs-string">&quot;&#123;:?&#125;(futex: &#123;:?&#125;, futex_val: &#123;:?&#125;) -&gt; &quot;</span>,<br>                    current,<br>                    (current <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>).<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">self</span>.futex_offset <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>),<br>                    ((current <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>).<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">self</span>.futex_offset <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> AtomicU32)<br>                        .<span class="hljs-title function_ invoke__">read</span>(),<br>                );<br>                current = (*current).next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;NULL&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_futex</span>(&amp;<span class="hljs-keyword">self</span>, index: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> *<span class="hljs-keyword">const</span> AtomicU32 &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">current</span> = <span class="hljs-keyword">self</span>.list.next;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..index &#123;<br>            <span class="hljs-keyword">if</span> current.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>                <span class="hljs-keyword">return</span> ptr::<span class="hljs-title function_ invoke__">null_mut</span>();<br>            &#125;<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                current = (*current).next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> current.<span class="hljs-title function_ invoke__">is_null</span>() &#123;<br>            <span class="hljs-keyword">return</span> ptr::<span class="hljs-title function_ invoke__">null_mut</span>();<br>        &#125;<br>        <span class="hljs-keyword">unsafe</span> &#123; (current <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>).<span class="hljs-title function_ invoke__">add</span>(<span class="hljs-keyword">self</span>.futex_offset <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> AtomicU32 &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">RobustListHead</span> &#123;&#125;<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">RobustListHead</span> &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">test_set_and_get_robust_list</span>();<br>    <span class="hljs-title function_ invoke__">test_robust_futex</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">futex_wait</span>(futex: *<span class="hljs-keyword">const</span> AtomicU32, thread: &amp;<span class="hljs-type">str</span>, tid: <span class="hljs-type">i64</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">futex_ref</span> = <span class="hljs-keyword">unsafe</span> &#123; &amp;*futex &#125;;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-comment">// 如果当前futex没有被其他线程持有</span><br>        <span class="hljs-keyword">if</span> (futex_ref.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst) &amp; FUTEX_TID_MASK) == <span class="hljs-number">0</span> &#123;<br>            futex_ref.<span class="hljs-title function_ invoke__">swap</span>(tid <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>, Ordering::SeqCst);<br>            <span class="hljs-comment">// 加锁后直接返回，这样就不用执行系统调用，减少一定开销</span><br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;线程&#123;thread&#125;上锁成功, futex值: &#123;:#x&#125;&quot;</span>,<br>                (*futex_ref).<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst)<br>            );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 标识futex的FUTEX_WAITERS位</span><br>        futex_ref.<span class="hljs-title function_ invoke__">fetch_or</span>(FUTEX_WAITERS, Ordering::SeqCst);<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;线程&#123;thread&#125;正在等待futex, futex值: &#123;:#x&#125;&quot;</span>,<br>            (*futex_ref).<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst)<br>        );<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-title function_ invoke__">syscall</span>(<br>                SYS_futex,<br>                futex_ref <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> AtomicU32 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>,<br>                FUTEX_WAIT,<br>                futex_ref.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst),<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-number">0</span>,<br>            )<br>        &#125;;<br>        <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;futex_wait系统调用执行失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">futex_wake</span>(futex: *<span class="hljs-keyword">const</span> AtomicU32, thread: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">futex_ref</span> = <span class="hljs-keyword">unsafe</span> &#123; &amp;*futex &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-title function_ invoke__">syscall</span>(<br>            SYS_futex,<br>            futex_ref <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> AtomicU32 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>,<br>            FUTEX_WAKE,<br>            <span class="hljs-number">1</span>,<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>,<br>        )<br>    &#125;;<br>    <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;futex_wake系统调用执行失败&quot;</span>);<br>    &#125;<br>    futex_ref.<span class="hljs-title function_ invoke__">store</span>(FUTEX_INIT, Ordering::SeqCst);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程&#123;thread&#125;释放锁&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/// 向kernel注册一个robust list</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_robust_list</span>(robust_list_head_ptr: *<span class="hljs-keyword">const</span> RobustListHead) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">syscall</span>(SYS_set_robust_list, robust_list_head_ptr, mem::size_of::&lt;RobustListHead&gt;()) &#125;;<br>    <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<br>            <span class="hljs-string">&quot;set_robust_list系统调用执行失败, Err: &#123;:?&#125;&quot;</span>,<br>            io::Error::<span class="hljs-title function_ invoke__">last_os_error</span>()<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// 获取kernel注册的robust list</span><br><span class="hljs-comment">/// 当pid=0时，表示获取当前进程的robust list</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_robust_list</span>(pid: <span class="hljs-type">i32</span>, robust_list_head_ptr: &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">mut</span> RobustListHead, len: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">syscall</span>(SYS_get_robust_list, pid, robust_list_head_ptr, len) &#125;;<br>    <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<br>            <span class="hljs-string">&quot;get_robust_list系统调用执行失败, Err: &#123;:?&#125;&quot;</span>,<br>            io::Error::<span class="hljs-title function_ invoke__">last_os_error</span>()<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// 测试set_robust_list系统调用和get_robust_list系统调用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_set_and_get_robust_list</span>() &#123;<br>    <span class="hljs-comment">// 初始化robust list head</span><br>    <span class="hljs-comment">// 8字节为RobustList的大小</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">robust_list_head</span> = RobustListHead::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 初始化robust list</span><br>    robust_list_head.<span class="hljs-title function_ invoke__">push</span>(AtomicU32::<span class="hljs-title function_ invoke__">new</span>(FUTEX_INIT));<br>    robust_list_head.<span class="hljs-title function_ invoke__">print_robust_list</span>();<br><br>    <span class="hljs-comment">// 设置robust list</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_ptr</span> = &amp;robust_list_head <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> RobustListHead;<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;robust_list_head_ptr: &#123;:?&#125;, len: &#123;:?&#125;&quot;</span>,<br>        robust_list_head_ptr, mem::size_of::&lt;RobustListHead&gt;()<br>    );<br>    <span class="hljs-title function_ invoke__">set_robust_list</span>(robust_list_head_ptr);<br><br>    <span class="hljs-comment">// 获取robust list</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">robust_list_head_ptr_geted</span>: *<span class="hljs-keyword">mut</span> RobustListHead = ptr::<span class="hljs-title function_ invoke__">null_mut</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">len_geted</span>: <span class="hljs-type">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-title function_ invoke__">get_robust_list</span>(<span class="hljs-number">0</span>, &amp;<span class="hljs-keyword">mut</span> robust_list_head_ptr_geted, &amp;<span class="hljs-keyword">mut</span> len_geted);<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;robust_list_head_ptr_geted: &#123;:?&#125;, robust_list_head: &#123;:?&#125; len_geted: &#123;:?&#125;&quot;</span>,<br>        robust_list_head_ptr_geted,<br>        <span class="hljs-keyword">unsafe</span> &#123; &amp;*robust_list_head_ptr_geted &#125;,<br>        len_geted<br>    );<br>&#125;<br><br><span class="hljs-comment">/// 测试一个线程异常退出时，robust list的表现</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_robust_futex</span>() &#123;<br>    <span class="hljs-comment">// 创建robust list head</span><br>    <span class="hljs-comment">// 8字节为RobustList的大小</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(RobustListHead::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">8</span>)));<br><br>    <span class="hljs-comment">// 初始化robust list</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">robust_list_head_guard</span> = robust_list_head.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    (*robust_list_head_guard).<span class="hljs-title function_ invoke__">push</span>(AtomicU32::<span class="hljs-title function_ invoke__">new</span>(FUTEX_INIT));<br>    <span class="hljs-title function_ invoke__">drop</span>(robust_list_head_guard);<br><br>    <span class="hljs-comment">// 线程1</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_clone1</span> = robust_list_head.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tid</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">syscall</span>(SYS_gettid) &#125;;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程1的线程号: &#123;tid&#125;&quot;</span>);<br><br>        <span class="hljs-comment">// 向kernel注册robust list</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_guard</span> = robust_list_head_clone1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_ptr</span> = &amp;(*robust_list_head_guard) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> RobustListHead;<br>        <span class="hljs-title function_ invoke__">set_robust_list</span>(robust_list_head_ptr);<br><br>        <span class="hljs-comment">// 尝试获取锁</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">futex</span> = robust_list_head_guard.<span class="hljs-title function_ invoke__">get_futex</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-title function_ invoke__">futex_wait</span>(futex, <span class="hljs-string">&quot;1&quot;</span>, tid);<br>        <span class="hljs-comment">// 执行具体的业务逻辑</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>));<br><br>        <span class="hljs-comment">// 模拟线程异常退出，是否会正常把未释放的锁释放掉</span><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;thread1异常退出&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;);<br><br>    thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">3</span>));<br><br>    <span class="hljs-comment">// 线程2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_clone2</span> = robust_list_head.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tid</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">syscall</span>(SYS_gettid) &#125;;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程2的线程号: &#123;tid&#125;&quot;</span>);<br><br>        <span class="hljs-comment">// 向kernel注册robust list</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_guard</span> = robust_list_head_clone2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">robust_list_head_ptr</span> = &amp;(*robust_list_head_guard) <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> RobustListHead;<br>        <span class="hljs-title function_ invoke__">set_robust_list</span>(robust_list_head_ptr);<br><br>        <span class="hljs-comment">// 尝试获取锁</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">futex</span> = robust_list_head_guard.<span class="hljs-title function_ invoke__">get_futex</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;线程2尝试获取锁, futex值: &#123;:#x&#125;&quot;</span>,<br>            <span class="hljs-keyword">unsafe</span> &#123; &amp;*futex &#125;.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst)<br>        );<br>        <span class="hljs-title function_ invoke__">futex_wait</span>(futex, <span class="hljs-string">&quot;2&quot;</span>, tid);<br>        <span class="hljs-comment">// 执行具体的业务逻辑</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-title function_ invoke__">futex_wake</span>(futex, <span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;);<br><br>    thread1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    thread2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>C示例程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/futex.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdatomic.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUTEX_INIT 0x00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUTEX_WAITERS 0x80000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUTEX_TID_MASK 0x3fffffff</span><br><br><span class="hljs-comment">// 定义一个结构体来封装线程任务参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span>* <span class="hljs-title">rlh</span>;</span><br>    <span class="hljs-type">int</span> thread;<br>&#125; thread_task_args;<br><br><span class="hljs-comment">// 向robust list插入新节点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">robust_list_push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> robust_list_head* rlh, <span class="hljs-type">atomic_uint</span> futex)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list</span>* <span class="hljs-title">new_robust_list</span> =</span> (<span class="hljs-keyword">struct</span> robust_list*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> robust_list));<br>    <span class="hljs-keyword">if</span> (new_robust_list == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;new robust list分配内存失败&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 通过偏移量将futex写入新robust list</span><br>    <span class="hljs-type">atomic_uint</span>* futex_ptr = (<span class="hljs-type">atomic_uint</span>*)((<span class="hljs-type">uint8_t</span>*)new_robust_list + rlh-&gt;futex_offset);<br>    *futex_ptr = futex;<br><br>    rlh-&gt;<span class="hljs-built_in">list</span>.next = new_robust_list;<br>&#125;<br><br><span class="hljs-comment">// 获取索引为index的futex地址</span><br><span class="hljs-type">atomic_uint</span>* <span class="hljs-title function_">robust_list_get_futex</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> robust_list_head* rlh, <span class="hljs-type">size_t</span> index)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list</span>* <span class="hljs-title">current</span> =</span> rlh-&gt;<span class="hljs-built_in">list</span>.next;<br>    <span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i == index) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">atomic_uint</span>*)((<span class="hljs-type">uint8_t</span>*)current + rlh-&gt;futex_offset);<br>        &#125;<br>        current = current-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 打印robust list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">robust_list_print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> robust_list_head* rlh)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list</span>* <span class="hljs-title">current</span> =</span> rlh-&gt;<span class="hljs-built_in">list</span>.next;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">atomic_uint</span>* futex_ptr = (<span class="hljs-type">atomic_uint</span>*)((<span class="hljs-type">uint8_t</span>*)current + rlh-&gt;futex_offset);<br>        <span class="hljs-type">atomic_int</span> futex = *futex_ptr;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p(futex: %p, futex_val: %u) -&gt; &quot;</span>, (<span class="hljs-type">void</span>*)current, (<span class="hljs-type">void</span>*)futex_ptr, futex);<br><br>        current = current-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 向kernel注册robust list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">set_robust_list</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> robust_list_head* rlh)</span> &#123;<br>    <span class="hljs-type">long</span> ret = syscall(SYS_set_robust_list, rlh, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> robust_list_head));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;set_robust_list系统调用执行失败\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从kernel获取robust list</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_robust_list</span><span class="hljs-params">(<span class="hljs-type">int</span> pid, <span class="hljs-keyword">struct</span> robust_list_head** rlh, <span class="hljs-type">size_t</span>* len)</span> &#123;<br>    <span class="hljs-type">long</span> ret = syscall(SYS_get_robust_list, pid, rlh, len);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;get_robust_list系统调用执行失败\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// futex_wait函数</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">futex_wait</span><span class="hljs-params">(<span class="hljs-type">atomic_uint</span>* futex, <span class="hljs-type">int</span> thread, <span class="hljs-type">long</span> tid)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 如果当前futex没有其他线程持有</span><br>        <span class="hljs-keyword">if</span> ((*futex &amp; FUTEX_TID_MASK) == <span class="hljs-number">0</span>) &#123;<br>            atomic_exchange(futex, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)tid);<br>            <span class="hljs-comment">// 加锁后直接返回</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d上锁成功. futex值: 0x%x\n&quot;</span>, thread, *futex);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 线程进入等待状态</span><br>        atomic_fetch_or(futex, FUTEX_WAITERS);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d正在等待futex, futex值: 0x%x\n&quot;</span>, thread, *futex);<br>        <span class="hljs-type">long</span> ret = syscall(SYS_futex, (<span class="hljs-type">unsigned</span>*)futex, FUTEX_WAIT, *futex, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;futex_wait系统调用执行失败\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// futex_wake函数</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">futex_wake</span><span class="hljs-params">(<span class="hljs-type">atomic_uint</span>* futex, <span class="hljs-type">int</span> thread)</span> &#123;<br>    <span class="hljs-type">long</span> ret = syscall(SYS_futex, (<span class="hljs-type">unsigned</span>*)futex, FUTEX_WAKE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;futex_wake系统调用执行失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">atomic_store</span>(futex, FUTEX_INIT);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d释放锁\n&quot;</span>, thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试set_robust_list系统调用和get_robust_list系统调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_set_and_get_robust_list</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个robust list head</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span>* <span class="hljs-title">rlh</span> =</span> (<span class="hljs-keyword">struct</span> robust_list_head*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> robust_list_head));<br>    rlh-&gt;futex_offset = <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 初始化robust list</span><br>    robust_list_push(rlh, <span class="hljs-number">0x00000000</span>);<br>    robust_list_print(rlh);<br><br>    <span class="hljs-comment">// 设置robust list</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;robust_list_head_ptr: %p, len: %ld\n&quot;</span>, rlh, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> robust_list_head));<br>    set_robust_list(rlh);<br><br>    <span class="hljs-comment">// 获取robust list</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span>* <span class="hljs-title">rlh_geted</span> =</span> (<span class="hljs-keyword">struct</span> robust_list_head*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> robust_list_head));<br>    <span class="hljs-type">size_t</span> len_geted;<br>    get_robust_list(<span class="hljs-number">0</span>, &amp;rlh_geted, &amp;len_geted);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;robust_list_head_geted_ptr: %p, len_geted: %ld\n&quot;</span>, rlh_geted, len_geted);<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">thread1_task</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    thread_task_args* args = (thread_task_args*)arg;<br>    <span class="hljs-comment">// robust list head指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span>* <span class="hljs-title">rlh</span> =</span> args-&gt;rlh;<br>    <span class="hljs-comment">// 线程号</span><br>    <span class="hljs-type">int</span> thread = args-&gt;thread;<br>    <span class="hljs-comment">// TID</span><br>    <span class="hljs-type">long</span> tid = syscall(SYS_gettid);<br><br>    <span class="hljs-comment">// 注册robust list</span><br>    set_robust_list(rlh);<br><br>    <span class="hljs-comment">// 尝试获取锁</span><br>    <span class="hljs-type">atomic_uint</span>* futex = robust_list_get_futex(rlh, <span class="hljs-number">0</span>);<br>    futex_wait(futex, thread, tid);<br>    <span class="hljs-comment">// 执行具体的业务逻辑</span><br>    sleep(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 线程异常退出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d异常退出\n&quot;</span>, thread);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">thread2_task</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    thread_task_args* args = (thread_task_args*)arg;<br>    <span class="hljs-comment">// robust list head指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span>* <span class="hljs-title">rlh</span> =</span> args-&gt;rlh;<br>    <span class="hljs-comment">// 线程号</span><br>    <span class="hljs-type">int</span> thread = args-&gt;thread;<br>    <span class="hljs-comment">// TID</span><br>    <span class="hljs-type">long</span> tid = syscall(SYS_gettid);<br><br>    <span class="hljs-comment">// 注册robust list</span><br>    set_robust_list(rlh);<br><br>    <span class="hljs-comment">// 尝试获取锁</span><br>    <span class="hljs-type">atomic_uint</span>* futex = robust_list_get_futex(rlh, <span class="hljs-number">0</span>);<br>    futex_wait(futex, thread, tid);<br>    <span class="hljs-comment">// 执行具体的业务逻辑</span><br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 释放锁</span><br>    futex_wake(futex, thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 测试一个线程异常退出时，robust list的表现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">test_robust_futex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程句柄</span><br>    <span class="hljs-type">pthread_t</span> t1, t2;<br><br>    <span class="hljs-comment">// 创建robust list head</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">robust_list_head</span>* <span class="hljs-title">rlh</span> =</span> (<span class="hljs-keyword">struct</span> robust_list_head*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> robust_list_head));<br><br>    <span class="hljs-comment">// 初始化robust list</span><br>    robust_list_push(rlh, <span class="hljs-number">0x00000000</span>);<br><br>    <span class="hljs-comment">// 构建线程参数</span><br>    thread_task_args args1 = &#123; rlh, <span class="hljs-number">1</span> &#125;;<br>    thread_task_args args2 = &#123; rlh, <span class="hljs-number">2</span> &#125;;<br><br>    <span class="hljs-comment">// 线程1</span><br>    pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, thread1_task, (<span class="hljs-type">void</span>*)&amp;args1);<br><br>    <span class="hljs-comment">// 等线程1先获取futex锁</span><br>    sleep(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 线程2</span><br>    pthread_create(&amp;t2, <span class="hljs-literal">NULL</span>, thread2_task, (<span class="hljs-type">void</span>*)&amp;args2);<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    pthread_join(t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(t2, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    test_set_and_get_robust_list();<br>    test_robust_futex();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><img src="/2025/01/30/Linux-Robust-Futex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250130183735637.png" class=""><h3 id="实现示例程序">实现示例程序</h3><p>【待完成】</p><h2 id="参考">参考</h2><ul><li><ahref="https://www.man7.org/linux/man-pages/man2/futex.2.html">futex(2) -Linux 手册页 --- futex(2) - Linux manual page</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>futex</tag>
      
      <tag>robust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Futex学习笔记</title>
    <link href="/2025/01/25/Linux-Futex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/25/Linux-Futex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="futex">Futex</h1><h2 id="简介">简介</h2><p><strong>概述：</strong> Futex(Fast UserspaceMutex)是linux的一种特有机制，设计目标是避免传统的线程同步原语（如mutex、条件变量等）在用户空间和内核空间之间频繁的上下文切换。Futex允许在用户空间处理锁定和等待的操作，只有在必要时进入内核，从而减少了不必要的开销。</p><p><strong>对比：</strong></p><ul><li>SpinLock：如果上锁成功，立即进入临界区，开销很小；但是如果上锁失败，CPU空转，浪费资源</li><li>Mutex：如果上锁失败，内核会切换到其他线程在CPU运行，不用自旋等待锁；但是即使是上锁成功也要进出内核，使用系统调用，会消耗几百个指令</li><li>Futex：结合上述二者的优点，在用户态尝试上锁，上锁成功既可以不用进入内核态，上锁失败就通过系统调用睡眠，唤醒也要通过系统调用<ul><li>在用户空间尝试加锁通常通过原子操作来完成，如CAS(Compare-And-Swap)或者其他无锁的原子操作</li></ul></li></ul><h2 id="原理">原理</h2><p><strong>本质：</strong>futex直接通过<strong>虚拟地址</strong>（是一个用户空间地址，通常是一个32位的锁变量字段，0表示空闲，1表示有线程持有当前锁）来处理锁，而不是像以前一样创建一个需要初始化以及跨进程全局内核句柄</p><p><strong>用户空间地址：</strong>futex用户空间地址可以通过mmap系统调用分配，而mmap分配的内存有三种：匿名内存、共享内存段、内存映射文件。匿名内存只能用在同一进程的线程之间使用，而共享内存段和内存映射文件可以在多个进程之间使用</p><p><strong>主要功能：</strong></p><ul><li>Futex原子操作：用户空间线程首先执行一些原子操作（如使用atomic函数或cmpxchg指令）来尝试获取锁</li><li>短路路径：如果锁在用户空间已经被释放，线程可以直接在用户空间完成同步，无需涉及内核</li><li>等待：如果一个线程尝试获取的锁已经被另一个线程占用，它可以调用futex_wait()进入休眠</li><li>唤醒：当锁被释放，另一个线程可以调用futex_wake()唤醒等待的线程</li></ul><p><strong>涉及的系统调用：</strong></p><ul><li><p>futex()：允许用户空间线程等待或唤醒其他线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">futex</span><span class="hljs-params">(<span class="hljs-type">int</span> *uddr, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> val, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *timeout, <span class="hljs-type">int</span> *uaddr2, <span class="hljs-type">int</span> val2)</span>;<br></code></pre></td></tr></table></figure><ul><li>uaddr：用户空间地址，表示锁的位置</li><li>val：如果是FUTEX_WAIT，表示原子性地检查uaddr中的值是否为val，如果是则让进程睡眠，否则返回错误；如果是FUTEX_WAKE，表示最多唤醒val个等待在uaddr上的进程</li><li>op：操作类型：<ul><li>FUTEX_WAIT：等待操作，线程会阻塞，直到指定的内存地址值发生变化</li><li>FUTEX_WAKE：唤醒操作，唤醒一个或多个等待该内存地址的线程</li></ul></li><li>timeout：可选的等待时间，如果为空，那么调用会无限期睡眠。timeout默认会根据CLOCK_MONOTONIC时钟来计算，从linux4.5开始，可以再futex_op上指定FUTEX_CLOCK_REALTIME来选择CLOCK_REALTIME时钟。</li><li>uaddr2和val2在某些情况下用于双重条件等待</li></ul></li><li><p>futex_wait()和futex_wake()是更高级的封装，用于在应用程序中更方便地实现等待和唤醒操作</p></li></ul><h2 id="实际应用">实际应用</h2><ul><li>pthread_mutex：在linux中，pthread_mutex是基于futex实现的。</li><li>内存屏障和自旋锁：在一些高效的同步机制中，futex也常常与自旋锁、内存屏障等技术结合使用</li></ul><h2 id="代码示例">代码示例</h2><p><strong>代码仓库：</strong> <ahref="https://github.com/1037827920/Futex-Example-Program">1037827920/Futex-Example-Program</a></p><h3 id="futex本身的使用">futex本身的使用</h3><p><strong>Rust示例程序：</strong>（需要使用到libc crate）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> libc::&#123;syscall, SYS_futex, SYS_gettid, FUTEX_WAIT, FUTEX_WAKE&#125;;<br><span class="hljs-keyword">use</span> std::&#123;<br>    panic,<br>    sync::&#123;<br>        atomic::&#123;AtomicU32, Ordering&#125;,<br>        Arc,<br>    &#125;,<br>    thread,<br>    time::Duration,<br>&#125;;<br><br><span class="hljs-keyword">const</span> FUTEX_INIT: <span class="hljs-type">u32</span> = <span class="hljs-number">0x0000_0000</span>;<br><span class="hljs-keyword">const</span> FUTEX_WAITERS: <span class="hljs-type">u32</span> = <span class="hljs-number">0x8000_0000</span>;<br><span class="hljs-keyword">const</span> FUTEX_TID_MASK: <span class="hljs-type">u32</span> = <span class="hljs-number">0x3fff_ffff</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">test_futex</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">futex_wait</span>(futex: &amp;AtomicU32, thread: &amp;<span class="hljs-type">str</span>, tid: <span class="hljs-type">i64</span>) &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-comment">// 如果当前futex没有被其他线程持有</span><br>        <span class="hljs-keyword">if</span> (futex.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst) &amp; FUTEX_TID_MASK) == <span class="hljs-number">0</span> &#123;<br>            futex.<span class="hljs-title function_ invoke__">swap</span>(tid <span class="hljs-keyword">as</span> <span class="hljs-type">u32</span>, Ordering::SeqCst);<br>            <span class="hljs-comment">// 加锁后直接返回，这样就不用执行系统调用，减少一定开销</span><br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;线程&#123;thread&#125;上锁成功, futex值: &#123;:#x&#125;&quot;</span>,<br>                futex.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst)<br>            );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 线程进入等待状态</span><br>        futex.<span class="hljs-title function_ invoke__">fetch_or</span>(FUTEX_WAITERS, Ordering::SeqCst);<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;线程&#123;thread&#125;正在等待futex, futex值: &#123;:#x&#125;&quot;</span>,<br>            futex.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst)<br>        );<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = <span class="hljs-keyword">unsafe</span> &#123;<br>            <span class="hljs-title function_ invoke__">syscall</span>(<br>                SYS_futex,<br>                futex <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> AtomicU32 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>,<br>                FUTEX_WAIT,<br>                futex.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst),<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-number">0</span>,<br>            )<br>        &#125;;<br>        <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;futex_wait系统调用执行失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">futex_wake</span>(futex: &amp;AtomicU32, thread: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ret</span> = <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-title function_ invoke__">syscall</span>(<br>            SYS_futex,<br>            futex <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> AtomicU32 <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">u32</span>,<br>            FUTEX_WAKE,<br>            <span class="hljs-number">1</span>,<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-number">0</span>,<br>        )<br>    &#125;;<br>    <span class="hljs-keyword">if</span> ret == -<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;futex_wake系统调用执行失败&quot;</span>);<br>    &#125;<br>    futex.<span class="hljs-title function_ invoke__">store</span>(FUTEX_INIT, Ordering::SeqCst);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;线程&#123;thread&#125;释放锁&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/// 测试基本的futex使用</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_futex</span>() &#123;<br>    <span class="hljs-comment">// futex用户空间地址</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">futex</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(AtomicU32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">futex_clone1</span> = futex.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">futex_clone2</span> = futex.<span class="hljs-title function_ invoke__">clone</span>();<br><br>    <span class="hljs-comment">// 线程1</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tid</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">syscall</span>(SYS_gettid) &#125;;<br>        <span class="hljs-comment">// 尝试获取锁</span><br>        <span class="hljs-title function_ invoke__">futex_wait</span>(&amp;futex_clone1, <span class="hljs-string">&quot;1&quot;</span>, tid);<br>        <span class="hljs-comment">// 执行具体的业务逻辑</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-title function_ invoke__">futex_wake</span>(&amp;futex_clone1, <span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-comment">// 线程2</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">tid</span> = <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-title function_ invoke__">syscall</span>(SYS_gettid) &#125;;<br>        <span class="hljs-comment">// 尝试获取锁</span><br>        <span class="hljs-title function_ invoke__">futex_wait</span>(&amp;futex_clone2, <span class="hljs-string">&quot;2&quot;</span>, tid);<br>        <span class="hljs-comment">// 执行具体的业务逻辑</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-title function_ invoke__">futex_wake</span>(&amp;futex_clone2, <span class="hljs-string">&quot;2&quot;</span>);<br>    &#125;);<br><br>    thread1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    thread2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>C示例程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdatomic.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/futex.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUTEX_INIT 0x00000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUTEX_WAITERS 0x80000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FUTEX_TID_MASK  0x3fffffff</span><br><br><span class="hljs-comment">// 定义一个结构体来封装参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">atomic_uint</span>* futex;<br>    <span class="hljs-type">int</span> thread;<br>&#125; thread_args;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">futex_wait</span><span class="hljs-params">(<span class="hljs-type">atomic_uint</span>* futex, <span class="hljs-type">int</span> thread, <span class="hljs-type">long</span> tid)</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 如果当前futex没有其他线程持有</span><br>        <span class="hljs-keyword">if</span> ((*futex &amp; FUTEX_TID_MASK) == <span class="hljs-number">0</span>) &#123;<br>            atomic_exchange(futex, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)tid);<br>            <span class="hljs-comment">// 加锁后直接返回</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d上锁成功. futex值: 0x%x\n&quot;</span>, thread, *futex);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 线程进入等待状态</span><br>        atomic_fetch_or(futex, FUTEX_WAITERS);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d正在等待futex, futex值: 0x%x\n&quot;</span>, thread, *futex);<br>        <span class="hljs-type">long</span> ret = syscall(SYS_futex, (<span class="hljs-type">unsigned</span>*)futex, FUTEX_WAIT, *futex, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;futex_wait系统调用执行失败\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">futex_wake</span><span class="hljs-params">(<span class="hljs-type">atomic_uint</span>* futex, <span class="hljs-type">int</span> thread)</span> &#123;<br>    <span class="hljs-type">long</span> ret = syscall(SYS_futex, (<span class="hljs-type">unsigned</span>*)futex, FUTEX_WAKE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;futex_wake系统调用执行失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">atomic_store</span>(futex, FUTEX_INIT);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程%d释放锁\n&quot;</span>, thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">thread_task</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    thread_args* args = (thread_args*)arg;<br>    <span class="hljs-comment">// futex用户空间地址</span><br>    <span class="hljs-type">atomic_uint</span>* futex = args-&gt;futex;<br>    <span class="hljs-comment">// 线程号</span><br>    <span class="hljs-type">int</span> thread = args-&gt;thread;<br>    <span class="hljs-comment">// TID</span><br>    <span class="hljs-type">long</span> tid = syscall(SYS_gettid);<br><br>    <span class="hljs-comment">// 尝试获取锁</span><br>    futex_wait(futex, thread, tid);<br>    <span class="hljs-comment">// 执行具体的业务逻辑</span><br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 释放锁</span><br>    futex_wake(futex, thread);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程句柄</span><br>    <span class="hljs-type">pthread_t</span> t1, t2;<br><br>    <span class="hljs-comment">// futex用户空间地址</span><br>    <span class="hljs-type">atomic_uint</span> futex = <span class="hljs-number">0</span>;<br><br>    thread_args args1 = &#123; &amp;futex, <span class="hljs-number">1</span> &#125;;<br>    thread_args args2 = &#123; &amp;futex, <span class="hljs-number">2</span> &#125;;<br><br>    <span class="hljs-comment">// 创建两个线程同时递增cnt</span><br>    pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, thread_task, (<span class="hljs-type">void</span>*)&amp;args1);<br>    pthread_create(&amp;t2, <span class="hljs-literal">NULL</span>, thread_task, (<span class="hljs-type">void</span>*)&amp;args2);<br><br>    <span class="hljs-comment">// 等待线程结束</span><br>    pthread_join(t1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(t2, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><img src="/2025/01/25/Linux-Futex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20250130183415454.png" class=""><h3 id="pthread_mutex的使用">pthread_mutex的使用</h3><p><strong>C示例程序：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 共享计数器</span><br><span class="hljs-type">int</span> shread_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 互斥锁</span><br><span class="hljs-type">pthread_mutex_t</span> cnt_mutex = PTHREAD_MUTEX_INITIALIZER;<br><br><span class="hljs-comment">// 线程执行的任务</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">thread_task</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    <span class="hljs-comment">// 线程ID</span><br>    <span class="hljs-type">long</span> tid = (<span class="hljs-type">long</span>)arg;<br><br>    <span class="hljs-comment">// 循环5次，每次增加计数器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        pthread_mutex_lock(&amp;cnt_mutex);<br><br>        <span class="hljs-comment">// 临界区：修改共享资源</span><br>        <span class="hljs-type">int</span> tmp = shread_cnt;<br>        <span class="hljs-comment">// 模拟一些处理时间</span><br>        usleep(<span class="hljs-number">100</span>);<br>        shread_cnt = tmp + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程 %ld: 计数器值 = %d\n&quot;</span>, tid, shread_cnt);<br><br>        <span class="hljs-comment">// 解锁</span><br>        pthread_mutex_unlock(&amp;cnt_mutex);<br><br>        <span class="hljs-comment">// 模拟一些处理时间</span><br>        usleep(<span class="hljs-number">200</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 定义线程句柄数组</span><br>    <span class="hljs-type">pthread_t</span> threads[<span class="hljs-number">3</span>];<br><br>    <span class="hljs-comment">// 创建3个线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> ret = pthread_create(&amp;threads[i], <span class="hljs-literal">NULL</span>, thread_task, (<span class="hljs-type">void</span>*)i);<br><br>        <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;线程创建失败&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待所有线程完成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        pthread_join(threads[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 打印最终计数器值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最终计数器值 = %d\n&quot;</span>, shread_cnt);<br><br>    <span class="hljs-comment">// 销毁互斥锁</span><br>    pthread_mutex_destroy(&amp;cnt_mutex);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原理浅析：</strong></p><p>pthread_mutex_lock实际上会执行__pthread_mutex_lock，然后这个函数实现里面会调用LLL_MUTEX_LOCK宏，这个宏会调用__lll_lock宏，在这个宏里面就会先尝试在用户态进行上锁（也就是通过CAS的原子操作进行上锁），然后上锁失败再调用__lll_lock_wait（或__lock_wait_private），这个函数在追踪下去就会执行futex_wait系统调用。这个流程就跟上面<ahref="#futex本身的使用">futex本身的使用</a>差不多了。</p><p>想要看更详细的讲解可以看这个博客：<ahref="https://www.cnblogs.com/pslydff/p/7041444.html">pthread_mutex_lock实现- pslydhh</a></p><h2 id="参考">参考</h2><ul><li><ahref="https://hardcore.feishu.cn/docs/doccn9Ld4O9tGh7DenRv3GOj7Uh">‍‌‌‌‬﻿‬﻿﻿‬﻿‍‬‌‍‬‬‌‍‬‌⁠‌‍﻿futex技术分享</a></li><li><ahref="https://jyywiki.cn/OS/2022/slides/5.slides.html#/4/1">2022年南大操作系统课程——并发控制：互斥</a></li><li><ahref="https://www.cnblogs.com/pslydff/p/7041444.html">pthread_mutex_lock实现- pslydhh</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>futex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程和线程的区别</title>
    <link href="/2025/01/19/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/01/19/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="进程和线程的区别">进程和线程的区别</h1><p><strong>定义：</strong></p><ul><li>进程：是一个正在运行的程序的实例，包含程序的代码、当前的活动（如程序计数器、寄存器状态等）以及与该进程相关的资源（如内存、文件句柄、设备等）。</li><li>线程：是在进程内部的执行单位。一个进程可以包含多个线程，这些线程共享进程的资源（如内存、文件句柄等），但每个线程都有自己的程序计数器、寄存器和堆栈</li></ul><p><strong>内存和资源管理：</strong></p><ul><li>进程：有自己的独立内存空间，每个进程之间的内存都是相互隔离的。</li><li>线程：共享同一个进程的内存空间，线程共享进程中的全局变量和内存，但每个线程有自己的栈内存</li></ul><p><strong>开销：</strong></p><ul><li>进程：创建、销毁和上下文切换开销相对较大</li><li>线程：开销相对较小</li></ul><p><strong>调度和执行：</strong></p><ul><li>进程：由操作系统的调度程序进行调度，每次切换上下文都需要保存和加载进程的整个状态，包括寄存器、内存、程序计数器等</li><li>线程：由操作系统内核或线程库进行调度，每个线程都有自己的程序计数器和执行状态</li></ul><p><strong>通信：</strong></p><ul><li>进程：通常使用管道、消息队列、共享内存、信号量等机制。</li><li>线程：共享变量或同步机制（如互斥锁、条件变量等）来实现</li></ul><p><strong>错误和崩溃：</strong></p><ul><li>进程：相互隔离的，一个进程的崩溃通常不会直接影响其他进程</li><li>线程：共享同一进程的资源，一个线程的崩溃可能导致整个进程的崩溃</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
      <tag>操作系统</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么要内存对齐</title>
    <link href="/2025/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2025/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="内存对齐">内存对齐</h1><h2 id="初步认识">初步认识</h2><p>内存对齐是什么？从下面的代码可以比较直观地有一个简单的认识：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s1</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s2</span> &#123;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c2;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">s3</span> &#123;<br>    <span class="hljs-type">char</span> c1;<br>    <span class="hljs-type">char</span> c2;<br>    <span class="hljs-type">int</span> i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(s1) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(s2) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(s3) &lt;&lt; endl;<br>&#125; <br></code></pre></td></tr></table></figure><p>上面的代码输出如下：</p><ul><li>s1为8字节：<ul><li>i：4字节</li><li>c1：1字节</li><li>c2：1字节+2填充字节</li></ul></li><li>s2为12字节：<ul><li>c1：1字节+3填充字节</li><li>i：4字节</li><li>c2：1字节+3填充字节</li></ul></li><li>s3为8字节：<ul><li>c1：1字节</li><li>c2：1字节+2填充字节</li><li>i：4字节</li></ul></li></ul><h2 id="原因探究">原因探究</h2><p>简单来看，主要是以下两个原因：</p><ul><li>性能优化：大多数现代处理器都要求数据按照特定的边界对齐，因为寄存器只能从<strong>能整除以4</strong>的地址开始读取数据（一次读取4字节(32位)或8字节(64位)），为什么寄存器这样设计，也是为了能够<strong>并行处理</strong>，加快内存访问。</li><li>硬件要求：某些处理器对于未对齐的/内存访问是禁止的，可能导致错误</li></ul><p>我们主要研究第一个原因性能优化，就拿上面的代码中的结构体s2来说，如果内存没有对齐，假设内存是如下分布的：<img src="/2025/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/image-20250118234111708.png" class=""></p><p>如果要读取变量i，就需要进行两次读取操作，然后再获取到变量i的值<img src="/2025/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/image-20250118235542718.png" class=""></p><p>如果内存是对齐的，则内存如下分布： <img src="/2025/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/image-20250118235324083.png" class=""></p><p>如果要读取变量i，只需要进行一次读取操作： <img src="/2025/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/image-20250118235823472.png" class=""></p><p>所以可以看出，内存对齐是真的可以加快内存的访问，提高性能。</p><p><strong>口头回答：</strong>为什么内存不对齐，就有可能导致额外的读取操作？（读取6字节数据和8字节数据，为什么读取8字节的性能就更高？）</p><p>因为寄存器只能从<strong>能整除以4</strong>的地址开始读取，也就是内存地址被一个一个的<strong>边界</strong>进行”分割“，且寄存器只能从这一个一个<strong>边界开始读取数据</strong>，内存不对齐有可能导致数据的存放刚好被边界<strong>分成两边</strong>，这样就得读取边界的左边和右边，才能把这个数据读取完整。</p><h2 id="取消内存对齐">取消内存对齐</h2><p>这里主要讨论在C/C++中，如果对结构体取消默认的内存对齐</p><p><strong>使用#pragma pack指令：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(1)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">char</span> a; <span class="hljs-comment">// 1字节</span><br>    <span class="hljs-type">int</span> b; <span class="hljs-comment">// 4字节</span><br>    <span class="hljs-type">short</span> c; <span class="hljs-comment">// 2字节</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack() <span class="hljs-comment">// 恢复默认对齐</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用alignas关键字：</strong>C++11引入，然而，alignas只能用于增加对齐要求，不能用于减少对齐要求，因此无法通过alignas取消内存对齐</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">8</span>) A &#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">short</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存对齐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust中的Rc, Cell, RefCell</title>
    <link href="/2025/01/15/Rust%E4%B8%AD%E7%9A%84RcCellRefCell/"/>
    <url>/2025/01/15/Rust%E4%B8%AD%E7%9A%84RcCellRefCell/</url>
    
    <content type="html"><![CDATA[<h1 id="引用计数rc">引用计数Rc</h1><p><strong>概述：</strong>Rc是Rust中用于实现引用计数的类型，它允许多个所有者共享同一个数据。</p><p><strong>用法详解：</strong></p><ul><li>每当clone一个Rc时，引用计数增加，而每当一个Rc退出作用域时，引用计数减少。</li><li>当引用计数变为0时，Rc和它所包裹的数据都会被销毁。</li><li>Rc的clone不会进行深拷贝，指创建另一个指向包裹值的指针，并增加引用计数</li></ul><p><strong>示例：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rc_examples</span> = <span class="hljs-string">&quot;Rc examples&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rc_a is created&quot;</span>);<br>        <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">rc_a</span>: Rc&lt;<span class="hljs-type">String</span>&gt; = Rc::<span class="hljs-title function_ invoke__">new</span>(rc_examples);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Reference Count of rc_a: &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;rc_a)); <br><br>        &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rc_a is cloned to rc_b&quot;</span>);<br><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">rc_b</span>: Rc&lt;<span class="hljs-type">String</span>&gt; = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;rc_a);<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Reference Count of rc_b: &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;rc_b));<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Reference Count of rc_a: &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;rc_a));<br><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rc_a and rc_b are equal: &#123;&#125;&quot;</span>, rc_a.<span class="hljs-title function_ invoke__">eq</span>(&amp;rc_b));<br>            <span class="hljs-comment">// 可以直接使用值的方法</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Length of the value inside rc_a: &#123;&#125;&quot;</span>, rc_a.<span class="hljs-title function_ invoke__">len</span>());<br>            <span class="hljs-comment">// 直接使用值</span><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Value of rc_b: &#123;&#125;&quot;</span>, rc_b);<br><br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rc_b is dropped out of scope&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Reference Count of rc_a: &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;rc_a));<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rc_a is dropped out of scope&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="cell和refcell">Cell和RefCell</h1><p><strong>概述：</strong>Rust编译器通过严格的借用规则（多个不可变引用或只有一个可变引用存在）确保程序安全性，但是会降低灵活性。因此提供了Cell和RefCell类型，允许在不可变引用的情况下修改数据。内部是通过unsafe代码实现的</p><h2 id="cell">Cell</h2><p><strong>概述：</strong>Cell和RefCell在功能上没有区别，区别在于Cell&lt;T&gt;适用于T实现Copy的情况</p><p><strong>示例：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::Cell;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Cell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;asdf&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = c.<span class="hljs-title function_ invoke__">get</span>();<br>    c.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">&quot;qwer&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">two</span> = c.<span class="hljs-title function_ invoke__">get</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, one, two);<br>&#125;<br></code></pre></td></tr></table></figure><p>asdf是&amp;str类型，实现了Copytrait，取到值保存在one变量后，还能同时进行修改，这个违背了Rust的借用规则，但通过Cell就能做到这一点</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Cell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;asdf&quot;</span>));<br></code></pre></td></tr></table></figure><p>这段代码编译器会报错，因为String没有实现Copy trait</p><h2 id="refcell">RefCell</h2><table><thead><tr><th>Rust规则</th><th>智能指针带来的额外规则</th></tr></thead><tbody><tr><td>一个数据只有一个所有者</td><td>Rc/Arc让一个数据可以拥有多个所有者</td></tr><tr><td>要么多个不可变借用，要么一个可变借用</td><td>RefCell实现编译器可变、不可变引用共存</td></tr><tr><td>违背规则导致编译错误</td><td>违背规则导致运行时panic</td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello, wolrd&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = s.<span class="hljs-title function_ invoke__">borrow</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s.<span class="hljs-title function_ invoke__">borrow_mut</span>();<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, s1, s2);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码不会出现编译错误，但是运行时会panic</p><p><strong>RefCell为何存在？</strong></p><p>从上面看，通过RefCell并不能绕过rust的借用规则，那还有什么用？</p><p>对于大型的复杂程序，可以选择使用RefCell来让事情简化。在Rust编译器的<ahref="https://github.com/rust-lang/rust/blob/620d1ee5346bee10ba7ce129b2e20d6e59f0377d/src/librustc/middle/ty.rs#L803-L987">ctxt结构体</a>中有大量的RefCell类型的map字段，主要原因是这些map会被分散在各个地方的代码片段所广泛使用或修改，很容易就碰到编译器跑出来的各种错误，但是你不知道如何解决。这时候可以使用RefCell，在运行时发现这些错误，因为一旦有的代码使用不正确，就会panic，我们就知道哪里借用冲突了。</p><h2 id="cell-or-refcell">Cell or RefCell</h2><p><strong>主要区别：</strong></p><ul><li>Cell只适用于实现了Copytrait类型，用于提供值，而RefCell用于提供引用</li><li>Cell不会panic，而RefCell会在运行时panic</li></ul><p><strong>性能比较：</strong></p><p>Cell没有额外的开销，下面两段代码的性能是一样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// code 1</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = Cell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = &amp;x;<br>x.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-number">2</span>);<br>y.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-number">3</span>);<br>z.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x.<span class="hljs-title function_ invoke__">get</span>());<br><br><span class="hljs-comment">// code 2</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;<span class="hljs-keyword">mut</span> x;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = &amp;<span class="hljs-keyword">mut</span> x;<br>x = <span class="hljs-number">2</span>;<br>*y = <span class="hljs-number">3</span>;<br>*z = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure><p>但是代码2不能编译成功，因为只能存在一个可变引用</p><h2 id="内部可变性">内部可变性</h2><p><strong>概述：</strong>对一个不可变的值进行可变借用，就是内部可变性</p><p><strong>无内部可变性：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;<span class="hljs-keyword">mut</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试对一个不可变值进行可变借用，破坏了Rust的借用规则</p><p><strong>RefCell应用场景：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 定义在外部库的trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Messnger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>&#125;<br><br><span class="hljs-comment">// 我们自己写的代码</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    msg_cache: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Messnger</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">push</span>(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码会编译错误，因为需要修改self的msg_cache，但是外部库的self是不可变的self，这时候RefCell就派上用场了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Messnger</span> &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    msg_cache: RefCell&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Messnger</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mq</span> = MsgQueue &#123;<br>        msg_cache: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>());<br>    &#125;;<br>    mq.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-string">&quot;hello, world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="rcrefcell">Rc+RefCell</h2><p><strong>概述：</strong>这是一个很常见的组合，前者可以实现一个数据拥有多个所有者，后者可以实现数据的内部可变性</p><p><strong>示例：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello, wolrd&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = s.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s.<span class="hljs-title function_ invoke__">clone</span>();<br>    <br>    s2.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, on yeah!&quot;</span>);<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\n&#123;:?&#125;\n&#123;:?&#125;&quot;</span>, s, s1, s2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能损耗：</strong></p><p>非常高，大致相当于没有线程安全版本的C++std::shared_ptr指针。C++这个指针的主要开销也在于原子性这个并发原语上，毕竟线程安全在哪个语言开销都不小</p><p><strong>内存损耗：</strong></p><p>二者结合的数据结构与下面类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// Rc</span><br>    strong_count: <span class="hljs-type">usize</span>,<br>    weak_count: <span class="hljs-type">usize</span>,<br>    <br>    <span class="hljs-comment">// RefCell</span><br>    borrow_count: <span class="hljs-type">isize</span>,<br>    <br>    <span class="hljs-comment">// 包裹的数据</span><br>    item: T,<br>&#125;<br></code></pre></td></tr></table></figure><p>仅仅多分配了三个usize/isize</p><p><strong>CPU损耗：</strong></p><p>从CPU来看， 损耗如下：</p><ul><li>对Rc&lt;T&gt;解引用是免费的（编译期），但是<code>*</code>带来的间接取值并不免费</li><li>cloneRc&lt;T&gt;需要将当前的引用计数跟0和usize::Max进行一次比较，然后将计数值加1</li><li>drop Rc&lt;T&gt;需要将计数值减1，然后跟0进行一次比较</li><li>对RefCell进行不可变借用，需要将isize类型的借用计数加1，然后跟0进行比较</li><li>对RefCell的不可变借用进行释放，需要将isize减1</li><li>对RefCell的可变借用大致跟上面差不多，但需要先跟0比较，然后再减1</li><li>对RefCell的可变借用进行释放，需要将isize加1</li></ul><h2 id="解决借用冲突">解决借用冲突</h2><p><strong>两种方法：</strong></p><ul><li>Cell::from_mut，将&amp;mut T转换为Cell&lt;T&gt;</li><li>Cell::as_slice_of_cells，将&amp;Cell&lt;T&gt;转换为&amp;[Cell&lt;T&gt;]</li></ul><p><strong>常见的借用冲突问题：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">is_even</span>(i: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>    i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">retain_even</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> nums.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|&amp;num| <span class="hljs-title function_ invoke__">is_even</span>(num)) &#123;<br>        nums[i] = *num;<br>        i += <span class="hljs-number">1</span>;<br>    &#125;<br>    nums.<span class="hljs-title function_ invoke__">truncate</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>会编译错误，因为同时使用了可变借用和不可变借用</p><p>可以通过索引来解决这个问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">retain_even</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">j</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..nums.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">is_even</span>(nums[j]) &#123;<br>            nums[i] = nums[j];<br>            i += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    nums.<span class="hljs-title function_ invoke__">truncate</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>但这样不够最佳实践，使用迭代器才是最佳实践</p><p>可以使用上面提到的两种方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::Cell;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">retain_even</span>(nums: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span>: &amp;[Cell&lt;<span class="hljs-type">i32</span>&gt;] = Cell::<span class="hljs-title function_ invoke__">from_mut</span>(&amp;<span class="hljs-keyword">mut</span> nums[..]).<span class="hljs-title function_ invoke__">as_slice_of_cells</span>();<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> slice.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|num| <span class="hljs-title function_ invoke__">is_even</span>(num.<span class="hljs-title function_ invoke__">get</span>())) &#123;<br>        slice[i].<span class="hljs-title function_ invoke__">set</span>(num.<span class="hljs-title function_ invoke__">get</span>());<br>        i += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    nums.<span class="hljs-title function_ invoke__">truncate</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>rc</tag>
      
      <tag>cell</tag>
      
      <tag>refcell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么linux kernel喜欢这样写</title>
    <link href="/2025/01/08/%E4%B8%BA%E4%BB%80%E4%B9%88linux-kernel%E5%96%9C%E6%AC%A2%E8%BF%99%E6%A0%B7%E5%86%99/"/>
    <url>/2025/01/08/%E4%B8%BA%E4%BB%80%E4%B9%88linux-kernel%E5%96%9C%E6%AC%A2%E8%BF%99%E6%A0%B7%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>最近在看linux kernel源码的时候，发现linuxkernel喜欢在每个函数体语句块的开头先声明好函数要使用到的变量，就算该变量仅仅是用于for循环。</p><p>比如说，大部分同学写for循环可能是这j样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是linux kernel就会这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>why？有没有同学很好奇嘞</p><p>查了一下才知道，原来C89标准还不支持在for循环内声明变量的语法，这个语法是在C99标准才加入的。</p><p>而linuxkernel为了兼容C89，能在一些不支持C89编译器上编译，所以才喜欢这样（很大的原因我觉得，毕竟linux真的兼容性超强）。</p><p>当然这里我觉得还有一些其他好处，比如说代码一致性，这样可以很方便看出每个函数都会用到哪些局部变量，更容易阅读代码。</p><p>还有吗？待补充(doge</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APIC</title>
    <link href="/2025/01/07/APIC/"/>
    <url>/2025/01/07/APIC/</url>
    
    <content type="html"><![CDATA[<h1 id="apic">APIC</h1><p><strong>概述：</strong>是一个用于管理和处理中断的硬件组件，用于提高多核或多处理器系统的中断处理效率</p><p><strong>Local APIC：</strong></p><ul><li>定义：是每个处理器核心独有的APIC，负责该处理核心的中断处理任务。</li><li>作用：<ul><li>接收中断：Local APIC接收来自IO APIC或其他处理器的中断请求</li><li>生成中断：LocalAPIC可以生成中断信号，以通知处理器进行任务调度、上下文切换等</li><li>处理中断：LocalAPIC负责管理本地中断，确保处理器按照优先级顺序响应中断请i去</li></ul></li><li>功能：<ul><li>每个核心有一个Local APIC来管理该核心的中断</li><li>Local APIC处理器与外部设备的IO APIC通过系统总线进行通信</li><li>Local APIC支持中断优先级控制、向量分配等功能</li></ul></li></ul><p><strong>IO APIC：</strong></p><ul><li>定义：是一个独立的APIC，用于管理外部设备产生的中断并将这些中断转发到相应的处理器。</li><li>作用：<ul><li>接收外部中断：IOAPIC接收来自外部硬件设备（如网卡、磁盘、USB设备等）发送的中断信号</li><li>路由中断：IOAPIC将接收到的外部中断根据预设的路由规则（通常根据中断源和目标CPU）转发到对应的本地APIC</li></ul></li><li>功能：<ul><li>IOAPIC支持多路复用，将来自不同外设的中断信号通过不同的IRQ编号进行管理，并将它们转发到处理器核心</li><li>支持中断的优先级控制，确保高优先级的中断能够及时被处理</li></ul></li></ul><h2 id="lvtlocal-vector-table">LVT(Local Vector Table)</h2><p><strong>概述：</strong>是一个表格，包含多个条目，每个条目对应一个中断源。每个LVT条目存储了与该中断源相关的配置，包括该中断的触发方式、目标处理器等信息</p><p><strong>工作原理：</strong></p><p>LVT将LocalAPIC的中断源映射到特定的中断服务例程，并设置相关的中断控制属性。LVT的每个条目通常包括以下几个部分：</p><ul><li>中断向量(Vector)：表示中断的唯一标识符</li><li>传递模式(Delivery Mode)：<ul><li>固定模式(Fixed Mode)：中断传递给指定CPU</li><li>最低优先级(Lowest Priority)：传递给当前优先级最低的CPU</li><li>外部中断(External Interrupt)：来自外部设备的中断</li><li>NMI(Non-Maskable Interrupt)：不可屏蔽中断</li></ul></li><li>触发方式(TriggerMode)：指定该中断是上升沿触发、下降沿触发、还是电平触发</li><li>屏蔽位(Mask)：如果设置为1，表示屏蔽（禁用）该中断；如果设置为0，则启用该中断</li><li>目标处理器(DestinationCPU)：如果是多处理器系统，LVT还会指定该中断由哪个CPU来处理</li></ul><p><strong>主要条目：</strong></p><ul><li>LVT Timer(APIC_LVTT)：<ul><li>该条目用于管理Local APIC的定时器中断</li><li>它控制定时器的触发方式，通常配置为周期性中断或一次性中断，用于定期触发操作系统的调度器</li></ul></li><li>LVT Keyboard(APIC_LVT0)：<ul><li>该条目用于管理键盘中断。实际上，它并不常用与现代系统，但可以用于设置其他外部中断源</li></ul></li><li>LVT Spurious Interrupt(APIC_LVT1)：<ul><li>该条目用于设置处理杂散中断(spuriousinterrupts)的行为。杂散中断通常是一些错误或无效的中断源</li></ul></li><li>LVT Error(APIC_LVTERR)：<ul><li>该条目用于处理APIC自身产生的错误中断。如果APIC遇到硬件错误或配置错误，就会触发该中断</li></ul></li><li>LVT Thermal(APIC_LVTTHMR)：<ul><li>该条目用于处理热管理中断，例如温度监测相关的事件。这在支持热管理的系统中非常重要</li></ul></li><li>LVT Machine Check(APIC_LVTCMCI)：<ul><li>该条目用于处理机器检查(Machine Check Exception,MCE)中断，通常用于检测硬件故障或系统错误</li></ul></li><li>LVT Performance Counter(APIC_LVTPC)：<ul><li>该条目用于管理性能计数器相关的中断</li></ul></li></ul><p><strong>LVT的操作：</strong></p><ul><li>写入LVT寄存器：通过<code>apic_write()</code>和<code>apic_read()</code>函数对LVT寄存器进行写入和读取操作，修改LVT条目的值</li><li>屏蔽LVT条目：通过将LVT的屏蔽位设置为1来屏蔽中断。通过将其恢复为0可以启用中断</li><li>配置触发方式：根据需要配置中断的触发方式</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS硬件设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件设备</tag>
      
      <tag>APIC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAM几何引擎简介</title>
    <link href="/2025/01/06/CAM%E5%87%A0%E4%BD%95%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B/"/>
    <url>/2025/01/06/CAM%E5%87%A0%E4%BD%95%E5%BC%95%E6%93%8E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>概述：</strong> Computer-AidedManufacturing（计算机辅助制造）几何引擎，处理与制造过程相关的几何计算。简单来说，CAM几何引擎是一个能够生成、修改和优化几何数据，以指导制造过程的核心组件</p><p><strong>功能：</strong></p><ul><li>几何建模：用于构建零件或产品的几何模型。这些几何模型通常是基于CAD系统中的设计文件（例如STL、STEP、IGES等格式），但在CAM中需要进一步转换为适合制造的格式</li><li>路径规划：负责生成刀具路径或轨迹，这对于数控机床(CNC)至关重要。根据零件的几何形状和材料，计算机会生成合理的切割路径。</li><li>优化与仿真：进行刀具路径的优化，如减少加工时间、提高加工质量，并进行加工过程的虚拟仿真，以预防潜在问题</li></ul><p><strong>核心技术：</strong></p><ul><li>曲线和曲面建模：处理曲线（如直线、圆弧、样条曲线等）和曲面（如Bézier曲面、NURBS曲面等）</li><li>几何转换：处理几何数据的转换</li><li>碰撞检测与干涉检查：在生成刀具路径时，需要检测刀具与工件、夹具之间是否发生碰撞，这要求几何引擎进行空间判断</li><li>离散化与插值：在数控加工中，路径通常是连续的，但机床无法直接理解连续的路径数据，因此需要将路径离散化成离散的切割点。</li></ul><p><strong>应用场景：</strong></p><ul><li>数控加工：生成控制CNC机床和刀具路径</li><li>3D打印</li><li>模具设计</li><li>装配与机器人路径规划：计算机器人移动最优路径</li></ul><p><strong>常见软件：</strong> Mastercam、Fusion 360、SiemensNX、SolidCAM</p><p><strong>挑战与发展：</strong></p><ul><li>复杂性：处理越来越复杂的几何模型</li><li>计算效率：满足实时性要求，在有限时间内完成计算</li><li>集成与互操作性：能与其他CAD、CAE、PLM等系统无缝衔接，支持跨平台协同工作</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的常见关键字</title>
    <link href="/2025/01/02/C-%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2025/01/02/C-%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="常见关键字">常见关键字</h1><p><strong>new和delete：</strong></p><ul><li>new：分配内存，调用构造函数初始化对象</li><li>delete：释放内存，释放内存前会调用析构函数</li></ul><p><strong>static：</strong>声明静态成员函数、静态成员变量、静态局部变量、静态全局变量（内部链接）</p><p><strong>const：</strong> 定义不可修改的值</p><p><strong>volatile：</strong>告诉编译器某个变量的值可能在程序外部发生变化（如硬件寄存器、共享内存活多线程场景），因此编译器不能对该变量进行优化</p><blockquote><p>在多线程环境中，volatile能确保主线程修改的共享变量对其他线程立即可见，但它不保证原子性操作，也不防止竞态条件</p></blockquote><p><strong>inline：</strong>提示编译器将函数的代码直接插入调用点，而不是通过常规的函数调用机制。通常用于小函数，减少函数调用开销</p><p><strong>friend：</strong>允许指定某个函数或类访问另一个类的私有成员</p><p><strong>mutable：</strong>用于允许类的常量成员变量被修改，即使在常量成员函数中</p><p><strong>this：</strong>指向当前对象的指针，只有在类的成员函数内可用</p><p><strong>typeid和decltype：</strong></p><ul><li>typeid：是RTTI(运行时类型识别)的一部分，在多态场景中，typeid用于检查对象的实际类型。它在底层依赖虚表和类型信息存储</li><li>decltype：是在编译时推导类型的工具，它不会生成任何代码，而是通过编译器的类型推断机制来确定表达式的类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MMIO</title>
    <link href="/2024/12/30/MMIO/"/>
    <url>/2024/12/30/MMIO/</url>
    
    <content type="html"><![CDATA[<h1 id="mmio">MMIO</h1><p><strong>概述：</strong> Memory-Mapped I/O是一种用于与硬件设备交互的技术。MMIO将设备的地址空间映射到系统的内存地址空间，操作系统通过读写内存来与这些设备进行通信。</p><p><strong>传统的IO：</strong>通过专门的IO指令（如in和out）访问设备。这些指令与CPU的内存访问指令不同，需要通过IO端口与硬件进行交互</p><p><strong>工作流程：</strong></p><ol type="1"><li>硬件地址映射：设备的寄存器和缓冲区在系统启动时会被映射到特定的内存地址区域。这个过程通常由硬件初始化程序或操作系统内核的启动代码完成</li><li>设备寄存器访问：操作系统可以直接通过读写相应的内存地址来操作硬件。</li></ol><p><strong>MMU：</strong>内存管理单元，复杂将设备寄存器的物理地址映射到主内存的虚拟地址，操作系统通常会提供该机制，从而实现对设备的读写操作</p><p><strong>类型：</strong></p><ul><li>普通MMIO：这些设备的寄存器空间通常较小，可能只涉及一些特定的控制寄存器。它们在内存空间中的映射通常时直接的、线性的</li><li>扩展MMIO：这些设备的寄存器空间较大，可能涉及多种控制寄存器、数据缓冲区或其他内存区域。这些地址通常会位于更高的物理地址空间，以避免与普通内存发生冲突</li></ul><p><strong>优点：</strong></p><ul><li>高效性：MMIO通过内存总线与设备进行交互，避免了传统IO操作中频繁的IO端口访问，提高了数据交换的效率</li><li>简化访问：可以像访问内存一样访问设备，无需复杂的IO操作，降低了硬件操作的复杂性</li><li>灵活性：可以直接操作设备的控制寄存器</li></ul><p><strong>缺点：</strong></p><ul><li>地址冲突：设备寄存器通常会映射到特定的内存区域，避免与系统内存区域重叠</li><li>性能瓶颈：过度的MMIO访问可能会导致总线带宽瓶颈，尤其是在大量设备同时访问的情况下</li><li>硬件依赖性：不同硬件的MMIO地址范围和实现方式不同，操作系统需要提供特定的驱动程序来支持不同设备的访问</li></ul><p><strong>OS中MMIO的实现：</strong></p><ul><li>设备驱动程序：负责在OS中映射MMIO地址，并提供接口与硬件进行交互</li><li>地址映射：OS需要使用MMU来将设备寄存器地址映射到虚拟内存地址，通过内存映射文件或直接通过mmap系统调用实现</li><li>同步与缓存管理：由于MMIO涉及到硬件的直接空间，需要确保访问的同步性，避免CPU缓存与硬件之间的数据不一致</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS硬件设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件设备</tag>
      
      <tag>MMIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FADT</title>
    <link href="/2024/12/30/FADT/"/>
    <url>/2024/12/30/FADT/</url>
    
    <content type="html"><![CDATA[<h1 id="fadt">FADT</h1><p><strong>概述：</strong> FADT(Fixed ACPI DescriptionTable)表是ACPI编程接口中使用一种的数据结构，该表包含与电源管理相关的固定寄存器块的信息。</p><h2 id="查找fadt">查找FADT</h2><p>通过RSDP指针以获取RSDT或XSDT，然后找到FADT，FADT是RSDT或XSDT的一个条目、FADT结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FADT</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ACPISDTHeader</span> <span class="hljs-title">h</span>;</span> <span class="hljs-comment">// ACPI 标准描述表头部</span><br>    <span class="hljs-type">uint32_t</span> FirmwareCtrl; <span class="hljs-comment">// 固件控制寄存器地址</span><br>    <span class="hljs-type">uint32_t</span> Dsdt; <span class="hljs-comment">// DSDT 表地址</span><br><br>    <span class="hljs-comment">// ACPI 1.0 中使用的字段；现在不再使用，仅用于兼容性</span><br>    <span class="hljs-type">uint8_t</span> Reserved;<br><br>    <span class="hljs-type">uint8_t</span> PreferredPowerManagementProfile; <span class="hljs-comment">// 首选电源管理配置</span><br>    <span class="hljs-type">uint16_t</span> SCI_Interrupt; <span class="hljs-comment">// SCI 中断</span><br>    <span class="hljs-type">uint32_t</span> SMI_CommandPort; <span class="hljs-comment">// SMI 命令端口</span><br>    <span class="hljs-type">uint8_t</span> AcpiEnable; <span class="hljs-comment">// ACPI 启用</span><br>    <span class="hljs-type">uint8_t</span> AcpiDisable; <span class="hljs-comment">// ACPI 禁用</span><br>    <span class="hljs-type">uint8_t</span> S4BIOS_REQ; <span class="hljs-comment">// S4BIOS 请求</span><br>    <span class="hljs-type">uint8_t</span> PSTATE_Control; <span class="hljs-comment">// PSTATE 控制</span><br>    <span class="hljs-type">uint32_t</span> PM1aEventBlock; <span class="hljs-comment">// PM1a 事件块地址</span><br>    <span class="hljs-type">uint32_t</span> PM1bEventBlock; <span class="hljs-comment">// PM1b 事件块地址</span><br>    <span class="hljs-type">uint32_t</span> PM1aControlBlock; <span class="hljs-comment">// PM1a 控制块地址</span><br>    <span class="hljs-type">uint32_t</span> PM1bControlBlock; <span class="hljs-comment">// PM1b 控制块地址</span><br>    <span class="hljs-type">uint32_t</span> PM2ControlBlock; <span class="hljs-comment">// PM2 控制块地址</span><br>    <span class="hljs-type">uint32_t</span> PMTimerBlock; <span class="hljs-comment">// 定时器块地址</span><br>    <span class="hljs-type">uint32_t</span> GPE0Block; <span class="hljs-comment">// GPE0 块地址</span><br>    <span class="hljs-type">uint32_t</span> GPE1Block; <span class="hljs-comment">// GPE1 块地址</span><br>    <span class="hljs-type">uint8_t</span> PM1EventLength; <span class="hljs-comment">// PM1 事件长度</span><br>    <span class="hljs-type">uint8_t</span> PM1ControlLength; <span class="hljs-comment">// PM1 控制长度</span><br>    <span class="hljs-type">uint8_t</span> PM2ControlLength; <span class="hljs-comment">// PM2 控制长度</span><br>    <span class="hljs-type">uint8_t</span> PMTimerLength; <span class="hljs-comment">// 定时器长度</span><br>    <span class="hljs-type">uint8_t</span> GPE0Length; <span class="hljs-comment">// GPE0 长度</span><br>    <span class="hljs-type">uint8_t</span> GPE1Length; <span class="hljs-comment">// GPE1 长度</span><br>    <span class="hljs-type">uint8_t</span> GPE1Base; <span class="hljs-comment">// GPE1 基址</span><br>    <span class="hljs-type">uint8_t</span> CStateControl; <span class="hljs-comment">// C 状态控制</span><br>    <span class="hljs-type">uint16_t</span> WorstC2Latency; <span class="hljs-comment">// 最差的 C2 延迟</span><br>    <span class="hljs-type">uint16_t</span> WorstC3Latency; <span class="hljs-comment">// 最差的 C3 延迟</span><br>    <span class="hljs-type">uint16_t</span> FlushSize; <span class="hljs-comment">// 刷新大小</span><br>    <span class="hljs-type">uint16_t</span> FlushStride; <span class="hljs-comment">// 刷新步进</span><br>    <span class="hljs-type">uint8_t</span> DutyOffset; <span class="hljs-comment">// 任务偏移</span><br>    <span class="hljs-type">uint8_t</span> DutyWidth; <span class="hljs-comment">// 任务宽度</span><br>    <span class="hljs-type">uint8_t</span> DayAlarm; <span class="hljs-comment">// 日闹钟</span><br>    <span class="hljs-type">uint8_t</span> MonthAlarm; <span class="hljs-comment">// 月闹钟</span><br>    <span class="hljs-type">uint8_t</span> Century; <span class="hljs-comment">// 世纪</span><br><br>    <span class="hljs-comment">// ACPI 1.0 中保留；自 ACPI 2.0+ 开始使用</span><br>    <span class="hljs-type">uint16_t</span> BootArchitectureFlags; <span class="hljs-comment">// 启动架构标志</span><br><br>    <span class="hljs-type">uint8_t</span> Reserved2;<br>    <span class="hljs-type">uint32_t</span> Flags; <span class="hljs-comment">// 标志位</span><br><br>    <span class="hljs-comment">// 12 字节结构；详情请参阅下文</span><br>    GenericAddressStructure ResetReg; <span class="hljs-comment">// 复位寄存器</span><br><br>    <span class="hljs-type">uint8_t</span> ResetValue; <span class="hljs-comment">// 复位值</span><br>    <span class="hljs-type">uint8_t</span> Reserved3[<span class="hljs-number">3</span>];<br><br>    <span class="hljs-comment">// 64 位指针 - 在 ACPI 2.0+ 中可用</span><br>    <span class="hljs-type">uint64_t</span> X_FirmwareControl; <span class="hljs-comment">// 扩展固件控制寄存器地址</span><br>    <span class="hljs-type">uint64_t</span> X_Dsdt; <span class="hljs-comment">// 扩展 DSDT 表地址</span><br><br>    GenericAddressStructure X_PM1aEventBlock; <span class="hljs-comment">// 扩展 PM1a 事件块地址</span><br>    GenericAddressStructure X_PM1bEventBlock; <span class="hljs-comment">// 扩展 PM1b 事件块地址</span><br>    GenericAddressStructure X_PM1aControlBlock; <span class="hljs-comment">// 扩展 PM1a 控制块地址</span><br>    GenericAddressStructure X_PM1bControlBlock; <span class="hljs-comment">// 扩展 PM1b 控制块地址</span><br>    GenericAddressStructure X_PM2ControlBlock; <span class="hljs-comment">// 扩展 PM2 控制块地址</span><br>    GenericAddressStructure X_PMTimerBlock; <span class="hljs-comment">// 扩展定时器块地址</span><br>    GenericAddressStructure X_GPE0Block; <span class="hljs-comment">// 扩展 GPE0 块地址</span><br>    GenericAddressStructure X_GPE1Block; <span class="hljs-comment">// 扩展 GPE1 块地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>FirmwareCtrl：</strong>这是一个指向FACS（固件控制结构）的32位指针。自ACPI2.0版本，表格中添加了一个新字段，名为X_FirmwareControl，类型为GAS，宽度为64位。这两个字段中只有一个被使用，另一个字段包含0。根据规范，当FACS放置在第4个GB上方时，才会使用X_字段</p><p><strong>Dsdt：</strong>这是一个指向DSDT（差异化系统描述表）的32位指针，同时还有一个名为X_Dsdt的兄弟字段。</p><p><strong>PreferredPowerManagementProfile：</strong>该值应指向一个电源管理配置文件，例如，如果它包含2，则计算机是笔记本电脑，并且您应该在省电模式下配置电源管理</p><p>值含义：</p><table><thead><tr><th>0</th><th>未指定</th></tr></thead><tbody><tr><td>1</td><td>桌面电脑</td></tr><tr><td>2</td><td>移动设备（笔记本电脑）</td></tr><tr><td>3</td><td>工作站</td></tr><tr><td>4</td><td>企业服务器</td></tr><tr><td>5</td><td>SOHO服务器</td></tr><tr><td>6</td><td>设备PC</td></tr><tr><td>7</td><td>性能服务器</td></tr><tr><td>大于7</td><td>保留</td></tr></tbody></table><p><strong>SCI_Interrupt：</strong></p><p>ACPI使用系统控制中断(SCI)通知OS有关固定事件的信息，例如按下电源按钮，或用于特定于固件的通用事件（GPE）。</p><p>FADT结构中这个字段指示了用于SCI的PIC（可编程中断控制器）或IOAPIC（输入输出高级可编程中断控制器）中断引脚。</p><p>要知道它是否是PICIRQ，通过MADT（多处理器描述表）检查是否存在双8259中断控制器，否则，它就是一个GSI（全局系统中断）。</p><p>如果正在使用IOAPIC并且PIC存在，请首先检查中断源覆盖以获取与IRQ源相关联的GSI。</p><p><strong>SMI_CommandPort：</strong></p><p>这是一个I/O端口，OS在这里写入AcpiEnable或AcpiDisable，以获取或释放ACPI寄存器的所有权，在不支持SMM（系统管理模式）的系统上，该端口地址为0。</p><h2 id="gnericaddress结构体">GnericAddress结构体</h2><p>GAS是ACPI用来描述寄存器位置的一种结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GenericAddressStructure</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint8_t</span> AddressSpace; <span class="hljs-comment">// 地址空间标识</span><br>  <span class="hljs-type">uint8_t</span> BitWidth; <span class="hljs-comment">// 位宽</span><br>  <span class="hljs-type">uint8_t</span> BitOffset; <span class="hljs-comment">// 位偏移</span><br>  <span class="hljs-type">uint8_t</span> AccessSize; <span class="hljs-comment">// 访问大小</span><br>  <span class="hljs-type">uint64_t</span> Address; <span class="hljs-comment">// 地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>AddressSpace：</strong> 寄存器所在的地址空间</p><table><thead><tr><th>值</th><th>地址空间</th></tr></thead><tbody><tr><td>0x00</td><td>系统内存</td></tr><tr><td>0x01</td><td>系统I/O</td></tr><tr><td>0x02</td><td>PCI配置空间</td></tr><tr><td>0x03</td><td>嵌入式控制器</td></tr><tr><td>0x04</td><td>系统管理总线</td></tr><tr><td>0x05</td><td>系统CMOS</td></tr><tr><td>0x06</td><td>PCI设备BAR目标</td></tr><tr><td>0x07</td><td>智能平台管理基础设施</td></tr><tr><td>0x08</td><td>通用性I/O</td></tr><tr><td>0x09</td><td>通用串行总线</td></tr><tr><td>0x0A</td><td>平台沟通渠道</td></tr><tr><td>0x0B to 0x0F</td><td>保留位</td></tr><tr><td>0x80 to 0xFF</td><td>OEM定义</td></tr></tbody></table><p><strong>BitWidth：</strong> 寄存器的位宽，即寄存器中数据的位数</p><p><strong>BitOffset：</strong> 指示数据在寄存器中的偏移量</p><p><strong>AccessSize：</strong> 定义一次可以读/写的字节数</p><table><thead><tr><th>值</th><th>访问大小</th></tr></thead><tbody><tr><td>0x00</td><td>未定义</td></tr><tr><td>0x01</td><td>字节（8位）访问</td></tr><tr><td>0x02</td><td>16位访问</td></tr><tr><td>0x03</td><td>32位访问</td></tr><tr><td>0x04</td><td>64位访问</td></tr></tbody></table><p><strong>Address：</strong> 寄存器的地址</p><h2 id="参考">参考</h2><ul><li><a href="https://wiki.osdev.org/FADT#SCI_Interrupt">FADT - OSDevWiki</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS硬件设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>硬件设备</tag>
      
      <tag>FADT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACPI_PM_Timer</title>
    <link href="/2024/12/29/ACPI-PM-Timer/"/>
    <url>/2024/12/29/ACPI-PM-Timer/</url>
    
    <content type="html"><![CDATA[<h1 id="acpi-pm-timer">ACPI PM Timer</h1><p><strong>概述：</strong> ACPI PM Timer是一个非常简单的计时器，它以3.579545 MHz运行，在计数器溢出时生成系统控制中断（SCI）。它精度较低，建议使用其他定时器，如HPET或APIC定时器。</p><h2 id="检测acpi-pm-timer">检测ACPI PM Timer</h2><p><strong>关键概念：</strong></p><ul><li>RSDP(Root System DescriptionPointer)：是一个指向ACPI系统表（如RSDT或XSDT）的指针。它位于系统内存的一个固定位置，操作系统会在启动时查找这个指针，以便访问ACPI表。RSDP在大多数情况下存储在系统的低地址区域（如BIOS固件中）</li><li>RSDT(Root System DescirptionTable)：是一个包含指向其他ACPI表的指针的ACPI表，它提供了系统固件中定义的所有ACPI结构的入口。</li><li>XSDT(Extended System DescriptionTable)：是RSDT的扩展，用于支持64位系统。于RSDT使用32指针不同，XSDT使用64位指针，可以支持更多的表</li><li>FADT(Fixed ACPI DescriptionTable)：是ACPI表之一，包含固定的ACPI信息，如电源管理、配置等内容，它描述了系统硬件的一些基本信息，并提供了与电源管理和系统管理相关的接口。</li></ul><p><strong>如何查找：</strong></p><p>通过RSDP指针以获取RSDT或XSDT，然后找到FADT。一旦找到了FADT，需要检查PMTimerLength字段是否为4，如果不是，则必须假定该计时器不可用。然后，如果ACPI的版本为2或更高，并且X_PMTimerBlock通用地址结构可用（检测地址不为0），则使用它，否则，将PMTimerBlock用作IO端口。</p><h2 id="位和32位模式">24位和32位模式</h2><p>ACPI PMTimer支持24位和32位计数器。如果FADA标志的第8位被设置，则计数器位32位。</p><h2 id="读取counter值">读取counter值</h2><p><strong>使用的是X_PMTimerBlock：</strong></p><ul><li>检查地址在哪个空间地址中<ul><li>如果是MMIO（内存映射I/O）：将地址映射到虚拟内存中，并从中读取无符号32位整数counter值</li><li>如果是IO（端口I/O）：从I/O端口读取无符号32位整数counter值</li></ul></li></ul><p><strong>使用的是PM_Timer：</strong></p><ul><li>直接从I/O端口读取无符号32位整数counter值</li></ul><h2 id="counter值">counter值</h2><table><thead><tr><th>位</th><th>描述</th></tr></thead><tbody><tr><td>0:23</td><td>计数器的24位</td></tr><tr><td>24:31</td><td>如果计数器是32位的，则为计数器的高8位。如果计数器是24位的，则为0.</td></tr></tbody></table><h2 id="中断请求">中断请求</h2><p>ACPI PM Timer在计数器溢出时会触发一个系统控制中断（SCI）。</p><h2 id="参考">参考</h2><ul><li><a href="https://wiki.osdev.org/ACPI_Timer">ACPI Timer - OSDevWiki</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS硬件设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acpi</tag>
      
      <tag>硬件设备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust入门学习笔记</title>
    <link href="/2024/12/29/Rust%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/29/Rust%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="rust简介">Rust简介</h1><h2 id="特点">特点</h2><p>即安全又高效，并发</p><p>是一种静态编译语言，要在写代码时声明数据类型</p><h2 id="擅长领域">擅长领域</h2><p>高性能Web Service</p><p>WebAssembly</p><p>命令行工具</p><p>网络编程</p><p>嵌入式设备</p><p>系统编程</p><h2 id="操作">操作</h2><p>更新rust：rustup update</p><p>卸载rust：rustup self uninstall</p><p>查看rust版本：rustc --version</p><p>查看本地文档：rustup doc</p><p>用vscode打开某项目：进入项目目录后 code .</p><h2 id="文件名">文件名</h2><p>后缀：rs</p><p>命名规范：hello_world.rs</p><h2 id="编译">编译</h2><p>rustc hello_world.rs（只适合简单的程序）</p><p>运行exe文件</p><h2 id="代码组织">代码组织</h2><p>代码组织主要包括： 哪些细节可以暴露，哪些细节是私有的作用域内哪些名称有效</p><p>模块系统： Package(包)：cargo特性，让你构建、测试、共享crateCrate(单元包)：一个模块树，它可产生一个library或可执行文件Module(模块)、use：让你控制代码的组织、作用域、私有路径Path(路径)：为struct、function或module等项命名的方式</p><p>Package包含Crate，Crate包含Module</p><h3 id="package">Package</h3><p>1、包含一个Cargo.toml，它描述如何构建这些Crates2、只能包含0-1个library crate 3、可以包含任意数量的binary crate4、但必须至少包含一个crate（library或binary）</p><h3 id="crate">Crate</h3><p>crate类型：library和binary</p><p>Crate Root： 是源代码文件Rust编译器从这里开始，组成你的Crate的根Module</p><p>Cargo惯例： src/ main.rs: binary crate的crate rootcrate名与package名相同 src/lib.rs: package 包含一个library crate librarycrate 的 crate root crate名与package名相同</p><p>Cargo把crate root 文件交给rustc来构建library 或 binary</p><p>一个Package可以同时包含src/main.rs和src/lib.rs 一个binarycrate和一个library crate 名称与package名相同 一个Pacage可以有多个binarycrate： 文件放在src/bin 每个文件都是单独的binary crate</p><h3 id="module">Module</h3><p>在一个crate内，代码进行分组 增加可读性，易于复用控制项目（item）的私有性，public、private</p><p>建立module： mod关键字 可嵌套可包含其他项（struct、enum、常量、trait、函数等）的定义</p><p>实例代码： 单独创建一个文件lib.rs或其他名.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house&#123;<br>    <span class="hljs-keyword">mod</span> hosting&#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">seat_at_table</span>()&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">mod</span> serving&#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_order</span>()&#123;&#125;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">serve_order</span>()&#123;&#125;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_payment</span>()&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>src/main.rs和src/lib.rs叫做crate roots:这两个文件（任意一个）的内容形成了名为crate的模块，位于整个模块树的根部</p><h3 id="私有边界">私有边界</h3><p>模块不仅可以组织代码，还可以定义私有边界如果想把函数或结构体等设为私有，可以将它放到某个模块中Rust中所有的条目（函数、方法、struct、enum、模块、常量）默认是私有的</p><p>父级模块无法访问子模块中的私有条目 子模块可以使用祖先模块中的条目</p><p>使用pub关键字可以将条目标记为公共的</p><p>pub strcut: pub放在struct前：struct是公共的，但里面的字段默认是私有的</p><p>pub enum: enum是公共的，里面的变体也都是公共的</p><h3 id="路径">路径</h3><p>为了在Rust的模块中找到某个条目，需要使用<strong>路径</strong></p><p>路径的两种形式： 绝对路径：从crate root开始，使用crate名或字面值crate相对路径：从当前模块开始，使用self，super或当前模块的标识符路径至少由一个标识符组成，标识符之间使用::</p><p>在src下创建lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//都是crate文件下的同一级，可以互项调用</span><br><span class="hljs-keyword">mod</span> front_of_house&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting&#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>()&#123;<br>    <span class="hljs-comment">//绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    <span class="hljs-comment">//相对路径</span><br>    front_of_house::hosting::add_to_waitlist;<br>&#125;<br></code></pre></td></tr></table></figure><p>super关键字： 用来访问父级模块路径中的内容，类似文件系统的..</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">serve_order</span>()&#123;&#125;<br><span class="hljs-keyword">mod</span> back_of_house&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fix_incorrect_order</span>()&#123;<br>        <span class="hljs-title function_ invoke__">cook_order</span>();<br>        <span class="hljs-comment">//使用super关键字</span><br>        super::<span class="hljs-title function_ invoke__">serve_order</span>();<br>        <span class="hljs-comment">//使用绝对路径</span><br>        crate::<span class="hljs-title function_ invoke__">serve_order</span>();<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cook_order</span>()&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="use关键字">use关键字</h3><p>可以使用use关键字将路径(可以用绝对路径和相对路径，一般用绝对路径)导入到作用域内，仍遵循私有性规则</p><p>use的习惯用法： 函数：将函数的父级模块引入作用域（指定到父级）struct、enum、其他：指定到完整路径（指定到本身）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting&#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>()&#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collection::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    map.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于同名条目，则需要指定到父级。或者使用as关键字为引入的路径指定本地别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br></code></pre></td></tr></table></figure><p>使用pub use重新导出名称使用use将路径（名称）导入到作用域后，该名称在此作用域内是私有的。 pubuse：重导出该条目引入作用域，该条目也可以被外部代码引入到它们的作用域</p><p>使用嵌套路径清理大量的use语句：如果使用同一个包或模块下的多个条目，可使用嵌套路径在同一行内将上述条目引入：路径相同的部分::{路径差异的部分}如果两个use路径值意是另一个的子路径，使用self</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//use std::cmp::Ordering;</span><br><span class="hljs-comment">//use std::io;</span><br><span class="hljs-keyword">use</span> std::&#123;cmp::Ordering, io&#125;;<br><br><span class="hljs-comment">//use std::io</span><br><span class="hljs-comment">//use std::io::Write</span><br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br></code></pre></td></tr></table></figure><p>通配符<span class="math inline">\(*\)</span> 使用<spanclass="math inline">\(*\)</span>可以把路径中所有公共条目都引入到作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::*;<br></code></pre></td></tr></table></figure><p>应用场景： 测试。将所有测试代码引入到tests模块 有时用于预导入模块</p><h3 id="使用外部包">使用外部包</h3><p>1、Cargo.toml添加依赖的包 2、use将特定条目引入作用域</p><h3 id="将模块内容移动到其他文件">将模块内容移动到其他文件</h3><p>模块定义时，如果模块后边是";"，而不是代码块：Rust会从与模块同名的文件中加载内容 模块树的结构不会变化</p><p>随着模块逐渐变大，该技术可以让你把模块的内容移动到其他文件中</p><p>lib.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>()&#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>front_of_house.rs:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting;<br></code></pre></td></tr></table></figure><p>front_of_house/hosting.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>()&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="宏">宏</h1><h2 id="简介">简介</h2><p>宏在rust里指的是一组相关特性的集合称谓：1、使用macro_rules!构建的声明宏（可能要弃用，不深究） 2、3种过程宏：自定义#[derive]宏，用于struct或enum，可以为其指定随derive属性添加的代码类似属性的宏，在任何条目上添加自定义属性类似函数的共，看起来像函数调用，对其指定为参数的token进行操作</p><p>函数与宏的差别：1、本质上，宏是用来编写可以生成其他代码的代码（元编程）2、函数在定义签名时，必须声明参数的个数和类型，宏可处理可变的参数3、编译器会在解释代码前展开宏4、宏的定义比函数复杂得多，难以阅读、理解、维护5、在某个文件调用宏时，必须提前定义宏或将宏引入当前作用域内6、函数可以在任何位置定义并在任何位置使用</p><h2 id="macro_rules-声明宏">macro_rules! 声明宏</h2><p>类似match模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><span class="hljs-comment">//意味引入作用域后使用，这样就看可以声明有这个宏了</span><br><span class="hljs-built_in">macro_rules!</span> vec &#123;<br>( $( $x:expr ),* ) =&gt; &#123;<br>    &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">temp_vec</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            $(<br>                temp_vec.<span class="hljs-title function_ invoke__">push</span>($x);<br>            )*<br>            temp_vec<br>    &#125;<br>    &#125;;<br>&#125;<span class="hljs-comment">//实现vec!宏</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">mod</span> macros &#123;<br>    <span class="hljs-built_in">macro_rules!</span> my_macro &#123;<br>        () =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Check out my macro!&quot;</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_macro!();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[rustfmt::skip]</span><br><span class="hljs-built_in">macro_rules!</span> my_macro &#123;<br>    () =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Check out my macro!&quot;</span>);<br>    &#125;;<br>    ($val:expr) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Look at this other macro: &#123;&#125;&quot;</span>, $val);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    my_macro!();<br>    my_macro!(<span class="hljs-number">7777</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基于属性来生成代码的过程宏">基于属性来生成代码的过程宏</h2><p>1、这种形式更像函数一些： 接收并操作输入的rust代码生成另外一些rust代码作为结果 2、三种过程宏： 自定义派生 属性宏 函数宏3、创建过程宏时：宏定义必须单独放在它们自己的包中，并使用特殊的包类型</p><p>自定义derivr宏： 需求：1、创建一个hello_macro包，定义一个拥有关联函数hello_macro和HelloMacrotrait 2、提供一个能够自动实现trait的过程宏3、在它们的类型上标注#[derive(HelloMacro)]，进而得到hello_macro的默认实现（例子看不懂：BV1hp4y1k7SV的P107）</p><p>类似属性的宏： 1、属性宏与自定义derive宏类似： 允许创建新的属性但不是为derive属性生成代码 2、属性宏更加灵活：derive只能用于struct和enum 属性宏可以用于任意条目，例如函数</p><p>类似函数的宏： 1、函数定义类似于函数调用的宏，但比普通股函数更加灵活2、函数宏可以接收TokenStream作为参数3、与另外两种过程宏一样，在定义中使用rust代码来操作TokenStream</p><h1 id="cargo">Cargo</h1><h2 id="简介-1">简介</h2><p>Cargo是Rust的构建系统和包管理工具：用于构建代码，下载依赖的库、构建这些库。（安装rust会安装cargo）</p><p>查看cargo版本：cargo --version</p><h2 id="操作-1">操作</h2><h3 id="创建项目">创建项目</h3><p>cargo new 项目名称</p><p>Cargo.toml: 1、是Cargo的配置格式2、package是一个区域标题，表示下方的内容是用来配置包的，name项目名，verstion项目版本，authors项目作者，edition使用的rust版本3、dependencies是另一个区域的开始，它会列出项目的依赖项（依赖库）4、在Rust里面，代码的包称作crate</p><p>cargo生成的main.rs在src目录下，而cargo.toml在项目顶层下，顶层目录可以防止README、许可信息、配置文件和其他</p><p>如果创建项目的时候没有使用cargo，也可以把项目转化为cargo：1、把源代码移动到src下 2、创建Cargo.toml并填写相应的配置</p><p>创建库项目： cargo new 项目名称 --lib</p><h3 id="构建项目">构建项目</h3><p>在项目里cargo build即可</p><p>生成.lock文件和target文件夹</p><p>Cargo.lock:1、首次构建时创建的文件，会找到该代码中符合要求的依赖项并写到lock文件2、在以后构建，会先使用lock文件中指定的依赖项版本，而不是最新的版本，除非自己手动指定（在toml文件中指定）</p><p>为发布构建：cargo build --release</p><h3 id="构建并运行项目">构建并运行项目</h3><p>cargo run</p><h3 id="检查代码">检查代码</h3><p>cargo check</p><p>检查代码，确保能通过编译，但不产生可执行文件（比cargo build快）</p><h2 id="发布配置">发布配置</h2><p>通过发布配置（release profile）来自定义构建： 1、是预定义的2、可自定义：可使用不同的配置，对代码编译拥有更多的控制3、每个profile的配置都独立于其他的profile</p><p>cargo主要的两个profile： 1、dev profile：适用于开发，cargo build2、release profile：适用于发布，cargo build --release</p><p>自定义profile： 1、针对每个profile，cargo都提供了默认的配置2、如果想自定义xxxxprofile的配置：可以在cargo.toml里添加[profile.xxxx]区域，在里面覆盖默认配置的子集（有[profile.dev]和[profile.release]）</p><p>在dev模式下，opt-level默认值是0（不要性能，编译快）在release模式下，opt-level默认值是3（要性能，编译慢）</p><h2 id="发布crate">发布crate</h2><p>发布到crate.io： 1、可以通过发布包来共享代码2、crate注册表在http://crates.io/</p><p>文档注释： 生成HTML文档 显式公共API的文档注释，如何使用API 使用///支持markdowns 放置在被说明条目之前</p><p>生成HTML文档的命令：cargo doc 它会运行rustdoc工具（rust安装包自带）把生成的HTML文档放在target/doc目录下 cargo doc--open能生成并打开文档</p><p>文档注释常用章节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">///# Examples</span><br><span class="hljs-comment">///```</span><br><span class="hljs-comment">///示例代码</span><br><span class="hljs-comment">///```</span><br></code></pre></td></tr></table></figure><p>其他常用章节： Panics：函数可能发生panic的场景Errors：如果函数返回Result，描述可能的错误种类，以及可导致错误的条件Safety：如果函数处于unsafe调用，就应该解释函数unsafe的原因，以及调用者确保的使用前提</p><p>文档注释作为测试： 示例代码块的附加值： 运行cargotest：将把文档注释中示例代码作为测试来运行</p><p>为包含注释的项添加文档注释： 符号：//! 这类注释通常描述crate和模块：crate root（按惯例为src/lib.rs）一个模块内，将crate或模块作为一个整体进行记录</p><p>上面的示例(lib.rs文件中的代码)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//! # CaoGao</span><br><span class="hljs-comment">//! Hello Wolrd!</span><br><span class="hljs-comment">//! </span><br><br><span class="hljs-comment">///Adds one to the number given</span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// # Examples</span><br><span class="hljs-comment">/// ```</span><br><span class="hljs-comment">/// let arg = 5;</span><br><span class="hljs-comment">/// let answer = my_crate::add_one(arg);</span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// assert_eq!(6, answer);</span><br><span class="hljs-comment">/// ```</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(arg: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    arg<br>&#125;<br></code></pre></td></tr></table></figure><p>详细关于发布代码到crate.io网站上的操作： 看b站BV1hp4y1k7SV 的P82</p><h2 id="pub-use">pub use</h2><p>使用pub use导出方便使用的公共API</p><p>问题：crate程序结构在开发时对于开发者很合理，但对于它的使用者不够方便。 例如：麻烦：my_crate::some_module::another_module::UsefulType方便：my_crate::UsefulType 解决方案： 使用pubuse，可以重新导出，创建一个与内部私有结构不同的对外公共结构</p><p>lib.rs：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> self::kinds::PrimaryColor;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> kinds&#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PrimaryColor</span> &#123;<br>        Red,<br>        Yellow,<br>Blue,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//use crate::kinds::PrimaryColor;</span><br><span class="hljs-keyword">use</span> crate::PrimaryColor;<br></code></pre></td></tr></table></figure><h2 id="工作空间">工作空间</h2><p>cargo工作空间：帮助管理多个相互关联且需要协同开发的cratecargo工作空间是一套共享同一个cargo.lock和输出文件夹的包</p><p>例子： 1个二进制crate，2个库crate</p><p>在项目最外边创建Cargo.toml文件并设置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">[workspace]<br><br>members = [<br>    &quot;adder&quot;<br>    &quot;add-one&quot;<br>]<br></code></pre></td></tr></table></figure><p>adder是一个二进制crate，add-one是l库crate</p><p>指定运行二进制crate： cargo run -p adder</p><p>要写依赖项，在对应的crate的Cargo.toml的dependencies属性：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[dependencies]<br>add-one = &#123;path = &quot;../add-one&quot;&#125;<br></code></pre></td></tr></table></figure><p>整个工作空间只有一个Cargo.toml：保证不会出错</p><p>指定执行某个文件测试： cargo test -p add-one</p><h1 id="关键字">关键字</h1><h2 id="let">let</h2><p>定义变量</p><h2 id="mut">mut</h2><p>声明变量为可变的，rust中的变量默认都是不可变的</p><h2 id="const">const</h2><p>声明常量，常量与变量有很多区别： 1、不可以使用mut，常量永远是不可变的2、声明常量使用const，而且类型必须被标注3、常量可以在任何作用域内声明，包括全局作用域4、常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值</p><p>命名规范：Rust中常量使用全大写字母，每个单词之间用下划线分开，例如：MAX_POINTS</p><p>例子： const MAX_POINTS: u32 = 100_000;</p><h2 id="fn">fn</h2><p>声明函数</p><p>rust中，针对函数和变量名，rust使用snakecase命名规范，即所有的字母都是小写的，单词之间使用下划线分开</p><p>在rust中，不需要先声明函数才能进行调用，只要文件中有对该函数的定义，就能进行调用</p><p>在rust中，函数签名中必须声明每个形参的类型</p><p>函数的语句和表达式示例代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br>        x + <span class="hljs-number">3</span><span class="hljs-comment">//这里不加分号，表示这里是一个表达式，能将值赋值给y，如果加分号，表示这是一个语句，那程序就会报错</span><br>    &#125;;<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的返回值：1、在-&gt;符号后边声明函数返回的类型，但是不可以为返回值命名2、在rust中，返回值就是函数体里面最后一个表达式的值3、若想提前返回，需使用return关键字，并指定一个值（大多数函数都是默认使用最后一个表达式为返回值）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_five</span>(x:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&#123;<br>    x + <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">plus_five</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>,x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="match">match</h2><p>相当于c++中的switch，分支，对应不同情况（不同枚举）有不同的执行语句</p><p>match匹配必须穷举所有的可能</p><p>常规代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">UsState</span>&#123;<br>    Alabama,<br>    Alaska,<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coin</span>&#123;<br>    Penny,<br>    Nickel,<br>    Dime,<br>    <span class="hljs-title function_ invoke__">Quarter</span>(UsState),<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">value_in_cents</span>(coin: Coin) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span>&#123;<br>    <span class="hljs-keyword">match</span> coin&#123;<br>        Coin::Penny =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Penny&quot;</span>);<br>            <span class="hljs-number">1</span><br>        &#125;<br>        Coin::Nickel =&gt; <span class="hljs-number">5</span>,<br>        Coin::Dime =&gt; <span class="hljs-number">10</span>,<br>        <span class="hljs-comment">//这里的state是临时创建的，可以表示传入的UsState的值</span><br>        Coin::<span class="hljs-title function_ invoke__">Quarter</span>(state) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;State quater from &#123;:?&#125;!&quot;</span>,state);<br>            <span class="hljs-number">25</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Coin::<span class="hljs-title function_ invoke__">Quarter</span>(UsState::Alaska);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-title function_ invoke__">value_in_cents</span>(c));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//要相同类型才能比较哦</span><br>    <span class="hljs-keyword">match</span> a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b)&#123;<br>        <span class="hljs-comment">//判断是从上往下判断的</span><br>        <span class="hljs-comment">//注意是逗号不是分号</span><br>        Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a小于b&quot;</span>),<br>        Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a大于b&quot;</span>),<br>        Ordering::Equal =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a等于b&quot;</span>),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通配符_：替代其余没列出的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>:<span class="hljs-type">u8</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//这里的v传入后后面不能使用了，除非这里传入引用，即&amp;v</span><br>    <span class="hljs-keyword">match</span> v&#123;<br>        <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;One&quot;</span>),<br>        <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Two&quot;</span>),<br>        _ =&gt; (),<span class="hljs-comment">//要放在最后面</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">maybe_icecream</span>(time_of_day: <span class="hljs-type">u16</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u16</span>&gt; &#123;<br>    <span class="hljs-keyword">match</span> time_of_day &#123;<br>        <span class="hljs-number">0</span>..=<span class="hljs-number">21</span> =&gt; <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>),<br>        <span class="hljs-number">22</span>..=<span class="hljs-number">23</span> =&gt; <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0</span>),<br>        _ =&gt; <span class="hljs-literal">None</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理错误示例代码：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br> std::io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;无法读取行&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>:<span class="hljs-type">i32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>()&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>    &#125;<br>    <span class="hljs-comment">//_表示不在乎括号里面的内容</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="if-let">if let</h2><p>相当于只匹配一种模式的match，代码更少但是放弃了穷举的可能</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">0u8</span>);<br>    <span class="hljs-keyword">match</span> v &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Three&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Others&quot;</span>),<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-number">3</span>) = v&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Three&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Others&quot;</span>);<br>    &#125;<span class="hljs-comment">//后面这段else可加可不加，意义不大</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">option_value</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 使用 if let 检查 option_value 是否为 Some，并将其解构为内部的值</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(value) = option_value &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Option value is Some: &#123;&#125;&quot;</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Option value is None.&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="while-let">while let</h2><p>whilelet循环会反复执行一个块，直到模式匹配失败，当模式匹配成功时，循环会进入块内部执行相关代码；当模式匹配失败时，循环会结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stack</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = stack.<span class="hljs-title function_ invoke__">top</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Popped item: &#123;&#125;&quot;</span>, item);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Stack is empty!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，Some(item) =stack.top()，他会尝试从stack中弹出一个元素，并将其绑定到item。只要pop方法返回Some枚举的值，就会执行循环体内的代码。一旦pop方法返回None，循环就会终止</p><h2 id="loop">loop</h2><p>相当于c++中的循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">loop</span>&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">//要相同类型才能比较哦</span><br>        <span class="hljs-keyword">match</span> a.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b)&#123;<br>            <span class="hljs-comment">//判断是从上往下判断的</span><br>            <span class="hljs-comment">//注意是逗号不是分号</span><br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a小于b&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a大于b&quot;</span>),<br>            Ordering::Equal =&gt;&#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a等于b&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span>&#123;<br>        counter += <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span>&#123;<br>            <span class="hljs-keyword">break</span> counter*<span class="hljs-number">2</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is: &#123;&#125;&quot;</span>,result);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if">if</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-number">3</span>;<br>     <br>    <span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">5</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was true&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was false&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-keyword">if</span> condition &#123;<span class="hljs-number">5</span>&#125; <span class="hljs-keyword">else</span>&#123;<span class="hljs-number">6</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="while">while</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">number</span> = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">while</span> number != <span class="hljs-number">3</span>&#123;<br>        number -= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for">for</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is: &#123;&#125;&quot;</span>,element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">number</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">4</span>).<span class="hljs-title function_ invoke__">rev</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>,number);<br>    &#125;<br>    <span class="hljs-comment">/*结果：</span><br><span class="hljs-comment">    3!</span><br><span class="hljs-comment">    2!</span><br><span class="hljs-comment">    1!</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="struct">struct</h2><h3 id="定义">定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>&#123;<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>    active: <span class="hljs-type">bool</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例化">实例化</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//一旦实例是可变的，那所有字段都是可变的</span><br>   <span class="hljs-comment">//可以不按顺序实例化</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> = User&#123;<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1037827@qq.com&quot;</span>),<br>        usename: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Mike&quot;</span>),<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">588</span>,<span class="hljs-comment">//不能缺少一个数据不赋值</span><br>    &#125;;<br>    <br>    <span class="hljs-comment">//使用点标记法取值</span><br>    user1.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;103@qq.com&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>简写实例化结构：（形参名与字段名相同）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User&#123;<br>    User&#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">0</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新语法">更新语法</h3><p>当你想基于某个struct实例来创建一个新实例的时候，可以使用struct更新语法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User&#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;103&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bob&quot;</span>),<br>    active: user1.active,<br>    sign_in_count: user1.sign_in_count,<br>&#125;<br><br><span class="hljs-comment">//更新语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User&#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;103&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Bob&quot;</span>),<br>    ..user1<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tuple-struct">Tuple Struct</h3><p>Tuple Struct整体有名字，但里面的元素没有名字。适用：想给整个tuple起名字，并让它不同于其他tuple，而且不需要给里面的每个元素起名字。访问可以用：模式匹配或点标记法</p><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>black.<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="unit-like-struct">Unit-Like Struct</h3><p>1、可以定义没有任何字段的struct，叫做Unit-Like Struct2、适用于需要在某个类型上实现某个trait，但是在里面又没有想要存储的数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UnitLikeStruct</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">unit_like_struct</span> = UnitLikeStruct;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="struct数据所有权">struct数据所有权</h3><p>上面的User使用了String而不是&amp;str： 该struct实例拥有其所有的数据只要struct实例是有效的，那么里面的字段数据也是有效的struct里面也可以存放引用，但是需要使用生命周期，生命周期保证只要struct实例是有效的，那么里面的引用也是有效的</p><h3 id="调试打印结构体">调试打印结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect</span> = Rectangle&#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-title function_ invoke__">area</span>(&amp;rect));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,rect);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(rect: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>    rect.width * rect.length <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法">方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-comment">//使用关键字impl实现方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-comment">//方法的第一个参数总是self，在调用时可以不写</span><br><span class="hljs-comment">//一般借用自己的实例化，而不是获得数据所有权，但不是强制的</span><br>    <span class="hljs-comment">//也可以是可变引用</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect</span> = Rectangle&#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,rect.<span class="hljs-title function_ invoke__">area</span>());<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法调用的运算符：在c++中，调用指针对象的方法为object-&gt;或者(<em>object).但在rust中会自动引用或解引用，即在调用方法时，rust根据情况自动添加&amp;、&amp;mut或</em>例子： p1.distance(&amp;p2) 等价于 (*p1).distance(&amp;p2)</p><p>关联函数：可以在impl块里定义不把self作为第一个参数的函数，它们叫关联函数（不是方法）例如：String::from()</p><p>关联函数通常用于构造器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span>&#123;<br>    width: <span class="hljs-type">u32</span>,<br>    length: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>&#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.length &gt; other.length<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">square</span>(size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> Rectangle&#123;<br>        Rectangle&#123;<br>            width: size,<br>            length: size,<br>        &#125;   <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect</span> = Rectangle&#123;<br>        width: <span class="hljs-number">30</span>,<br>        length: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Rectangle::<span class="hljs-title function_ invoke__">square</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,rect.<span class="hljs-title function_ invoke__">area</span>());<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,rect);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个struct可以有多个impl块</p><h1 id="输入输出">输入输出</h1><h2 id="输出">输出</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输入">输入</h2><h3 id="字符串输入">字符串输入</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    ios::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;无法读取行&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="依赖项">依赖项</h1><h2 id="rand">rand</h2><p>现在toml文件中依赖项区域加入rand = "版本号"</p><p>生成1~100的随机数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand::rng;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = rand::<span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">gen_range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据类型">数据类型</h1><h2 id="shadowing隐藏">Shadowing（隐藏）</h2><p>可以使用相同名字声明新的变量，新的变量就会shadow之前生民的同名变量</p><p>新变量的数据类型可以与旧变量的数据类型不同</p><h2 id="复合类型">复合类型</h2><p>rust提供两种基础的复合类型：元组(tuple)和数组</p><p>tuple可以将多个类型的多个值放在一个类型里，长度是固定的，一旦声明就无法修改。获取Tuple的元素值：1、可以使用模式匹配来解构（destructure）一个Tuple来获取元素的值2、点标记法，后接元素的引号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>:(<span class="hljs-type">i32</span>,<span class="hljs-type">f64</span>,<span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>,<span class="hljs-number">6.4</span>,<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">//使用模式匹配获取Tuple中的元素的值</span><br>    <span class="hljs-keyword">let</span> (x,y,z) = tup;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,x,y,z);<br>    <br>    <span class="hljs-comment">//使用点标记法</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,tup.<span class="hljs-number">0</span>,tup.<span class="hljs-number">1</span>,tup.<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>数组也可以将多个值放在一个类型里，但是数组中每个元素的类型必须是相同的，长度也是固定的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>:[<span class="hljs-type">i32</span>,<span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = [<span class="hljs-number">3</span>;<span class="hljs-number">5</span>];<span class="hljs-comment">// let b = [3,3,3,3,3];</span><br>    <br>    <span class="hljs-comment">//访问数组元素</span><br>    a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串转化成整数">字符串转化成整数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span>  <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;无法读取行&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">i32</span> = guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">except</span>(<span class="hljs-string">&quot;不是整数&quot;</span>);<br>    <span class="hljs-comment">//let guess: u32 = 也是可以的</span><br>    <span class="hljs-comment">//注意只有单冒号，这种方式是声明变量为哪种类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>1、trim方法是去除"" 2、parse方法是将字符串转化为整型3、rust中允许同名新变量隐藏旧变量</p><h1 id="所有权">所有权</h1><h2 id="简介-2">简介</h2><p>Rust的核心特性就是所有权</p><p>所有程序在运行时都必须管理它们使用计算机内存的方式1、有些语言有垃圾收集机制，在程序运行时，它们会不断寻找不再使用的内存2、在其他语言中，程序员必须显式地分配和释放内存</p><p>Rust采用了第三种方式：1、内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则2、当程序运行时，所有权特性不会减慢程序的运行速度</p><h2 id="stack-vs-heap">Stack vs Heap</h2><p>Stack按值的接收顺序来存储，按相反的顺序将它们移除所有存储在Stack上的数据必须拥有已知的固定大小，编译时大小未知的数据或运行时大小可能发生变化的数据必须放在heap上</p><p>Heap内存组织性差一些： 1、当你把数据放入Heap时，会请求一定数量的空间2、操作系统在heap里找到一块足够大的空间，把它标记为在用，并返回一个指针，是这个空间的地址3、这个过程叫做在heap上进行分配</p><p>访问heap中的数据要比访问stack中的数据慢，因为需要通过指针才能找到heap中数据</p><p>当你的代码调用函数时，值被传入到函数。函数本地的变量被压到stack上。当函数结束后，这些值会从stack上弹出</p><h2 id="所有权存在的原因">所有权存在的原因</h2><p>所有权解决的问题： 1、跟踪代码的哪些部分正在使用heap的哪些数据2、最小化heap上的重复数据量 3、清理heap上未使用的数据以避免空间不足</p><h2 id="所有权规则">所有权规则</h2><p>1、每个值都有一个变量，这个变量是该值的所有者2、每个值同时只能有一个所有者3、当所有者超出作用域(scope)时，该值将被删除</p><h2 id="内存和分配">内存和分配</h2><p>对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动地交换给操作系统</p><p>调用drop函数</p><h2 id="移动">移动</h2><p>存放在stack中数据进行移动时无碍，但是如果时复合类型进行移动，两个变量的数据指向的是同一块heap上的内容，当离开作用域时，会释放两次内存，rust的解决方案是尝试让第一个变量失效，即当第一个变量离开作用域时不会释放内存（此时已经不能使用第一个变量了，因为它已经失效了）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<span class="hljs-comment">//已经不能使用s1了</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="克隆">克隆</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<span class="hljs-comment">//在heap上复制了一份内容</span><br>    <span class="hljs-comment">//这样s1还能继续使用</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><p>把一个值赋给其他变量变量就会发生移动，形参传入实参，那实参就会发生移动如果是stack上的数据，那么发生拷贝如果是heap上的数据，那么发生移动，它的值就会被drop清理</p><p>如何让函数使用某个值，但不获得其所有权？就是把传入的实参作为返回值返回即可转移所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> (s2,len) = <span class="hljs-title function_ invoke__">calculate_length</span>(s1);<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#123;&#125; is &#123;&#125;&quot;</span>,s2,len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>,<span class="hljs-type">usize</span>)&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br>    (s,length)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用">引用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#123;&#125; is &#123;&#125;&quot;</span>,s1,len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span>&#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>借用： 1、我们把引用作为函数参数的这个行为叫做借用2、不可以修改借用的东西 3、因为和变量一样，引用默认也是不可变的</p><p>加入mut使其引用可变(&amp;mut)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;<span class="hljs-keyword">mut</span> s1);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span>&#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;,world!&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<span class="hljs-comment">//这样就会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>好处：可在编译时防止数据竞争</p><p>三种引发数据竞争的行为： 1、两个或多个指针同时访问同一个数据2、至少有一个指针用于写入数据 3、没有使用任何机制来同步对数据的访问</p><p>解决方案：可以通过创建新的作用域，来允许非同时地创建多个可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一个限制： 1、不可以同时拥有一个可变引用和一个不可变的引用2、多个不可变的引用是允许的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s;<span class="hljs-comment">//没有错</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s;<span class="hljs-comment">//没有错</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = &amp;<span class="hljs-keyword">mut</span> s;<span class="hljs-comment">//报错，因为已经有不可变的引用了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>悬空引用（Dangling References）：1、一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了2、在Rust中，编译器可保证引用永远都不是悬空引用，如果你引用了某些数据，编译器能保证在引用离开作用域之前数据不会离开作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &amp;s<span class="hljs-comment">//报错</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="切片">切片</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<br><span class="hljs-comment">//但是这里的wordIndex无法与s保持同步性</span><br>    <span class="hljs-comment">//例如s.clear()后,wordIndex已经无效了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,wordIndex);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上面代码的缺陷，rust提供了一种解决方案：字符串切片字符串切片是指向字符串中一部分内容的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<span class="hljs-comment">//[..5]  语法糖</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];<span class="hljs-comment">//[6..]  语法糖</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">whole</span> = &amp;s[<span class="hljs-number">0</span>,s.<span class="hljs-title function_ invoke__">len</span>()];<span class="hljs-comment">//[..]  语法糖</span><br>&#125;<br></code></pre></td></tr></table></figure><p>形式：[开始索引..结束索引] 开始索引：切片起始位置的索引值结束索引：切片终止位置的下一个索引值</p><p>解决最开始的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<span class="hljs-comment">//wordIndex为不可变引用</span><br><br>    <span class="hljs-comment">//此时已经不能用s.clear()，因为s已经是不可变的了</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,wordIndex);<br>&#125;<br><br><span class="hljs-comment">//注意这里的返回是字符串切片&amp;str</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<span class="hljs-comment">//因为这里返回不可变引用了！！！！！！！！</span><br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串字面值是切片，字符串字面值被直接存储在二进制程序中</p><p>将字符串切片作为参数传递，即： fn first_word(s: &amp;str) -&gt;&amp;str {} 1、使用字符串切片，直接调用该函数2、使用String，可以创建一个完整的String切片来调用该函数</p><p>因为这样就可以同时接收String和&amp;str类型的参数了，定义函数时使用字符串切片来代替字符串引用会是我们的API更加通用，而且不会损失任何功能</p><p>示例代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;my_string[..]);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">my_string_literal</span> = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">wordIndex</span> = <span class="hljs-title function_ invoke__">first_word</span>(my_string_literal);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bytes</span> = s.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>    <span class="hljs-keyword">for</span> (i,&amp;item) <span class="hljs-keyword">in</span> bytes.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b&#x27; &#x27;</span> &#123;<br>            <span class="hljs-keyword">return</span> &amp;s[..i];<br>        &#125;<br>    &#125;<br>    &amp;s[..]<br>&#125;<br></code></pre></td></tr></table></figure><p>其他类型的切片：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="标准类">标准类</h1><h2 id="字符串">字符串</h2><p>Rust中字符串使用UTF-8编码</p><p>Rust的核心语言层面，只有一个字符串类型：字符串切片str（&amp;str）</p><p>字符串切片：对存储在其他地方、UTF-8编码的字符串的引用字符串字面值：存储在二进制文件中，也是字符串切片</p><h3 id="string类">String类</h3><p>UTF-8编码</p><h4 id="创建">创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//无初始值创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s0</span> <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <br>    <span class="hljs-comment">//有初始值创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, World&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="str转换成string">&amp;str转换成String</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = <span class="hljs-string">&quot;Hello, world&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = data.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-string">&quot;Hello, world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = data.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = data.<span class="hljs-title function_ invoke__">into</span>();<br>    <span class="hljs-comment">//这三个方法基本是等效的，返回String</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="更新">更新</h4><p>push_str()：把一个字符串切片附加到String</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>    <span class="hljs-comment">//传入引用，即可以继续使用，下面的s1传入后还能继续使用</span><br>    <span class="hljs-comment">//let mut s1 = String::from(&quot;bar&quot;);</span><br>    <span class="hljs-comment">//s.push_str(&amp;s1);</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure><p>push()方法：把单个字符附加到String</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;lo&quot;</span>);<br>    s.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;l&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>+：连接字符串 使用了类似这个签名的方法：fn add(self, &amp;str) -&gt;String{...} 解引用强制转化，把字符串引用转化成字符串切片</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello &quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;World&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = s1 + &amp;s2;<span class="hljs-comment">//这里取得s1的所有权给s3</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s3);<br>    <span class="hljs-comment">//println!(&quot;&#123;&#125;&quot;,s1);   s1已经不能使用了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s2);<span class="hljs-comment">//s2还可以使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>format!：连接多个字符串(更灵活)不会取得任何参数的所有权，这些参数后续都可以继续使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;tic&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;tac&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;toe&quot;</span>);<br>    <br>    <span class="hljs-comment">//let s3 = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;</span><br>    <span class="hljs-comment">//println!(&quot;&#123;&#125;&quot;,s3);</span><br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>,s1,s2,s3);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回字符串长度">返回字符串长度</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s.<span class="hljs-title function_ invoke__">len</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s2.<span class="hljs-title function_ invoke__">len</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="访问">访问</h4><p>String类不能按索引的形式进行访问 String是对Vec<u8>的包装</p><p>Rust有三种看待字符串的方式：字节、标量值、字形簇（最接近所谓的字母）</p><p>Rust不允许String进行索引的最后一个原因：索引操作应消耗一个常量时间O(1)，而String无法保证，需要遍历所有内容来确定有多少个合法的字符</p><h4 id="切割string">切割String</h4><p>可以使用[]和一个范围来创建字符串的切片</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = &amp;hello[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>];<span class="hljs-comment">//必须沿边界切割，因为有些文字一个字占了两个字节</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历">遍历</h4><p>对于标量值：chars()方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,b);<br>    &#125;<br>    <span class="hljs-comment">//输出h e l l o</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于字节：bytes()方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">bytes</span>()&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于字形簇：很复杂，标准库未提供</p><h4 id="注意">注意</h4><p>Rust选择将正确处理String数据作为所有Rust程序的默认行为：程序员必须在处理UTF-8数据之前投入更多的精力</p><p>但却可以防止在开发后期处理涉及非ASCII字符的错误</p><h4 id="代替">代替</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;I think cars are cool&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = input.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">&quot;cars&quot;</span>. <span class="hljs-string">&quot;balloons&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="转化为小写字母">转化为小写字母</h4><p>to_lowercase() trait</p><p>返回值是String类型</p><h4 id="转化为大写字母">转化为大写字母</h4><p>to_uppercase() trait</p><h3 id="str字符串切片">&amp;str（字符串切片）</h3><h4 id="去除空格">去除空格</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-string">&quot;   Hello!   &quot;</span>;<br>    <span class="hljs-comment">//去除头尾的空格</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string0</span> = input.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-comment">//去除头部的空格</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = input.<span class="hljs-title function_ invoke__">trim_start</span>().<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-comment">//去除尾部的空格</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = input.<span class="hljs-title function_ invoke__">trim_end</span>().<span class="hljs-title function_ invoke__">to_string</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="连接">连接</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input1</span> = <span class="hljs-string">&quot;world&quot;</span>;<br>    <span class="hljs-comment">//返回String类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,input,input1);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代替-1">代替</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = <span class="hljs-string">&quot;I think cars are cool&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = input.<span class="hljs-title function_ invoke__">replace</span>(<span class="hljs-string">&quot;cars&quot;</span>. <span class="hljs-string">&quot;balloons&quot;</span>).<span class="hljs-title function_ invoke__">to_string</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="转化为小写字母-1">转化为小写字母</h4><p>to_lowercase() trait</p><p>返回值是String类型</p><h2 id="vector">Vector</h2><p>Vec<T> 可存储相同类型的值，在堆上连续存放</p><h3 id="创建-1">创建</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//常规创建</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-comment">//使用宏创建，用初始值作为容器的数据类型 </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加">添加</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//编译器可以识别到就可以不用Vec&lt;T&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取元素">读取元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>   <span class="hljs-comment">//使用索引  超出索引范围会报错</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">third1</span>: &amp;<span class="hljs-type">i32</span> = &amp;v[<span class="hljs-number">2</span>]<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;&#125;&quot;</span>,third);<br>    <br>    <span class="hljs-comment">//使用get方法  超出索引范围不会报错</span><br>    <span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(thied2) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;&#125;&quot;</span>,third);<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no third element&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="所有权和借用规则">所有权和借用规则</h3><p>不能再同一作用域内同时拥有可变和不可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    ler first = &amp;v[<span class="hljs-number">0</span>];<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span><span class="hljs-comment">//这一行代码报错，不能同时拥有可变和不可变引用</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历元素">遍历元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v&#123;<br>        *item += <span class="hljs-number">50</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;v&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,item);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存放不同数据类型">存放不同数据类型</h3><p>1、使用enum，因为enum的变体可以附加不同类型的数据，而enum变体定义在同一个enum类型下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SpreadSheetCell</span> &#123;  <br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">row</span>: <span class="hljs-type">Vec</span>&lt;SpreadSheetCell&gt; = <span class="hljs-built_in">vec!</span>[<br>        SpreadSheetCell::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">3</span>),<br>        SpreadSheetCell::<span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;blue&quot;</span>)),<br>        SpreadSheetCell::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">10.12</span>),<br>    ];<br>&#125;<br></code></pre></td></tr></table></figure><p>2、使用Box<dyn Any></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::any::Any;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Any&gt;&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">42</span>));<br>    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3.14</span>));<br>    vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello, Rust!&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> vec &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(i) = item.downcast_ref::&lt;<span class="hljs-type">i32</span>&gt;() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Integer: &#123;&#125;&quot;</span>, i);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(f) = item.downcast_ref::&lt;<span class="hljs-type">f64</span>&gt;() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Float: &#123;&#125;&quot;</span>, f);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(s) = item.downcast_ref::&lt;<span class="hljs-type">String</span>&gt;() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Text: &#123;&#125;&quot;</span>, s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法-1">方法</h3><h4 id="from_slice">from_slice</h4><p>函数定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_slice</span>(slice: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span><br></code></pre></td></tr></table></figure><p>接受一个切片，返回一个包含切片元素副本的新集合示例，这在需要从切片中构建集合时非常有用，因为它允许你在不修改原始数据的情况下创建一个新的集合</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">from_slice</span>(slice);<br></code></pre></td></tr></table></figure><h4 id="extend_from_slice">extend_from_slice</h4><p>定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">extend_from_slice</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: &amp;[T])<br></code></pre></td></tr></table></figure><p>接受一个切片，将切片中的元素追加到集合的末尾</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>vec.<span class="hljs-title function_ invoke__">extend_from_slice</span>(slice);<br></code></pre></td></tr></table></figure><h4 id="copy_from_slice">copy_from_slice</h4><p>定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">copy_from_slice</span>(src: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span><br></code></pre></td></tr></table></figure><p>接受一个切片作为参数，并将切片中的内容复制到调用者所代表的可变位置</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">array</span> = [<span class="hljs-number">0</span>;<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">src</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">copy_count</span> = array.<span class="hljs-title function_ invoke__">copy_from_slice</span>(&amp;src);<br></code></pre></td></tr></table></figure><h2 id="hashmap">HashMap</h2><h3 id="创建-2">创建</h3><p>创建空的HashMap：new()函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span>: HashMap&lt;<span class="hljs-type">String</span>,<span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用collect方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">teams</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>)];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">initial_scores</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>,<span class="hljs-number">50</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">scores</span>: HashMap&lt;_,_&gt; = <br>    teams.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">zip</span>(initial_scores.<span class="hljs-title function_ invoke__">iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加-1">添加</h3><p>insert()方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>),<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="所有权-1">所有权</h3><p>1、对于实现了Copy trait的类型（例如i32），值会被复制到HashMap中2、对于拥有所有权的值（例如String），值会被移动，所有权会转移给HashMap3、如果将值的引用插入到HashMap，值本身不会移动</p><h3 id="访问-1">访问</h3><p>get方法（返回Option&lt;&amp;T&gt;）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>),<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">team_name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">score</span> = scores.<span class="hljs-title function_ invoke__">get</span>(&amp;team_name);<br>    <span class="hljs-keyword">match</span> score&#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(s) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;team not exist&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历-1">遍历</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    scores,<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>),<span class="hljs-number">50</span>);<br>    <br>    <span class="hljs-keyword">for</span> (k,v) <span class="hljs-keyword">in</span> &amp;scores&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,k,v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更新-1">更新</h3><p>1、HashMap大小可变 2、每个k对应一个v 3、更新数据k已经存在，对应一个v： 替换现有的v 保留现有的v，忽略新的v合并现存的v和新的v k不存在： 添加一对k，v</p><p>entry方法：检查指定的k是否对应一个v 参数为k，返回enumEntry：代表值是否存在 or_insert方法： 如果k存在，返回到对应的v的一个可变引用如果k不存在，将方法参数作为k的新值插入进去，返回到这个值的可变引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>),<span class="hljs-number">10</span>);<br>    <br>    scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>)).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-comment">//let e = scores.entry(String::from(&quot;Yellow&quot;));</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,e);</span><br>    <span class="hljs-comment">//e.or_insert(50);</span><br>    scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>)).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,scores);<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串单词计数器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = <span class="hljs-string">&quot;hello wolrd wonderful world&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">split_whitespace</span>()&#123;<br>        <span class="hljs-comment">//返回value值的可变引用</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = map.<span class="hljs-title function_ invoke__">entry</span>(word).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>        *count += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#?&#125;&quot;</span>,map);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hash函数">Hash函数</h3><p>默认情况下，HashMap使用加密功能强大的Hash函数，可以抵抗拒绝服务（DOS）攻击不是可用的最快的Hash算法，但具有更好的安全性</p><p>可以指定不同的Hasher来切换到另一个函数 hasher是实现BuildHashertrait的类型</p><h3 id="计算长度">计算长度</h3><p>len() trait</p><h3 id="计算value的和">计算value的和</h3><p>values().sum::<T>()</p><h1 id="枚举">枚举</h1><h2 id="定义枚举">定义枚举</h2><p>IP地址：IPv4,IPv6</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//算是一种自定义类型</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span>&#123;<br>    V4,<br>    V6,<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IpAddr</span>&#123;<br>    kind: IpAddrKind,<br>    address: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">four</span> = IpAddrKind::V4;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six</span> = IpAddrKind::V6;<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddr&#123;<br>        kind: IpAddrKind::V4,<br>        address: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将数据附加到枚举的变体中">将数据附加到枚举的变体中</h2><p>优点： 不需要使用额外的struct每个变体可以拥有不同的类型以及关联的数据量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span>&#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>,<span class="hljs-type">u8</span>,<span class="hljs-type">u8</span>,<span class="hljs-type">u8</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>),<br>    Move &#123;x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-number">127</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">loopback</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;::1&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//标准库中的IpAddr</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ipv4Addr</span>&#123;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ipv6Addr</span>&#123;<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span>&#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(Ipv4Addr),<br>    <span class="hljs-title function_ invoke__">V6</span>(Ipv6Addr),<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&#123;<br>    Quit,<span class="hljs-comment">//无关联数据</span><br>    Move &#123;x: <span class="hljs-type">i32</span>,y: <span class="hljs-type">i32</span>&#125;,<span class="hljs-comment">//关联一个匿名结构体</span><br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = Message::Quit;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Message::Move&#123;x:<span class="hljs-number">12</span>,y:<span class="hljs-number">24</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;H&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义方法">定义方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&#123;<br>    Quit,<span class="hljs-comment">//无关联数据</span><br>    Move &#123;x: <span class="hljs-type">i32</span>,y: <span class="hljs-type">i32</span>&#125;,<span class="hljs-comment">//关联一个匿名结构体</span><br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>,<span class="hljs-type">i32</span>);<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>)&#123;&#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = Message::Quit;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Message::Move&#123;x:<span class="hljs-number">12</span>,y:<span class="hljs-number">24</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;H&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>);<br>    <br>    m.<span class="hljs-title function_ invoke__">call</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打印枚举">打印枚举</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span>&#123;<br>    Quit,<br>    <span class="hljs-title function_ invoke__">Echo</span> (<span class="hljs-type">String</span>),<br>    Move &#123;x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>&#125;,<br>    <span class="hljs-title function_ invoke__">ChangeColor</span> (<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,<span class="hljs-keyword">self</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::Quit);</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::Echo);</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::Move);</span><br>    <span class="hljs-comment">//println!(&quot;&#123;:?&#125;&quot;,Message::ChangeColor);</span><br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">messages</span>: [Message;<span class="hljs-number">4</span>] = [<br>        Message::Move &#123;x:<span class="hljs-number">10</span>, y:<span class="hljs-number">30</span>&#125;,<br>        Message::<span class="hljs-title function_ invoke__">Echo</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>)),<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">200</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>),<br>        Message::Quit,<br>    ] <br>    <span class="hljs-keyword">for</span>  <span class="hljs-title class_">message</span>: &amp;Message <span class="hljs-keyword">in</span> &amp;messages&#123;<br>        message.<span class="hljs-title function_ invoke__">call</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="option枚举">Option枚举</h2><p>定义于标准库中，描述了某个值可能存在或不存在的情况在预导入模块中，可直接使用</p><p>在rust中，没有null，但是有类似null概念的枚举也就是option</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt;&#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><span class="hljs-comment">//可直接使用</span><br><span class="hljs-comment">//Option&lt;T&gt;</span><br><span class="hljs-comment">//Some(T)</span><br><span class="hljs-comment">//None</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_number</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;A String&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">absent_number</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br>    <span class="hljs-comment">//在定义None时，编译器无法确定变量类型，需要显式声明</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用Option<T>比null的好处：Option<T>和T是不同的类型，如果要使用，必须将Option<T>转换成T</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six</span> = <span class="hljs-title function_ invoke__">plus_one</span>(five);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">none</span> = <span class="hljs-title function_ invoke__">plus_one</span>(none);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_one</span>(x: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;&#123;<br>    <span class="hljs-keyword">match</span> x&#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(i) =&gt; <span class="hljs-title function_ invoke__">Some</span>(i+<span class="hljs-number">1</span>),<br>        <span class="hljs-comment">//这里的i是临时创建的，可以表示Some中的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="错误处理">错误处理</h1><h2 id="概述">概述</h2><p>Rust的可靠性：大部分情况下，编译时提示错误并处理</p><p>错误的分类： 可恢复：例如文件未找到，可再次尝试不可恢复：bug，例如访问的索引超出范围</p><p>Rust没有类似异常的机制： 可恢复错误：Result&lt;T,E&gt;不可恢复错误：panic! 宏</p><h2 id="不可恢复错误">不可恢复错误</h2><p>当panic!宏执行： 1、程序会打印一个错误信息2、展开（unwind）、清理调用栈（stack） 3、退出程序</p><p>为应对panic，展开或中止(abort)调用栈 默认情况下，当panic发生：1、程序展开调用栈（工作量大）：Rust沿着调用栈往回走，清理每个遇到的函数中的数据2、或立即中止调用栈：不进行清理，直接停止程序，内存需要OS进行清理</p><p>想让二进制文件更小，把设置从“展开”改为“中止”：在Cargo.toml中的profile部分设置，panic = 'abort' 例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[profile.release]<br>panic = &#x27;abort&#x27;<br></code></pre></td></tr></table></figure><p>panic!可能出现在：我们写的代码中或我们所依赖的代码中可通过调用panic!的函数的回溯信息来定位引起问题的代码。通过设置环境变量RUST_BACKTRACE可得到回溯信息</p><h2 id="可恢复的错误">可恢复的错误</h2><h3 id="result枚举">Result枚举</h3><p>enum Result&lt;T, E&gt; { Ok(T), Err(E), }T：操作成功情况下，Ok变体里返回的数据的类型E：操作失败情况下，Err变体里返回的错误的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>()&#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)&#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>                <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error creating file: &#123;:?&#125;&quot;</span>, error),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error opening the file: &#123;:?&#125;&quot;</span>,other_error),<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用unwrap_or_else方法改良： 如果是Ok返回里面的变体如果是Err调用后面的匿名函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error|&#123;<br>        <span class="hljs-keyword">if</span> error.<span class="hljs-title function_ invoke__">kind</span>() == ErrorKind::NotFound&#123;<br>            File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|error|&#123;<br>                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="unwrap">unwrap</h3><p>match表达式的一个快捷方法： 如果Result结果是Ok，返回Ok里面的值如果Result结果是Err，调用panic!宏</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">/*let f = File::open(&quot;hello.txt&quot;);</span><br><span class="hljs-comment">    let f = match f&#123;</span><br><span class="hljs-comment">        Ok(file) =&gt; file,</span><br><span class="hljs-comment">        Err(error) =&gt; &#123;</span><br><span class="hljs-comment">            panic!(&quot;Error opening file &#123;:?&#125;&quot;, error)</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;;*/</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="expect">expect</h3><p>和unwrap类似，但可指定错误信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-comment">/*let f = File::open(&quot;hello.txt&quot;);</span><br><span class="hljs-comment">    let f = match f&#123;</span><br><span class="hljs-comment">        Ok(file) =&gt; file,</span><br><span class="hljs-comment">        Err(error) =&gt; &#123;</span><br><span class="hljs-comment">            panic!(&quot;Error opening file &#123;:?&#125;&quot;, error)</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;;*/</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;无法打开文件hello.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传播错误">传播错误</h3><p>将错误返回给调用者</p><p>常规方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>,Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt;&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(error),<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)&#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-title function_ invoke__">Err</span>(error),<br>    &#125;<br>&#125;<br><span class="hljs-comment">//传播错误的Result枚举也可以是Result&lt;String, String&gt;</span><br><span class="hljs-comment">//或其他的</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">read_username_from_file</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>?运算符：传播错误的一种快捷方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>,Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>()<span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>,io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果Result是Ok：Ok中的值就是表达式的结果，然后继续执行程序如果Result是Err：Err就是整个函数的返回值，就像使用了return</p><p>?与from函数 Trait std::convert::From 上的from函数，用于错误之间的转换被?所应用的错误,会隐式的被from函数处理，即它所接收的错误类型会被转化为当前函数返回类型所定义的错误类型</p><p>使用链式继续优化：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>,Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>,io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>?运算符只能用于返回Result的函数main函数的默认返回类型是()，可以修改成返回Result类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br><span class="hljs-comment">//Box&lt;dyn Error&gt;是trait对象，简单理解：任何可能的错误类型，这里如果是其他错误则写其他错误</span><br><span class="hljs-comment">//Box括号中的两个类型没有逗号</span><br></code></pre></td></tr></table></figure><h2 id="使用panic的时机">使用panic!的时机</h2><p>总体原则：在定义一个可能失败的函数时，优先考虑返回Result，否则就panic!</p><p>编写示例、原型代码、测试代码可用unwrap、expect</p><p>可以确定Result是Ok，可以使用unwrap</p><p>错误处理的指导性建议： 当代码最终可能处于损坏状态时，最好使用panic!损坏状态：某些假设、保证、约定或不可变性被打破（例如非法的值、矛盾的值或空缺的值被传入代码，以及下列中的一条：这种损坏状态并不是预期能够偶尔发生的事情；在此之后，代码如果处于这种损坏状态就无法运行；在使用的类型中没有一个好的方法来将这些信息进行编码）</p><p>场景建议： 1、调用你的代码，传入无意义的参数值：panic!2、调用外部不可控代码，返回非法状态，你无法修复：panic!3、如果失败是可预期的：Result!4、当你的代码对值进行操作，首先应该验证这些值：panic!</p><p>为验证创建自定义类型：创建新的类型，把验证逻辑放在构造示例的函数里</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guess</span>&#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> || value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be between 1 and 100, got &#123;&#125;&quot;</span>, value);<br>        &#125;<br>        Guess &#123;value&#125;;<br>    &#125; <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-keyword">self</span>.value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理代码">错误处理代码</h2><h3 id="part1">part1</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ParsePosNonzeroError</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_creation</span>(err: CreationError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;<br>        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">Creation</span>(err)<br>    &#125;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add another error conversion function here.</span><br>    <span class="hljs-comment">// fn from_parseint...</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_parseint</span>(err: ParseIntError) <span class="hljs-punctuation">-&gt;</span> ParsePosNonzeroError &#123;<br>        ParsePosNonzeroError::<span class="hljs-title function_ invoke__">ParseInt</span>(err)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">parse_pos_nonzero</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> change this to return an appropriate error instead of panicking</span><br>    <span class="hljs-comment">// when `parse()` returns an error.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i64</span> = s.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_parseint)?;<br>    PositiveNonzeroInteger::<span class="hljs-title function_ invoke__">new</span>(x).<span class="hljs-title function_ invoke__">map_err</span>(ParsePosNonzeroError::from_creation)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法-2">方法</h2><h3 id="ok_or">ok_or</h3><p>接受一个参数，该参数是一个默认的错误值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">option_value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = option_value.<span class="hljs-title function_ invoke__">ok_or</span>(<span class="hljs-string">&quot;Default Error&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="ok_or_else">ok_or_else</h3><p>接受一个闭包作为参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">option_value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = option_value.<span class="hljs-title function_ invoke__">ok_or_else</span>(|| <span class="hljs-string">&quot;Defalut Error&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br></code></pre></td></tr></table></figure><p>ok_or方法更适合提供静态的错误值，而ok_or_else方法更适合提供需要计算的错误值。</p><h1 id="泛型">泛型</h1><h2 id="提取函数">提取函数</h2><p>作用：消除重复代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largerst</span>(list: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list &#123;<br>        <span class="hljs-keyword">if</span> item &gt; largerst &#123;<br>            largest = item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for item in list &#123;</span><br><span class="hljs-comment">    if *item &gt; largerst &#123;</span><br><span class="hljs-comment">    largest = *item; </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    largest<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number_list</span> = [<span class="hljs-number">34</span>,<span class="hljs-number">50</span>,<span class="hljs-number">25</span>,<span class="hljs-number">100</span>,<span class="hljs-number">65</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">largest</span>(&amp;number_list);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简介-3">简介</h2><p>提高代码复用能力</p><p>泛型是具体类型或其他属性的抽象代替：1、编写的代码不是最终的代码，而是一种模板，里面有一些“占位符”2、编译器在编译时将“占位符”替换成具体的类型 例如：fn largest<T>(list:&amp;[T]) -&gt; T {...}</p><p>示例代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largerst</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list &#123;<br>        <span class="hljs-comment">//这里的比较大小会报错，后面再了解</span><br>        <span class="hljs-keyword">if</span> item &gt; largerst &#123;<br>            largest = item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for item in list &#123;</span><br><span class="hljs-comment">    if *item &gt; largerst &#123;</span><br><span class="hljs-comment">    largest = *item; </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    largest<br>&#125;<br></code></pre></td></tr></table></figure><p>struct定义中的泛型可以使用多个泛型的类型参数，但太多类型参数说明你的代码需要重组为多个更小的单元：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T1, T2&gt; &#123;<br>    x: T1,<br>    y: T2,<br>&#125;<br></code></pre></td></tr></table></figure><p>enum定义中的泛型，可以让枚举的变体持有泛型数据类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T,E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><p>为struct或enum实现方法的时候， 可在定义中使用泛型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><span class="hljs-comment">//针对Point泛型实现的方法</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x1</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><span class="hljs-comment">//针对Point具体类型实现的方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x2</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>struct里的泛型类型参数可以和方法的泛型类型参数不同：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><span class="hljs-comment">//实现泛型结构体</span><br><span class="hljs-keyword">impl</span>&lt;T,U&gt; Point&lt;T,U&gt; &#123;<br>    <span class="hljs-comment">//泛型犯法</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mixup</span>&lt;V,W&gt;(<span class="hljs-keyword">self</span>, other: Point&lt;V,W&gt;) <span class="hljs-punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x,<br>            y: other.y,<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>泛型代码的性能：1、使用泛型的代码和使用具体类型的代码运行速度是一样的2、单态化：在编译时将泛型替换为具体类型的过程</p><h1 id="trait">Trait</h1><h2 id="简介-4">简介</h2><p>Trait告诉编译器某种类型具有哪些并且可以与其他类型共享的功能，抽象的定义共享行为，与其他语言的接口有点类似，但有些区别。</p><p>Trait bounds: 泛型类型参数指定为实现了特定行为的类型</p><h2 id="定义-1">定义</h2><p>把方法签名放在一起，来定义实现某种目的所需的一组行为。1、只有方法签名，没有具体实现2、trait可以有多个方法，每个方法签名占一行，以:结尾3、实现该trait的类型必须提供具体的方法实现</p><p>示例：</p><p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize1</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>实现trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">pub</span> headline: <span class="hljs-type">String</span>, <br>    <span class="hljs-keyword">pub</span> location: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-comment">//NewsArticle可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.headline, <span class="hljs-keyword">self</span>.author, <span class="hljs-keyword">self</span>.location)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> reply: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-comment">//Tweet可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现trait的约束：1、可以在某个类型上实现某个trait的前提条件是：这个类型或这个trait是在本地crate里定义的2、无法为外部类型来实现外部的trait：这个限制是程序属性的一部分（也就是一致性），更具体地说是孤儿原则，之所以这样命名是因为夫类型不存在。此规则确保其他人的代码不能破坏你的代码。如果没有这个规则，两个crate可以为同一类型实现一个trait，rust就不知道应该使用哪个实现</p><p>默认实现代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-comment">//相当于c++中抽象类中函数的默认实现，即在抽象类（父类）方法中实现这个方法，这里也可以直接在接口实现方法</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>&#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Read more ...&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">pub</span> headline: <span class="hljs-type">String</span>, <br>    <span class="hljs-keyword">pub</span> location: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-comment">//NewsArticle可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> reply: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-comment">//Tweet可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Tweet</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="把trait作为函数参数">把trait作为函数参数</h2><p>示例代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">pub</span> headline: <span class="hljs-type">String</span>, <br>    <span class="hljs-keyword">pub</span> location: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-comment">//NewsArticle可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">NewsArticle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.headline, <span class="hljs-keyword">self</span>.author, <span class="hljs-keyword">self</span>.location)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> reply: <span class="hljs-type">bool</span>,<br>    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-type">bool</span>,<br>&#125;<br><br><span class="hljs-comment">//Tweet可以有Summary这个行为</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Tweet</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//即可以传入NewsArticle，也可以传入Tweet,总而言之，可以传入实现了Summary这个trait的所有类型</span><br><span class="hljs-comment">//适用于简单的情况</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><br><span class="hljs-comment">//trait bound写法</span><br><span class="hljs-comment">//适用于复杂的情况，即传入参数多选trait bound</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>,item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><br><span class="hljs-comment">//指定多个trait bound</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> + Display)&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary + Display&gt;(item: T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>,item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用where关键字优化代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notiyf</span>&lt;T: Summary + Display, U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>&gt;(a: T,b: U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, a.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify2</span>&lt;T,U&gt;(a:T, b:U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br><span class="hljs-keyword">where</span><br>T: Summary + Display,<br>U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>,<br>&#123;<br>    <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>,a.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="把trait当作返回类型">把trait当作返回类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-comment">//返回的类型只能是一个，不能是可能会出现两种类型</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例子">例子</h2><p>修复上面的largest函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//PartialOrd trait用来比较，Copy用于基本类型的复制</span><br><span class="hljs-comment">//说明类型T实现了这两个trait</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt; (list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; largest &#123;<br>           largest = item; <br>        &#125;<br>    &#125;<br>    largest<br>&#125;<br><span class="hljs-comment">//如果要比较String</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt; (list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = list[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">clone</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> *item &gt; largest &#123;<br>           largest = item.<span class="hljs-title function_ invoke__">clone</span>(); <br>        &#125;<br>    &#125;<br>    largest<br>&#125;<br><span class="hljs-comment">//或</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt; (list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">largest</span> = &amp;list[<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> list.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>        <span class="hljs-keyword">if</span> item &gt; &amp;largest &#123;<br>           largest = item; <br>        &#125;<br>    &#125;<br>    largest<br>&#125;<br></code></pre></td></tr></table></figure><p>可以有条件地为实现了特定Trait的类型来实现方法：（即只有这个类型拥有了指定的Trait，才能使用这个方法）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T, y: Y) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>&#123;<br>        <span class="hljs-keyword">Self</span> &#123;x, y&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp_diplay</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt; <span class="hljs-keyword">self</span>.y &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.x);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以为实现了其他Trait的任意类型有条件地实现某个Trait，就是说某个类型如果实现了某个Trait，那么就为它实现另外一个Trait。</p><p>为满足TraitBound的所有类型上实现Trait叫做覆盖实现，就上面说的那句话的操作就是覆盖实现，</p><h1 id="生命周期">生命周期</h1><h2 id="简介-5">简介</h2><p>1、Rust的每个引用都有自己的生命周期 2、生命周期：引用保持有效的作用域3、大多数情况：生命周期是隐式的、可被推断的4、当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</p><p>生命周期的主要目标：避免悬垂引用</p><p>借用检查器：比较作用域判断所有的借用是否合法。（被借用的数据生命周期不小于借用数据的生命周期）</p><p>输入生命周期：函数/方法的参数 输出生命周期：函数/方法的返回值</p><h2 id="生命周期标注语法">生命周期标注语法</h2><p>无法比较时，需要显式注明生命周期：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(),string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-comment">//‘a的实际生命周期：</span><br><span class="hljs-comment">//x和y两个参数生命周期比较短的那个</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x : &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;a&#x27; <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期。</p><p>参数名：以'开头，通常全小写且非常短，很多人使用 'a 例子： &amp;i32&amp;'a i32 &amp;'a mut i32 单个生命周期标注本身没有意义</p><h2 id="深入理解生命周期">深入理解生命周期</h2><p>指定生命周期参数的方式依赖于函数所做的事情：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(),string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-comment">//如果函数返回值只跟x有关，那不需要标注y的生命周期</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x : &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;a&#x27; <span class="hljs-type">str</span> &#123;<br>    x<br>&#125;<br></code></pre></td></tr></table></figure><p>从函数返回引用时，返回类型的生命周期参数需要与其中一个参数的生命周期匹配，如果返回的引用没有指向任何参数，那么它只能引用函数内创建的值，这就是悬垂引用，该值在函数结束时就走出了作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(),string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x : &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;a&#x27; <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>    result.<span class="hljs-title function_ invoke__">as_str</span>();<br>&#125;<br><span class="hljs-comment">//如果想返回函数内创建的值，下面这样做</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="struct定义中的生命周期标注">Struct定义中的生命周期标注</h2><p>Struct里可以包括：自持有的类型；引用（需要在每个引用上添加生命周期标注）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//要保证里面的引用数据比sturct实例存活时间长</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcept</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">novel</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Call me Ishmael. Some years ago ...&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = ImportantExcept &#123;<br>        part: first_sentence,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生命周期省略规则">生命周期省略规则</h2><p>在Rust引用分析中所编入的模式称为生命周期省略规则，这些规则无需开发者来遵循，它们是一些特殊情况，由编译器来考虑，如果你的代码符合这些特殊情况，那么就无需显式标注生命周期。</p><p>编译器使用3个规则在没有显式标注生命周期的情况下，来确定引用的生命周期，如果编译器应用完3个规则之后，仍然有无法确定生命周期的引用，那就会报错。这些规则适用于fn定义和impl块</p><p>规则： 1、每个引用类型的参数都有自己的生命周期2、如果只有1个输入生命周期参数，那么该生命周期被赋给所有输出生命周期参数3、如果有多个输入生命周期参数，但其中一个是&amp;self或&amp;mutself（只适用于方法），那么self的生命周期会被赋给所有的输出生命周期参数</p><p>如果不遵循上面三个规则，就需要自己标注生命周期</p><p>方法定义中的生命周期标注1、在struct上使用生命周期实现方法，语法和泛型参数的语法一样2、在哪生命和使用生命周期参数，依赖于生命周期参数是否和字段、方法的参数和返回值有关3、struct字段的生命周期名在impl后生命，在struct名后使用4、生命周期省略规则经常使得方法中的生命周期标注不是必须的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcept</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcept&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">level</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">annouce_and_return_part</span>(&amp;<span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>. announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态生命周期">静态生命周期</h2><p>'static 是一个特殊的生命周期，即整个程序的持续时间。例如：所有的字符串字面值都拥有'static生命周期</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>为引用指定'static生命周期前要三思：是否需要引用在程序整个生命周期内都存活</p><h2 id="例子-1">例子</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest_with_an</span>+announcement&lt;<span class="hljs-symbol">&#x27;a</span>,T&gt; (x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, ann: T) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span><br><span class="hljs-keyword">where</span><br>T: Display,<br>&#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Anncouncement! &#123;&#125;&quot;</span>, ann);<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="测试">测试</h1><h2 id="简介-6">简介</h2><p>测试实际上就是一个函数，用来验证非测试代码的功能是否和预期一致</p><p>测试函数体通常执行的3个操作（3a）： 1、准备数据/状态2、运行被测试的代码 3、断言(Assert)结果</p><p>如何使用：测试函数需要使用test属性(attribute)进行标注，attribute就是一段Rust代码的元数据，在函数上加#[test]，可把函数变成测试函数</p><p>运行测试： 1、使用cargo test 命令运行所有测试函数，rust会构建一个testrunner 可执行文件，它会运行标注了test的函数，并报告其运行是否成功。2、当使用cargo创建library项目时，会生成一个testmodule，里面就有一个test函数。 3、你可以添加任意数量的test module 或函数</p><p>测试失败： 1、测试函数panic就表示失败 2、每个测试运行在一个新线程3、当主线程看见某个测试线程挂掉了，那个测试标记为失败了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/* lib.rs */</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(left: <span class="hljs-type">usize</span>, right: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    left + right<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">another</span>() &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Make this test fail&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="断言assert">断言(assert)</h2><p>使用assert!宏检查测试结果，用来确定某个状态是否为true，如果返回false，调用panic，测试失败</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    length: <span class="hljs-type">u32</span>,<br>    width: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle)  <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.length &gt; other.length &amp;&amp; <span class="hljs-keyword">self</span>.width &gt; other.width<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">larger_can_hold_smaller</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">larger</span> = Rectangle &#123; length: <span class="hljs-number">8</span>, width: <span class="hljs-number">7</span> &#125;;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">smaller</span> = Rectangle &#123; length: <span class="hljs-number">5</span>, width: <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-built_in">assert!</span>(larger.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;smaller));<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">smaller_cannot_hold_larger</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">larger</span> = Rectangle &#123; length: <span class="hljs-number">8</span>, width: <span class="hljs-number">7</span> &#125;;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">smaller</span> = Rectangle &#123; length: <span class="hljs-number">5</span>, width: <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-built_in">assert!</span>(!smaller.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;larger));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用assert_eq!（相等）和assert_ne!（不等）测试相等性断言失败：自动打印出两个参数的值，使用debug格式打印参数，要求参数实现了PartialEq和DebugTraits（所有 基本类型和标准库里的大部分类型都实现了）</p><h2 id="自定义错误信息">自定义错误信息</h2><p>可以想assert!、assert_eq!、assert_ne!添加可选的自定义信息，这些自定义信息和失败消息都会打印出来。</p><p>assert!：第一个参数必填，自定义消息作为第二个参数assert_eq!和assert_nq!：前两个参数必填，自定义消息作为第三个参数</p><p>自定义消息参数会被传递给format!宏，可以使用{}占位符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <br></code></pre></td></tr></table></figure><h2 id="should_panic">should_panic</h2><p>验证错误处理的情况：测试除了验证代码的返回值是否正确，还需验证代码是否如预期地处理了发生错误的情况。</p><p>可验证代码在特定情况下是否发生了panic</p><p>需要在代码中添加should_panic属性： 函数发生panic：测试通过函数没有发生panic：测试失败</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guess</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> || value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be betwwen 1 and 100, got &#123;&#125;&quot;</span>, value);<br>        &#125;<br><br>        Guess &#123;<br>            value,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greater_than_100</span>() &#123;<br>        Guess::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>让should_panic更精确，为should_panic属性添加一个可选的expected参数，将检查失败消息中是否包含所指定的文字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guess</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Guess</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> Guess &#123;<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;&quot;</span>, value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>, value);<br>        &#125;<br><br>        Guess &#123;<br>            value,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[should_panic(expected = <span class="hljs-string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">greater_than_100</span>() &#123;<br>        Guess::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">200</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在测试中使用result">在测试中使用Result</h2><p>无需panic，可使用Result&lt;T, E&gt;作为返回类型编写测试：返回Ok：测试通过 返回Err：测试失败</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt;&#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span> == <span class="hljs-number">4</span> &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;two plus does not equal four&quot;</span>))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：不要在使用Result&lt;T, E&gt;编写的测试上标注#<ahref="#should_panic">should_panic</a></p><h2 id="控制测试运行">控制测试运行</h2><p>改变cargo test的行为：添加命令行参数</p><p>如果不添加命令行参数，会执行默认行为： 1、并行运行所有测试2、捕获（不显示）所有输出，使读取与测试结果相关的输出更容易</p><p>命令行参数： 1、针对cargo test的参数，紧跟在cargo test后2、针对测试可执行程序：放在 --之后</p><p>cargo test --help（显示可以放在cargo test后面的参数） 和 cargo test-- --help（显示可以放在cargo test --后面的参数）</p><h3 id="并行运行测试">并行运行测试</h3><p>默认使用多个线程并行运行</p><p>确保测试之间： 1、不会相互依赖2、不依赖于某个共享状态（环境、工作目录、环境变量等等）</p><h3 id="test-threads-参数">--test-threads 参数</h3><p>1、传递给二进制文件2、不想以并行方式运行测试，或想对线程数进行细粒度控制 3、可以使用--test-threads 参数，后边跟着线程的数量</p><p>例如： cargo test -- --test-threads=1</p><h3 id="显式函数输出">显式函数输出</h3><p>默认，如测试通过，rust的test库会捕获所有打印到标准输出的内容</p><p>例如：如果被测试段代码中用到了println!：1、如果测试通过：不会在终端看到println!打印的内容2、如果测试失败：会看到println!打印的内容和失败信息</p><p>如果想在成功的测试中看到打印的内容：cargo test -- --show-output</p><h2 id="按名称运行测试">按名称运行测试</h2><p>选择运行的测试：将测试的名称（一个或多个）作为cargo test的参数</p><p>运行单个测试：指定测试名 例子：cargo test 测试函数名称</p><p>运行多个测试：指定测试名的一部分（模块名也可以）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_two</span>(a: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> super::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_two_and_two</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, <span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">2</span>));<br>    &#125;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_three_and_two</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, <span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">3</span>));<br>    &#125;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hundred</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">102</span>, <span class="hljs-title function_ invoke__">add_two</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行多个测试： 1、cargo test add：运行add_two_and_two和add_three_and_two两个测试 2、cargo test tests：运行tests这个模块的测试</p><h2 id="忽略测试">忽略测试</h2><p>可以忽略运行比较耗时的测试</p><p>ignore属性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-meta">#[ignore]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">expensive_test</span>() &#123;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要运行忽略的测试： cargo test -- --ignored</p><h2 id="测试的分类">测试的分类</h2><p>单元测试和集成测试</p><p>单元测试： 1、小、专注 2、一次对一个模块进行隔离的测试3、可测试private接口</p><p>集成测试： 1、在库外部。和其他外部代码一样使用你的代码2、只能使用public接口 3、可能在每个测试中使用到多个模块</p><h3 id="单元测试">单元测试</h3><p>单元测试用#[cfg(test)]标注：只有运行cargo test才编译和运行代码集成测试则不需要#[cfg(test)]，集成测试在不同的目录</p><p>rust允许测试私有函数</p><h3 id="集成测试">集成测试</h3><p>在rust中，集成测试完全位于被测试库的外部</p><p>目的：是测试被测试库的多个部分是否能正确地一起工作</p><p>创建集成测试：创建tests目录，tests目录下的每个测试文件都是单独的一个crate（需要将被测试库导入）</p><p>无需标注#[cfg(test)]，tests目录被特殊对待，只有cargotest，才会编译tests目录下的文件</p><p>运行指定的集成测试： 1、运行一个特定的集成测试： cargo test 函数名2、运行某个测试文件内的所有测试：cargo test --test 文件名</p><p>如果想要在tests目录下创建其他辅助函数而不用进行测试运行，则在tests目录下重新创建一个文件夹，然后把辅助函数放在这个文件夹中。（文件命名可以为mod.rs）（使用该模块要导入，在代码中用mod 文件夹名即可导入）</p><p>针对binary crate的集成测试： 如果项目是binarycrate，只有含有main.rs没有lib.rs，不能在tests目录下创建集成测试，无法把main.rs的函数导入作用域只有library crate才能暴露函数给其他crate用，binarycrate意味着独立运行</p><h1 id="文件处理">文件处理</h1><h2 id="文件读取">文件读取</h2><p>用String类存储：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;文件读取失败！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="闭包">闭包</h1><h2 id="简介-7">简介</h2><p>闭包：可以捕获其所在环境的匿名函数</p><p>特性： 1、是匿名函数 2、保存为变量、作为参数3、可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算4、可从其定义的作用域捕获值</p><h2 id="例子-2">例子</h2><p>名称：生成自定义运动计划的程序</p><p>算法的逻辑并不是重点，重点是算法中的计算过程所耗费的时间</p><p>目标：仅在必要时调用该算法，只调用一次</p><p>原本代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">simulated_user_specified_value</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">simulated_random_number</span> = <span class="hljs-number">7</span>;<br><br>    <span class="hljs-title function_ invoke__">generate_workout</span>(simulated_user_specified_value, simulated_random_number);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">simulated_expensive_calculation</span>(intensity: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;正在计算……&quot;</span>);<br>    thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>    intensity<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity)<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity)<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity)<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步改进generate_workout函数：（用变量存储函数的返回值，但是不需要的情况又造成浪费）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">simulated_expensive_calculation</span>(intensity);<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            result<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            result<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                result<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用闭包改进： （可以用闭包的特性继续改进）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-comment">//这里只是定义了函数，并没有执行</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">expensive_closure</span> = |num: <span class="hljs-type">u32</span>| &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;calculating slowly...&quot;</span>);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        num<br>    &#125;;<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">expensive_closure</span>(intensity)<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            <span class="hljs-title function_ invoke__">expensive_closure</span>(intensity)<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                <span class="hljs-title function_ invoke__">expensive_closure</span>(intensity)<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包类型推断和标注">闭包类型推断和标注</h2><p>闭包的类型推断： 1、闭包不要求标注参数和返回值的类型2、闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型3、可以手动添加类型标注注意：闭包的定义最终只会为参数/返回值推断出唯一具体的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">example_closure</span> = |x| x;<br>    <br>    <span class="hljs-comment">//let s = example_closure(String::from(&quot;hello&quot;));</span><br>    <span class="hljs-comment">//let n = example_closure(5);</span><br>    <span class="hljs-comment">//取消第一个注释，编译器不会报错，并把x定义为String类型，取消第二个注释会报错，因为编译器已经把x定义为String类型</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="存储闭包">存储闭包</h2><p>使用泛型参数和fn trait来存储闭包</p><p>记忆化/延迟计算：创建一个struct，它持有闭包及其调用结果，只会在需要结果时才执行该闭包，可缓存结果</p><p>如何让struct持有闭包：struct的定义需要知道所有字段的类型：需要指明闭包的类型，每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样，所以需要使用泛型和traitbound</p><p>fn traits由标准库提供 所有的闭包都至少实现了以下trait之一：Fn FnMutFnOnce</p><p>改进上面的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    calculation: T,<br>    value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt; <br><span class="hljs-keyword">where</span><br>T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>,<br>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(calculation: T) <span class="hljs-punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;<br>        Cacher &#123;<br>            calculation,<br>            value: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">value</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>,arg: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.value &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(v) =&gt; v,<br>            <span class="hljs-literal">None</span> =&gt; &#123;<br>                <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = (<span class="hljs-keyword">self</span>.calculation)(arg);<br>                <span class="hljs-keyword">self</span>.value = <span class="hljs-title function_ invoke__">Some</span>(v);<br>                v<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generate_workout</span>(intensity: <span class="hljs-type">u32</span>, random_number: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">expensive_closure</span> = Cacher::<span class="hljs-title function_ invoke__">new</span>(|num|&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;calculating slowly ...&quot;</span>);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        num<br>    &#125;);<br>    <span class="hljs-keyword">if</span> intensity &lt; <span class="hljs-number">25</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,<br>            expensive_closure.<span class="hljs-title function_ invoke__">value</span>(intensity)<br>        );<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Next, do &#123;&#125; situps!&quot;</span>,<br>            expensive_closure.<span class="hljs-title function_ invoke__">value</span>(intensity)<br>        );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> random_number == <span class="hljs-number">3</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,<br>                expensive_closure.<span class="hljs-title function_ invoke__">value</span>(intensity)<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Cacher实现的限制：1、Cacher实例假定针对不同的参数arg，value方法总会得到同样的值，可以使用HashMap，key：arg参数，value：执行闭包的结果2、只能接收一个u32类型的参数和u32类型的返回值</p><h2 id="使用闭包捕获上下文">使用闭包捕获上下文</h2><p>闭包可以捕获它们所在的环境：闭包可以访问定义它的作用域内的变量，而普通函数则不能。但会产生内存开销。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = |z| z == x;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><p>闭包从所在环境捕获值得方式： 与函数获得参数的三种方式一样：1、取得所有权：FnOnce 2、可变借用：FnMut 3、不可变借用：Fn</p><p>创建闭包时，通过闭包对环境值的使用，rust能推断出具体使用哪个trait：所有闭包都实现了FnOnce 没有移动捕获变量的实现了FnMut无需可变访问捕获变量的闭包实现了Fn</p><p>move关键字：在参数列表前使用move关键字，可以强制闭包取得它所使用的环境值得所有权。当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = <span class="hljs-keyword">move</span> |z| z == x; <br>    <span class="hljs-comment">//println!(&quot;can&#x27;t use x here: &#123;:?&#125;&quot;,x);</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><p>最佳实践： 当指定Fn trait bound之一时，首先用Fn，基于闭包体里的情况，如果需要FnOnce或FnMut，编译器会再告诉你</p><h1 id="迭代器">迭代器</h1><h2 id="简介-8">简介</h2><p>迭代器模式：对一系列执行某些任务</p><p>迭代器负责：遍历每个项；确定序列（遍历）何时完成</p><p>rust的迭代器：懒惰的：除非调用消费迭代器的方法，否则迭代器本省没有任何效果</p><h2 id="iterator-trait和next方法">iterator trait和next方法</h2><h3 id="iterator-trait">iterator trait</h3><p>所有迭代器都实现了iterator trait</p><p>iterator trait定义与标准库，定义大致如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>type Item和 Self::Item定义了与此该trait关联的类型： 实现Iteratortrait需要你定义一个Item类型，它用于next方法的放回类型</p><h3 id="next">next</h3><p>每次返回迭代器中的一项，返回结果包裹在Some里，迭代结束，返回None</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iterator_demonstration</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1_iter</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>        <br>        <span class="hljs-built_in">assert_eq!</span>(v1_iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(v1_iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(v1_iter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="几个迭代方法">几个迭代方法</h3><p>iter方法：在不可变引用上创建迭代器into_iter方法：创建的迭代器会获得所有权 iter_mut方法：迭代可变的引用</p><h2 id="消耗产生迭代器">消耗/产生迭代器</h2><p>消耗迭代器的方法：调用next方法的叫做“消耗型适配器”，因为调用它会把迭代器耗尽例如：sum方法，取得迭代器的所有权，通过反复调用next，遍历所有元素，每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iterator_sum</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1_iter</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span>: <span class="hljs-type">i32</span> = v1_iter.<span class="hljs-title function_ invoke__">sum</span>();<br>        <span class="hljs-built_in">assert_eq!</span>(total,<span class="hljs-number">6</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>产生其他迭代器的方法： 定义在iteratortrait上的另外一些方法叫做”迭代器适配器“：把迭代器转换为不同种类的迭代器可以通过链式调用使用多个迭代器适配器来执行复杂的操作，且可读性较高例如：map，接收一个闭包，闭包作用于每个元素</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iterator_sum</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = v1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x|&#123;x+<span class="hljs-number">1</span>&#125;).<span class="hljs-title function_ invoke__">collect</span>();<br>        <span class="hljs-built_in">assert_eq!</span>(v2, <span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>map方法是产生，接收一个闭包</p><p>collect方法：消耗性适配器，把结果收集到一个集合类型中，返回时Vec类型</p><h2 id="使用闭包捕获环境">使用闭包捕获环境</h2><p>filter方法： 接收一个闭包这个闭包在遍历迭代器的每个元素时，返回bool类型如果闭包返回true，当前元素将会包含在filter产生的迭代器中如果闭包返回false，当前元素将不会包含在filter产生的迭代器中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Shoe</span> &#123;<br>    size: <span class="hljs-type">u32</span>,<br>    style: <span class="hljs-type">String</span>, <br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">shoe_in_my_size</span>(shoes: <span class="hljs-type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;Shoe&gt; &#123;<br>    shoes.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|x| x.size == shoe_size).<span class="hljs-title function_ invoke__">collect</span>()<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">filter_by_size</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">shoes</span> = <span class="hljs-built_in">vec!</span>[<br>        Shoe &#123;<br>            size: <span class="hljs-number">10</span>,<br>            style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sneaker&quot;</span>),<br>        &#125;,<br>        Shoe &#123;<br>            size: <span class="hljs-number">13</span>,<br>            style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sandal&quot;</span>),<br>        &#125;,<br>        Shoe &#123;<br>            size: <span class="hljs-number">10</span>,<br>            style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boot&quot;</span>),<br>        &#125;<br>    ];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">in_my_size</span> = <span class="hljs-title function_ invoke__">shoe_in_my_size</span>(shoes, <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(<br>            in_my_size,<br>            <span class="hljs-built_in">vec!</span>[<br>                Shoe &#123;<br>                    size: <span class="hljs-number">10</span>,<br>                    style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;sneaker&quot;</span>),<br>                &#125;,<br>                Shoe &#123;<br>                    size: <span class="hljs-number">10</span>,<br>                    style: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;boot&quot;</span>),<br>                &#125;<br>            ]<br>        );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建自定义迭代器">创建自定义迭代器</h2><p>实现next方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;<br>    count : <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Counter &#123;<br>        Counter &#123;<br>            count: <span class="hljs-number">0</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实现Iterator这个trait</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.count &lt; <span class="hljs-number">5</span> &#123;<br>            <span class="hljs-keyword">self</span>.count += <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.count)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_next_directly</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = Counter::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(counter.<span class="hljs-title function_ invoke__">next</span>(), <span class="hljs-literal">None</span>);<br>&#125;<br><br><span class="hljs-comment">//zip是将两个迭代器的元素分别组成一个元素然后放入集合</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">using_other_iterator_trait_methods</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span>: <span class="hljs-type">u32</span> = Counter::<span class="hljs-title function_ invoke__">new</span>()<br>        .<span class="hljs-title function_ invoke__">zip</span>(Counter::<span class="hljs-title function_ invoke__">new</span>().<span class="hljs-title function_ invoke__">skip</span>(<span class="hljs-number">1</span>))<br>        .<span class="hljs-title function_ invoke__">map</span>(|(a,b)| a*b)<br>        .<span class="hljs-title function_ invoke__">filter</span>(|x| x%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>)<br>        .<span class="hljs-title function_ invoke__">sum</span>();<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">18</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环和迭代器">循环和迭代器</h2><p>迭代器更快</p><p>零开销抽象：使用抽象时不会引入额外的运行时开销</p><p>放心多多使用迭代器</p><h2 id="迭代器方法">迭代器方法</h2><h3 id="join">join</h3><p>作用：将一个可迭代对象的元素连接成一个字符串的方法，它接受一个分隔符作为参数，并将可迭代对象中的每个元素以该分隔符连接起来，最终返回一个包含所有元素的字符串</p><p>函数签名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">join</span>&lt;Separator&gt;(&amp;<span class="hljs-keyword">self</span>, sep: Separator) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> <br><span class="hljs-keyword">where</span><br>Separator: Display + <span class="hljs-built_in">Clone</span>,<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">words</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;rust&quot;</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = words.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;, &quot;</span>); <span class="hljs-comment">// 使用 &quot;, &quot; 作为分隔符</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result); <span class="hljs-comment">// 输出：hello, world, rust</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="product">product</h3><p>计算从1到num之间所有整数的成绩，并将结果存储在变量v中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = (<span class="hljs-number">1</span>..=num).<span class="hljs-title function_ invoke__">product</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="智能指针">智能指针</h1><h2 id="简介-9">简介</h2><p>指针：一个变量在内存中包含的是一个地址（指向其他数据）</p><p>rust中最常见的指针就是引用&amp;</p><p>智能指针： 行为和指针相似 有额外的元数据和功能</p><p>引用计数智能指针类型：1、通过记录所有者的数量，使一份数据被多个所有者同时持有2、并在没有任何所有者时自动清理数据</p><p>智能指针的例子： 1、String和Vec2、都拥有一片内存区域，且允许用户对其操作 3、还拥有元数据4、提供额外的功能或保障（String保障其数据是合法的UTD-8编码）</p><p>智能指针的实现：1、通常使用struct实现，并实现了Deref和Drop这两个trait 2、Dereftrait：允许智能指针struct的实例项引用一样使用 3、Droptrait：允许你自定义当智能指针实例走出作用域时的代码</p><p>标准库中常见的智能指针： Box<T>：在heap内存上分配值Rc<T>：启用多重所有权的引用计数类型Ret<T>和RefMut<T>：通过RefCell<T>访问；在运行时而不是编译时强制借用规则的类型</p><p>内部可变模式： 不可变类型暴露出可修改其内部值的API</p><p>引用循环： 它们如何泄露内存，以及如何防止其发生</p><table><thead><tr><th></th><th>Box</th><th>Rc</th><th>refcell</th></tr></thead><tbody><tr><td>同一数据的所有者</td><td>一个</td><td>多个</td><td>一个</td></tr><tr><td>可变性、借用检查</td><td>可变、不可变借用</td><td>不可变借用</td><td>可变、不可变借用</td></tr></tbody></table><p>Box和Rc都在编译时检查，RefCell在运行时检查</p><h2 id="box">Box</h2><p>最简单的智能指针： 1、允许在heap上存储数据2、stack上是指向heap数据的指针 3、没有性能开销和没有其他额外的功能</p><p>常用场景：1、在编译时，某类型的大小无法确定。但使用该类型时，上下文却需要知道它的确切大小2、当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制3、使用某个值时，只关心它是否实现了特定的trait，而不关心它的具体类型</p><p>存储数据的简单例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b = &#123;&#125;&quot;</span>, b);<br>&#125;<span class="hljs-comment">//作用域结束b内存会释放</span><br></code></pre></td></tr></table></figure><p>使用Box赋能递归类型： 1、在编译时，rust需要知道一个类型所占空间的大小2、而递归类型的大小无法在编译时确定 3、当Box类型的大小确定</p><p>关于Cons List： 1、来自Lisp语言的一种数据结构2、两个元素：当前项的值，下一个元素3、最后一个成员只包含Nil值，没有下一个元素</p><p>Cons List并不是rust的常用集合，而是Vec<T></p><p>使用Box来获得确定大小的递归类型：Box<T>是一个指针，rust知道它需要多少空间，因为指针的大小不会基于它指向的数据的大小变化而变化（间接存储）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">1</span>,<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">2</span>,<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>,<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Nil))))));<br>&#125;<br></code></pre></td></tr></table></figure><p>Box<T>解引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(x);<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>,x);<br>    <span class="hljs-built_in">assert_ne!</span>(<span class="hljs-number">5</span>,*y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="deref-trait">Deref Trait</h2><p>1、实现Deref Trait使我们可以自定义解引用运算符*的行为2、通过实现Deref，智能指针可像常规引用一样来处理</p><p>定义自己的智能指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; (T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(x);<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>,*y);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数和方法的隐式解引用转化：1、隐式解引用转换是为函数和方法提供的一种便捷特性 2、假设T实现了Dereftrait：Deref Coercion 可以把T的引用转化为T经过Deref操作后生成的引用3、当某类型的引用传递给函数或方法时，但它的类型与定义的参数类型不匹配：Deref Coercion就会自动发生编译器会对deref进行一系列调用，来吧它转为所需的参数类型，且在编译时完成，没有额外开销</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; (T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">MyBox</span>(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Rust&quot;</span>));<br><br>    <span class="hljs-comment">// &amp;m =&gt; &amp;MyBox&lt;Stirng&gt;</span><br>    <span class="hljs-comment">// deref =&gt; &amp;String</span><br>    <span class="hljs-comment">// deref =&gt; &amp;str</span><br>    <span class="hljs-title function_ invoke__">hello</span>(&amp;m);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello</span>(name: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;&#125;&quot;</span>,name);<br>&#125;<br></code></pre></td></tr></table></figure><p>解引用与可变性： 1、可使用DerefMut trait重载可变引用的*运算符2、在类型和triat在下列三种情况发生时，rust会执行deref coercion： 当T:Deref&lt;Target=U&gt;，允许&amp;T转换为&amp;U 当T:DerefMut&lt;Target=U&gt;，允许&amp;mut T转换为&amp;mut U 当T:Deref&lt;Target=U&gt;，允许&amp;mut T转换为&amp;U</p><h2 id="drop-trait">Drop Trait</h2><p>实现Drop Trait，可以让我们自定义当值将要离开作用域时发生的动作：例如：文件、网络资源释放等 任何类型都可以实现Drop Trait</p><p>Drop Trait只要求你实现drop方法： 参数：对self的可变引用</p><p>Drop trait在预导入模块中，不用引入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    data: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping CustomSmartPointer with data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.data);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;My stuff&quot;</span>),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;other stuff&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;CustomSmartPointers created.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用std::mem::drop来提前drop值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//use std::mem::drop;可写可不写</span><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    data: <span class="hljs-type">String</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">CustomSmartPointer</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping CustomSmartPointer with data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.data);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;My stuff&quot;</span>),<br>    &#125;;<br>    <span class="hljs-title function_ invoke__">drop</span>(c);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = CustomSmartPointer &#123;<br>        data: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;other stuff&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;CustomSmartPointers created.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="rc引用计数智能指针">Rc引用计数智能指针</h2><p>只有当数据为零引用时，这个智能指针才会被清理</p><p>使用场景：1、需要在heap上分配数据，这些数据被程序的多个部分读取（只读），但在编译时无法确定哪个部分使用完这些数据2、Rc<T>智能用于单线程场景</p><p>Rc不在预导入模块 Rc::clone(&amp;a)函数：增加引用计数Rc::strong_count(&amp;a)：获得引用计数（强引用），还有Rc::weak_count函数</p><p>例子： 两个List共享另一个List 的所有权：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, Rc&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">5</span>, <br>        Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">10</span>, <br>            Rc::<span class="hljs-title function_ invoke__">new</span>(Nil)))));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    <span class="hljs-comment">//使用引用不会获得a的所有权，使用clone函数增加Rc计数</span><br>    <span class="hljs-comment">//Rc::clone不会进行深度拷贝，增加效率</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">4</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count after c gose out of scope = &#123;&#125;&quot;</span>,<br>        Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>&#125;<br></code></pre></td></tr></table></figure><p>Rc通过<strong>不可变</strong>引用，使你可以在程序不同部分之间共享只读数据</p><h2 id="refcell和内部可变性">RefCell和内部可变性</h2><p>内部可变性： 1、是rust的设计模式之一2、它允许你在只持有不可变引用的前提下对数据进行修改：数据结构中使用了unsafe代码来绕过rust正常的可变性和借用规则</p><p>与Rc不同，RefCell类型代表了其持有数据的唯一所有权，但二者都只能适用于单线程场景</p><p>Box和RefCell的区别：1、Box在编译阶段强制代码遵守借用规则，否则出现错误2、RefCell只在运行时检查借用规则，否则触发panic</p><p>内部可变性：可变的借用一个不可变的值</p><p>没看懂，后面有需要再看： BV1hp4y1k7SV 的P91</p><h2 id="循环引用导致内存泄漏">循环引用导致内存泄漏</h2><p>使用Rc和RefCell接可能创造出循环引用，从而发生内存泄漏</p><p>没看懂，后面有需要再看： BV1hp4y1k7SV 的P92</p><h1 id="无畏并发">无畏并发</h1><h2 id="简介-10">简介</h2><p>concurrent：程序的不同部分之间独立地执行（并发）parallel：程序的不同部分同时执行（并行）</p><p>本章统称为并发</p><p>rust无畏并发：允许编写没有细微bug的代码，并再不引入新bug的情况下易于重构</p><h2 id="多线程运行代码">多线程运行代码</h2><p>多线程导致的问题： 竞争状态：线程以不一致的顺序访问数据或资源死锁：两个线程彼此等待对方使用完所持有的资源，线程无法继续只有在某些情况下发生的bug，很难可靠地复制现象和修复</p><p>实现线程的方式： 1、通过调用OS的API来创建线程：1：1模型：需要较小的运行时 2、语言自己实现的线程（绿色线程）：M：N模型：需要更大的运行时</p><p>rust标准库只提供1：1模型</p><p>通过thread::spawn函数可以创建新线程：参数：一个闭包（在新线程里运行的代码）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-comment">//没法等待所有线程的完成</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>)); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过join Handle等待所有线程的完成：1、thread::spawn函数的返回值类型是JoinHandle2、JoinHandle持有值得所有权：调用其join方法，可以等待对应的其他线程的完成3、join方法：调用handle的join方法会阻止当前运行线程的执行，直到handle所表示的这些线程终结</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">2</span>)); <br>    &#125;<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 等待子线程结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用move闭包：1、move闭包通常和thread::spawn函数一起使用，它允许使用其他线程的数据2、创建线程时，把值的所有权从一个线程转移到另一个线程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>,v);<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 等待线程结束</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消息传递跨线程传递数据">消息传递跨线程传递数据</h2><p>Go语言的名言：不要用共享内存来通信，要用通信来共享内存</p><p>流行且能保证安全并发的技术：消息传递线程通过彼此发送信息来进行通信</p><p>Channel： 1、发送端、接收端2、如果两端中有一端被关闭，那Channel就被关闭</p><p>使用mpsc::channel函数创建Channel： mpsc表示multiple producer，singleconsumer（多个生产者，一个消费者）返回一个tuple，里面的元素分别是发送端、接收端</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>        tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">received</span> = rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>&#125;<br></code></pre></td></tr></table></figure><p>发送端send方法： 参数：想要发送的数据返回：Result&lt;T,E&gt;，如果有问题，返回一个错误</p><p>接收端方法： 1、recv方法：阻止当前线程执行，直到Channel中有值被送来一旦有值收到，就返回Result&lt;T, E&gt; 当发送端关闭，就会收到一个错误2、try_recv方法，不会阻塞： 立即返回Result&lt;T, E&gt;通常会使用循环调用检查try_recv的结果</p><p>当使用Channel发送数据值，该数据的所有权已经发送出去了</p><p>发送多个值，看到接受者在等待：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::btree_map::Values;<br><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx,rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;thread&quot;</span>),<br>        ];<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过克隆创建多个发布者：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::btree_map::Values;<br><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx,rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tx1</span> = mpsc::Sender::<span class="hljs-title function_ invoke__">clone</span>(&amp;tx);<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1: thread&quot;</span>),<br>        ];<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx1.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;thread&quot;</span>),<br>        ];<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="共享状态的并发">共享状态的并发</h2><p>Channel类似单所有权：一旦将值的所有权转移至Channel，就无法使用它共享内存并发类似多所有权：多个线程可以同时访问同一块内存</p><p>使用Mutex来每次只允许一个线程访问数据 1、Mutex是mutualexclusion（互斥锁）的简写2、在同一时刻，Mutex只允许一个线程来访问某些数据 3、想要访问数据：线程必须首先获取互斥锁，lock数据结构是mutex的一部分，它能跟踪谁对数据有用独占访问权mutex通常被描述为：通过锁定系统来保护它所持有的数据</p><p>mutex的两条规则： 1、在使用数据之前，必须尝试获取锁2、使用完mutex所保护的数据，必须对数据进行解锁，以便其他线程可以获取锁</p><p>Mutex<T>的API： 1、通过Mutex::new来创建（智能指针）2、访问数据前，通过lock方法来获取锁 会阻塞当前线程 lock可能会失败返回的是MutexGuard（智能指针）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">//要共享的数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num = <span class="hljs-number">6</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);<br>&#125;<br></code></pre></td></tr></table></figure><p>多线程多重所有权： （错误的代码）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *num += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Counter: &#123;&#125;&quot;</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>多线程的多重所有权： Arc和Rc类似，但是它可以用于并发情景</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *num += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, temp);<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，要共享的数据，就用Mutex<T>创建就可以了，然后再多个线程锁住它、使用它、解锁它</p><h2 id="send-和-sync-trait">Send 和 Sync trait</h2><p>Send：允许线程间转移所有权 只有Rc没有实现Send</p><p>Sync：允许从多线程访问 实现Sync类型可以安全的被多个线程引用Mutex实现了Sync</p><p>手动来实现Send和Sync是不安全的</p><h1 id="模式匹配">模式匹配</h1><h2 id="简介-11">简介</h2><p>1、模式是rust中一种特殊语法，用于匹配复杂和简单类型的结构2、将模式与匹配表达式和其他构造结合使用，可以更地控制程序的控制流3、模式将由以下元素（的一些组合）组成：字面值、结构的数组、enum、struct和tuple、变量、通配符、占位符4、想要使用模式，需要将其与某个值进行比较：如果模式匹配，就可以在代码中使用这个值的相应部分</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<br>   <span class="hljs-keyword">for</span>(index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>,value,index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> (x,y,z) = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式的两种形式">模式的两种形式</h2><p>不可辨驳的：能匹配任何可能传递的模式 例如：let x = 5;</p><p>可辩驳的：对某些可能的值，无法进行匹配的模式 例如：if let Some(x) =a_value;</p><h2 id="语法">语法</h2><p>或：符号“|”</p><p>表示范围：..=</p><p>加条件：if关键字</p><h1 id="高级特性">高级特性</h1><h2 id="unsafe-rust">unsafe rust</h2><p>rust隐藏着第二个语言，它没有强制内存安全保证：Unsaferust和普通的rust一样，但是提供了额外的“超能力”</p><p>存在的原因： 1、静态分析是保守的：使用unsaferust：我知道自己在做什么，并承担相应风险2、计算机硬件本身就是不安全的，rust需要能够进行底层系统编程</p><p>使用unsafe关键字来切换到unsaferust，开启一个块，里面放着unsafe代码</p><p>unsafe rust可执行的四个动作： 1、解引用原指针 2、调用unsafe函数或方法3、访问或修改可变的静态变量 4、实现unsafe trait</p><p>注意： 1、unsafe并没有关闭借用检查或停用其他安全检查2、任何内存安全相关的错误必须留在unsafe块里3、尽可能隔离unsafe代码，最好将其封装在安全的抽象里，提供安全的API</p><p>原始指针： 可变的：<span class="math inline">\(*\)</span>mut T不可变的：<span class="math inline">\(*const\)</span>T。意味着解引用后不能直接对其进行赋值</p><p>与引用不同，原始指针：1、允许通过同时具有不可变和可变指针或多个指向同一位置的可变指针来忽略借用规则2、无法保证指向合理的内存 3、允许为null 4、不实现任何自动清理5、放弃保证的安全，换取更好的性能/与其他语言或硬件接口的能力</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>;<br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r1: &#123;&#125;&quot;</span>, *r1);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r2: &#123;&#125;&quot;</span>, *r2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要使用原始指针： 1、与C语言进行接口2、构建借用检查器无法理解的安全抽象</p><p>unsafe函数或方法：在定义前加上了unsafe关键字：1、调用前需要手动满足一些条件（主要靠看文档），因为rust无法对这些条件进行验证2、需要在unsafe块里进行调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangerous</span>() &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-title function_ invoke__">dangerous</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建unsafe代码的安全抽象：1、函数包含unsafe代码并不意味着需要将整个函数标记为unsafe2、将unsafe代码包裹在安全函数中是一个常见的抽象</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::slice;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">split_at_mut</span>(slice: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], mid: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>], &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">i32</span>]) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = slice.<span class="hljs-title function_ invoke__">len</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = slice.<span class="hljs-title function_ invoke__">as_mut_ptr</span>();<br>    <span class="hljs-built_in">assert!</span>(mid &lt;= len);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        (slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),<br>         slice::<span class="hljs-title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="hljs-title function_ invoke__">offset</span>(mid <span class="hljs-keyword">as</span> <span class="hljs-type">isize</span>), len - mid))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br>    <span class="hljs-keyword">let</span> (a, b) = <span class="hljs-title function_ invoke__">split_at_mut</span>(&amp;<span class="hljs-keyword">mut</span> v, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(a, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(b, &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用extern函数调用外部代码：1、extern关键字：简化创建和使用外部函数接口的过程2、外部函数接口：它允许一种编程语言定义函数，并让其他编程语言能调用这些函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">abs</span>(input: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>; <span class="hljs-comment">// 声明外部函数</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Absolute value of -3 according to C: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">abs</span>(-<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从其他语言调用rust函数：1、可以使用extern创建接口，其他语言通过它们调用rust函数2、在fn前添加extern关键字，并指定ABI3、还需添加#[no_mangle]注解：避免rust在编译时改变它的名称</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_from_c</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Just called a Rust function from C&quot;</span>);<br>&#125;<br><span class="hljs-comment">//可以被C语言调用，不需要unsafe</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>访问或修改一个可变静态变量：1、rust支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争2、在rust里，全局变量叫做静态变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> HELLO_WORLD: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-comment">//命名规范如上</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, HELLO_WORLD);<br>    <span class="hljs-comment">// 编译器会提示错误，因为不能修改一个`static`绑定</span><br>    <span class="hljs-comment">// HELLO_WORLD = &quot;Hello, Rust!&quot;;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>常量：允许使用它们的时候对数据进行复制 静态变量：1、有固定的内存地址，使用它的值总会访问同样的数据2、可以是可变的，访问和修改静态可变变量是不安全的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-type">u32</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_count</span>(inc: <span class="hljs-type">u32</span>) &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        COUNTER += inc;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">add_to_count</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现不安全trait：1、当某个trait中存在至少一个方法拥有编译器无法校验的不安全因素时，就称这个trait是不安全的2、声明unsafe trait：在定义前加unsafe</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">i32</span>&#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="高级trait">高级trait</h2><p>在trait定义中使用关联类型来指定占位类型：关联类型是trait中的类型占位符，它可以用于trait的方法签名中：可以定义出包含某些类型的trait，而在实现前无需知道这些类型是什么</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>关联类型与泛型的区别：</p><table><thead><tr><th>泛型</th><th>关联类型</th></tr></thead><tbody><tr><td>每次实现triat时标注类型</td><td>无需标注类型</td></tr><tr><td>可以为一个类型多次实现某个trait</td><td>无法为单个类型多次实现某个trait</td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::path::Iter;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator2</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator2</span>&lt;<span class="hljs-type">u32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator2</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-literal">None</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>默认泛型参数和运算符重载：1、可以在使用泛型参数时为泛型指定一个默认的具体类型2、语法：&lt;PlaceholderType=ConcreteType&gt;3、这种技术常用于运算符重载4、rust不允许创建自己的运算符及重载任意的运算符5、但可以通过实现std::ops中列出的那些trait来重载一部分相应的预算符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span> &#125; + Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span> &#125;, Point &#123; x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>指定默认类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Millimeter</span>(<span class="hljs-type">u32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meters</span>(<span class="hljs-type">u32</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span>&lt;Meters&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Millimeter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Millimeter;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Meters) <span class="hljs-punctuation">-&gt;</span> Millimeter &#123;<br>        <span class="hljs-title function_ invoke__">Millimeter</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br>    <br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span> () &#123;&#125;<br></code></pre></td></tr></table></figure><p>调用同名方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Pilot</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Wizard</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Human</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Pilot</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is your captain speaking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Wizard</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Up!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Human</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>)&#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*waving arms furiously*&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">person</span> = Human;<br>    person.<span class="hljs-title function_ invoke__">fly</span>(); <span class="hljs-comment">// 调用结构体中的函数</span><br>    Pilot::<span class="hljs-title function_ invoke__">fly</span>(&amp;person);<br>    Wizard::<span class="hljs-title function_ invoke__">fly</span>(&amp;person);<br>    Human::<span class="hljs-title function_ invoke__">fly</span>(&amp;person); <span class="hljs-comment">// 调用关联函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法参数没有传入自身类型，使用完全限定语法：1、可以在任何调用函数或方法的地方使用2、允许忽略那些从其他上下文能推导出来的部分3、当rust无法区分你期望调用哪个具体实现的时候，才需要使用这种语法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Spot&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;puppy&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dog: &#123;&#125;&quot;</span>, Dog::<span class="hljs-title function_ invoke__">baby_name</span>()); <span class="hljs-comment">// 输出 “Dog: spot”</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Animal: &#123;&#125;&quot;</span>, &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">baby_name</span>()); <span class="hljs-comment">// 输出 “Animal: puppy”</span><br>&#125;<br></code></pre></td></tr></table></figure><p>完全限定语法：<Type as Trait>::function()</p><p>使用supertrait来要求trait附带其他trait的功能：需要在一个trait中使用其他trait的功能： 1、需要被依赖的triat也被实现2、那个被间接依赖的trait就是当前trait的supertrait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">OutlinePrint</span>: fmt::Display &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">outline_print</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = output.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">4</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;* &#123;&#125; *&quot;</span>, output);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">4</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y)<br>    &#125;<br>&#125;<br>    <br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">OutlinePrint</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>使用newtype模式在外部类型上实现外部trait：1、孤儿规则：只有当trait或类型定义在本地包时，才能为该类型实现这个trait2、可以通过newtype模式来绕过这一规则： 利用tuplestruct创建一个新的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::&#123;<span class="hljs-keyword">self</span>, write&#125;;<br><br><span class="hljs-comment">//把vec包裹在wrapper中，可以实现display这个trait</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;[&#123;&#125;]&quot;</span>,<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;, &quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = <span class="hljs-title function_ invoke__">Wrapper</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>)]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;w = &#123;&#125;&quot;</span>, w);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级类型">高级类型</h2><p>使用newtype模式实现类型安全和抽象： newtype模式可以：1、用来静态地保证各种值之间不会混淆并表明值的单位2、为类型的某些细节提供抽象能力3、通过轻量级的封装来隐藏内部实现细节</p><p>使用类型别名创建类型同义词： 1、rust提供了类型别名的功能：为现有类型生产另外的名称 并不是一个独立的类型 使用type关键字2、主要用途：较少代码字符重复输入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Kilometers</span> = <span class="hljs-type">i32</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: Kilometers = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Thunk</span> = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_long_type</span>(f: Thunk) &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Error;<span class="hljs-comment">//错误的类型的通称</span><br><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-comment">//type Result&lt;T&gt; = std::result::Result&lt;T, Error&gt;;这个已经声明在std::io::Result&lt;T&gt;了</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = std::io::<span class="hljs-type">Result</span>&lt;T&gt;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Write</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">Write</span>(&amp;<span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">usize</span>&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">flush</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_all</span>(&amp;<span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">write_fmt</span>(&amp;<span class="hljs-keyword">self</span>, fmt: fmt::Arguments) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>Never类型： 1、有一个名为!的特殊类型： 它没有任何值，空类型也称Never类型，因为它在不返回的函数中充当返回类型2、不返回值的函数也称作发散函数（Never类型可以是continue，可以是panic）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span> = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>            <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Sized trait: 为了处理动态大小的类型：rust提供了一个Sizedtriat来确定一个类型的大小在编译时是否已知：1、编译时可计算出大小的类型会自动实现这个trait2、rust还会为每一个泛型函数隐式地添加Sized约束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T&gt;(t: T) &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: <span class="hljs-built_in">Sized</span>&gt;(t: T) &#123;&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，泛型函数只能用于编译时已经知道大小的类型，可以通过特殊语法解除这一限制</p><p>即?Sized trait约束：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T&gt;(t: T) &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: <span class="hljs-built_in">Sized</span>&gt;(t: T) &#123;&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;<span class="hljs-comment">//可能不是Sized也可能是</span><br></code></pre></td></tr></table></figure><h2 id="高级函数和闭包">高级函数和闭包</h2><p>函数指针： 1、可以将函数传递给其他函数2、函数在传递过程中会被强制转换成fn类型 3、fn类型就是“函数指针”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_one</span>(x: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">do_twice</span>(f: <span class="hljs-title function_ invoke__">fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>, arg: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-title function_ invoke__">f</span>(arg) + <span class="hljs-title function_ invoke__">f</span>(arg)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">answer</span> = <span class="hljs-title function_ invoke__">do_twice</span>(add_one, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,answer);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数指针与闭包的不同：1、fn是一个类型，不是一个trait：可以直接指定fn为参数类型，不用声明一个以Fntrait为约束的泛型参数 2、函数指针实现了全部3中闭包trait：总是可以把函数指针作为参数传递给一个接受闭包的函数所以，倾向于搭配闭包trait的泛型来编写函数，可以同时接收闭包和普通函数3、某些情景，只想接收fn而不接收闭包：与外部不支持闭包的代码交互：C函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_numbers</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_strings</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = list_of_numbers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|i| i.<span class="hljs-title function_ invoke__">to_string</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_numbers</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_strings</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = list_of_numbers.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(<span class="hljs-built_in">ToString</span>::to_string).<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>        <span class="hljs-title function_ invoke__">Value</span>(<span class="hljs-type">u32</span>),<br>        Stop,<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Status::<span class="hljs-title function_ invoke__">Value</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list_of_statuses</span>:<span class="hljs-type">Vec</span>&lt;Status&gt; = (<span class="hljs-number">0u32</span>..<span class="hljs-number">20</span>)<br>        .<span class="hljs-title function_ invoke__">map</span>(Status::Value)<br>        .<span class="hljs-title function_ invoke__">collect</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>返回闭包：闭包使用trait进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该trait的具体类型作为返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/*fn return_closure() -&gt; Fn(i32) -&gt; i32 &#123;</span><br><span class="hljs-comment">    |x| x + 1</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_closure</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|x| x + <span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="类型转换">类型转换</h1><h2 id="as">as</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">average</span>(values: &amp;[<span class="hljs-type">f64</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">total</span> = values.<span class="hljs-title function_ invoke__">iter</span>().sum::&lt;<span class="hljs-type">f64</span>&gt;();<br>    (total / values.<span class="hljs-title function_ invoke__">len</span>() <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="as_mut">as_mut</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">num_sq</span>&lt;T: <span class="hljs-built_in">AsMut</span>&lt;<span class="hljs-type">u32</span>&gt;&gt;(arg: &amp;<span class="hljs-keyword">mut</span> T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span>&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Implement the function body.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = *arg.<span class="hljs-title function_ invoke__">as_mut</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">squared</span> = num * num;<br>    *arg.<span class="hljs-title function_ invoke__">as_mut</span>() = squared;<br>    squared<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="as_bytes">as_bytes()</h2><p>将字符串转换为一个字符数组（&amp;[u8]）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_bytes</span> = <span class="hljs-type">str</span>.<span class="hljs-title function_ invoke__">as_bytes</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="as_ptr">as_ptr()</h2><p>将目标转换为指针</p><p>例子：将C字符串转换为*const c_char</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> libc;<br><span class="hljs-keyword">use</span> std::ffi:CString;<br><span class="hljs-keyword">use</span> libc::c_char;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = CString::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>:*<span class="hljs-keyword">const</span> c_char = a.<span class="hljs-title function_ invoke__">as_ptr</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="as_mut_ptr">as_mut_ptr()</h2><p>将目标转换为可变指针</p><h1 id="文件系统">文件系统</h1><h2 id="结构体">结构体</h2><h3 id="pathbuf">PathBuf</h3><p>用于操作路径的结构体，它提供了方便的方法来构建、操作和转换文件系统路径</p><p>定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PathBuf</span> &#123;<br>    inner: OsString,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OsString</span> &#123;<br>    inner: Buf,<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::path::PathBuf;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">path</span> = PathBuf::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-comment">//添加路径</span><br>    path.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&quot;dir&quot;</span>);<br>    <span class="hljs-comment">//path.push(&quot;dir1&quot;);</span><br>    path.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&quot;file.txt&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Path: &#123;&#125;&quot;</span>, path.<span class="hljs-title function_ invoke__">display</span>());<span class="hljs-comment">//dir\file.txt</span><br><br>    <span class="hljs-comment">//在路径添加扩展名</span><br>    path.<span class="hljs-title function_ invoke__">set_extension</span>(<span class="hljs-string">&quot;dat&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Path: &#123;&#125;&quot;</span>, path.<span class="hljs-title function_ invoke__">display</span>());<span class="hljs-comment">//dir\file.dat</span><br><br>    <span class="hljs-comment">//获取路径的父目录</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(parent) = path.<span class="hljs-title function_ invoke__">parent</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Parent directory: &#123;&#125;&quot;</span>, parent.<span class="hljs-title function_ invoke__">display</span>());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;No parent directory found&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将路径转换为字符串</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">path_str</span> = path.<span class="hljs-title function_ invoke__">to_str</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Path as string: &#123;&#125;&quot;</span>,path_str);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="path">Path</h3><p>定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Path</span> &#123;<br>    inner: OsStr,<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OsStr</span> &#123;<br>    inner: Slice,<br>&#125;<br></code></pre></td></tr></table></figure><p>创建：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">path</span> = Path::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="输入输出-1">输入输出</h2><h3 id="一些重命名">一些重命名</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = result::<span class="hljs-type">Result</span>&lt;T, Error&gt;;<br></code></pre></td></tr></table></figure><h1 id="优化相关">优化相关</h1><h2 id="编译器相关">编译器相关</h2><h3 id="coreintrinsicsunlikely">core::intrinsics::unlikely</h3><p>是一个用于指示编译器优化的内置函数(intrinsc)。它用于标记条件分支的分支预测，提示编译器某个分支的执行效率较低，以便编译器在生成机器代码时进行优化，使得执行效率高的分支更可能处于CPU流水线的“预取阶段”</p><p>当某一个执行效率明显高于另一个时，使用unlikely可以帮助编译器生成更优化的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">unsafe</span> &#123; core::intrinsics::<span class="hljs-title function_ invoke__">unlikely</span>(condition) &#125; &#123;<br>    <span class="hljs-comment">// 条件为假的情况</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 条件为真的情况</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个unsafe函数。</p><h1 id="属性">属性</h1><h2 id="debug">debug</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[drive(Debug)]</span><br></code></pre></td></tr></table></figure><p>为结构体自动生成dubugtrait的实现，可以使得结构体使用"println!("{:?}",locked_inode)等宏来打印调试信息</p><h1 id="内存管理">内存管理</h1><h2 id="弱引用">弱引用</h2><p>定义：弱引用不会阻止被引用对象被回收，如果被引用对象只有弱引用指向它，则可以自由地释放这个对象，即使还有弱引用指向它，因为弱引用==不会增加引用计数==。</p><p>功能：解决循环引用导致的内存泄漏问题，由于两个对象互相引用造成了循环引用，无法判断对象是否可以被释放</p><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Weak&#125;;<br><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    next: RefCell&lt;<span class="hljs-type">Option</span>&lt;Weak&lt;Node&gt;&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">node1</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>        next: RefCell::<span class="hljs-title function_ invoke__">new</span>(Nonw),<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">node2</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>        next: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">None</span>),<br>    &#125;);<br><br>    *node1.next.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;node2));<br>    *node2.next.<span class="hljs-title function_ invoke__">borrow_mut</span>() = <span class="hljs-title function_ invoke__">Some</span>(Arc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;node1));<br>    <span class="hljs-comment">//如果没有其他强引用指向它们，它们会被释放</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：确保不会在没有强引用的情况下使用弱引用指向的对象，否则可能会出现空指针错误</p><h2 id="原子引用计数">原子引用计数</h2><p>功能：用于在多线程环境中共享数据的所有权，提供一种安全地在多线程之间共享数据所有权的方式</p><p>引用计数：当Arc的引用计数为0时，它会释放内部数据并销毁自身。</p><p>内部可变性：与Rc类似，Arc不能提供内部可变性，如果需要在多线程环境下修改数据，可以使用Mutex、RwLock等同步原语结合Arc使用</p><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sycn::Arc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">data</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">3</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">data_clone</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;data);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Thread &#123;&#125;: &#123;:?&#125;&quot;</span>,i,data_clone);<br>        &#125;)<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>入门笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的STL</title>
    <link href="/2024/12/29/C-%E4%B8%AD%E7%9A%84STL/"/>
    <url>/2024/12/29/C-%E4%B8%AD%E7%9A%84STL/</url>
    
    <content type="html"><![CDATA[<h1 id="stl">STL</h1><h2 id="vector">vector</h2><p><strong>特点：</strong></p><ul><li>底层结构：由动态数组实现，特点是存储空间连续</li><li>访问遍历：支持随机访问，可使用下标访问，访问时间复杂度为O(1)</li><li>插入/删除：尾部插入/删除效率较高；中间和头部插入/删除效率较低，因为存储空间是连续的，插入后需要改变元素顺序</li><li>空间效率：底层实现时，会事先预留一些额外空间，以减少重新分配的次数</li><li>使用场景：需要随机访问且频繁在尾部进行操作的场景；如果频繁增删元素则不适用该容器</li></ul><p><strong>实现原理：</strong></p><p>std::vector内部维护一个动态数组，当容量不足以容纳新元素时，std::vector会分配更大的内存空间，并将现有元素复制到新的存储空间。新容量通常是旧容量的两倍，以减少频繁的内存分配和拷贝操作</p><h2 id="deque">deque</h2><p><strong>特点：</strong></p><ul><li>底层结构：由双向队列实现，特点是存储空间连续</li><li>访问遍历：支持随机访问，其性能比vector要低</li><li>插入/删除：尾部和头部插入/删除效率较高；中间插入/删除时间效率较低，但比vector高效一些</li><li>空间效率：底层实现时比vector的结构更复杂，也会事先预留一些额外空间，以减少重新分配的次数</li><li>使用场景：需要随机访问且频繁在头部和尾部进行操作的场景；如果频繁在中部增删元素则不适用该容器</li></ul><p><strong>实现原理：</strong></p><p>std::queue是一个双端队列，支持在两端快速插入和删除。内部使用分段存储结构，，而不是一个连续的大块内存。这使得在两端的插入和删除更加高效。使用一个指针管理这些块，并在需要时动态调整指针数组的大小</p><h2 id="list">list</h2><p><strong>特点：</strong></p><ul><li>底层结构：由双向链表实现，特点是存储空间不连续</li><li>访问遍历：不支持随机访问，只能通过迭代器进行访问</li><li>插入/删除：任意位置插入/删除效率都很高</li><li>空间效率：每个元素都需要分配额外的空间</li><li>使用场景：需要在任意位置频繁插入/删除操作的场景</li></ul><p><strong>实现原理：</strong></p><p>std::list是一个双向链表，包含节点，每个节点包含一个数据元素和两个指针，分别指向前一个和后一个节点。每次插入或删除节点时，都会进行动态内存分配和释放</p><h2 id="set">set</h2><p><strong>特点：</strong></p><ul><li>底层结构：由红黑树实现，是一种平衡二叉搜索树，存储空间不连续</li><li>访问遍历：不支持随机访问，只能通过迭代器进行访问</li><li>插入/删除：查询/插入/删除效率为O(log N)复杂度</li><li>排序方式：默认使用less仿函数，即&lt;运算符进行排序；也可以自定义排序规则仿函数</li><li>使用场景：需要有序集合且元素不重复的场景</li></ul><h2 id="multiset">multiset</h2><p><strong>特点：</strong></p><ul><li>底层结构：由红黑树实现，是一种平衡二叉搜索树，存储空间不连续</li><li>访问遍历：不支持随机访问，只能通过迭代器访问</li><li>插入/删除：查询/插入/删除效率为O(log N)复杂度</li><li>排序方式：默认使用less仿函数，即&lt;运算符进行排序；也可以自定义排序规则仿函数</li><li>使用场景：需要有序集合且元素<strong>重复</strong>的场景</li></ul><h2 id="map">map</h2><p><strong>特点：</strong></p><ul><li>底层结构：由红黑树实现，是一种平衡二叉搜索树，存储空间不连续</li><li>访问遍历：不支持随机访问，只能通过迭代器进行访问</li><li>插入/删除：查询/插入/删除效率为O(log N)复杂度</li><li>排序方式：默认使用less仿函数，即&lt;运算符进行排序‘；也可以自定义排序规则的仿函数</li><li>使用场景：需要有序键值对且键值不重复的场景</li></ul><h2 id="multimap">multimap</h2><p><strong>特点：</strong></p><ul><li>底层结构：由红黑树实现，是一种平衡二叉搜索树，存储空间不连续</li><li>访问遍历：不支持随机访问，只能通过迭代器进行访问</li><li>插入/删除：查询/插入/删除效率为O(log N)复杂度</li><li>排序方式：默认使用less仿函数，即&lt;运算符进行排序‘；也可以自定义排序规则的仿函数</li><li>使用场景：需要有序键值对且键值<strong>重复</strong>的场景</li></ul><h2 id="emplace_back和push_back">emplace_back和push_back</h2><p><strong>概述：</strong> 二者的功能都是向容器尾部添加新元素</p><p><strong>区别：</strong></p><ul><li>push_back：先创建临时对象，然后再拷贝复制到对应的内存，再删除临时对象，效率较低</li><li>emplace_back：直接在内存处创建对象，效率较高</li></ul><blockquote><p>在代码中能用emplace_back就用emplace_back</p></blockquote><h2 id="unordered_map-vs.-map">unordered_map vs. map</h2><p><strong>底层数据结构：</strong></p><ul><li>unordered_map：基于哈希表实现，元素没有排序，键值对的顺序是随机的。在内部，哈希表将键值分配到不同的bucket中，元素的顺序取决于它们的哈希值</li><li>map：基于红黑树（一种近似平衡的二叉查找树）实现，元素按键排序，支持有序的遍历。</li></ul><p><strong>插入和查找时间复杂度：</strong></p><ul><li>unordered_map：平均时间复杂度是O(1)，在大量哈希冲突的情况下，复杂度会退化到O(n)</li><li>map：时间复杂度为O(log n)，因为每次操作都涉及红黑树的自平衡</li></ul><p><strong>内存开销：</strong></p><ul><li>unordered_map：哈希表的实现需要更多内存来存储bucket和哈希表。哈希表大小是动态调整的，以减少哈希冲突的影响，可能因为内存重新分配导致一定的内存浪费</li><li>map：基于红黑树实现，每个元素存储的开销相对较大，因为每个节点需要存储指向左右子节点、父节点的指针，但是总体内存开销可能比unordered_map低</li></ul><p><strong>键的比较方式：</strong></p><ul><li>unordered_map：键的比较通过哈希函数进行，默认情况下标准库为常见类型提供了哈希函数</li><li>map：键的比较通过operator&lt;（或自定义的比较器）来进行，要求键类型必须是可比较的</li></ul><p><strong>std::unordered_map示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, string&gt; um;<br>    um[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br>    um[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;<br>    um[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br><br>    <span class="hljs-comment">// 元素的顺序是随机的</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : um) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>std::map示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, string&gt; m;<br>    m[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;one&quot;</span>;<br>    m[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;two&quot;</span>;<br>    m[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;three&quot;</span>;<br><br>    <span class="hljs-comment">// 元素会按照键升序排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : m) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ul><li>unordered_map：适用于快速查找和快速插入操作的场景，顺序无关紧要，只关心查找效率</li><li>map：适用于需要按键排序的场景，例如查找范围、按顺序遍历等情况。需要保证有序的插入和删除。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的concept</title>
    <link href="/2024/12/28/C-%E4%B8%AD%E7%9A%84concept/"/>
    <url>/2024/12/28/C-%E4%B8%AD%E7%9A%84concept/</url>
    
    <content type="html"><![CDATA[<h1 id="concept">concept</h1><p><strong>概述：</strong>是C++20引入的新机制，旨在提供一种类型约束机制，使得模板的使用更加直观、可读且类型安全</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 定义concept</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Incrementable = <span class="hljs-built_in">requires</span>(T x) &#123;<br>    &#123; ++x &#125; -&gt; std::same_as&lt;T&amp;&gt;;  <span class="hljs-comment">// 确保类型 T 支持自增操作并返回 T&amp;</span><br>    &#123; x++ &#125; -&gt; std::same_as&lt;T&gt;;   <span class="hljs-comment">// 确保类型 T 支持后置自增操作并返回 T</span><br>&#125;;<br><br><span class="hljs-comment">// 使用定义的concept来约束模板参数</span><br><span class="hljs-keyword">template</span> &lt;Incrementable T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(T&amp; x)</span> </span>&#123;<br>    ++x;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">increment</span>(a); <span class="hljs-comment">// 有效，支持int自增操作</span><br><br>    <span class="hljs-comment">// std::string b = &quot;hello&quot;;</span><br>    <span class="hljs-comment">// increment(b); // 编译错误，不支持自增操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见的内建concept：</strong></p><ul><li>std::integral：表示整数类型（如int，long等）</li><li>std::floating_point：表示浮点类型（如float、double等）</li><li>std::same_as：检查两个类型是否相同</li><li>std::convertible_to：检查一个类型是否可以转换为另一个类型</li><li>std::invocable：检查类型是否可以被调用（如函数对象）</li><li>std::signed_integral：表示带符号整数类型</li><li>std::unsigned_integral：表示无符号整数类型</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;std::integral T&gt;<br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 有效，int是integral类型</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; add(5.5, 10.5) &lt;&lt; std::endl; // 编译错误，double不是integral类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>概念的组合：</strong></p><p>concept还可以通过逻辑运算符组合，创建更复杂的类型约束：</p><ul><li>&amp;&amp;：要求类型同时满足多个条件</li><li>||：要求类型满足至少一个条件</li><li>!：要求类型不满足这个条件</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Addable = <span class="hljs-built_in">requires</span>(T a, T b) &#123;<br>    &#123; a + b &#125; -&gt; std::same_as&lt;T&gt;; <span class="hljs-comment">// 必须支持加法运算</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Incrementable = <span class="hljs-built_in">requires</span>(T x) &#123;<br>    &#123; ++x &#125; -&gt; std::same_as&lt;T&amp;&gt;;  <span class="hljs-comment">// 确保类型 T 支持自增操作并返回 T&amp;</span><br>    &#123; x++ &#125; -&gt; std::same_as&lt;T&gt;;   <span class="hljs-comment">// 确保类型 T 支持后置自增操作并返回 T</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> IncrementableAddable = Incrementable&lt;T&gt; &amp;&amp; Addable&lt;T&gt;;<br><br><span class="hljs-keyword">template</span> &lt;IncrementableAddable T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">incrementAndAdd</span><span class="hljs-params">(T&amp; x, T y)</span> </span>&#123;<br>    ++x;<br>    x = x + ;y;<br>    std::cout &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">incrementAndAdd</span>(a, <span class="hljs-number">10</span>); <span class="hljs-comment">// 有效</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>concept</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的完美转发</title>
    <link href="/2024/12/28/C-%E4%B8%AD%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    <url>/2024/12/28/C-%E4%B8%AD%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="完美转发">完美转发</h1><p><strong>背景：</strong></p><p>C++的参数传递常常面临以下问题：</p><ul><li>左值和右值：左值和右值在处理上有区别，通常左值被传递时需要按值传递，而右值可能会被按引用传递以避免不必要的拷贝</li><li>引用折叠(ReferenceCollapsing)：C++中的引用折叠规则（T&amp;&amp;类型的引用会折叠成不同的类型）也会影响完美转发的实现</li></ul><p><strong>需求：</strong></p><p>在模板函数中，参数的类型和值类别（如左值、右值）可能不确定。如果直接传递这些参数，可能会遇到不必要的拷贝、资源丢失或类型不匹配的问题。完美转发就是为了解决这个问题，保持传递给这个函数的参数类型和值类别不变地转发到另一个函数。</p><p><strong>实现方法：</strong></p><p>C++11引入了右值引用(T&amp;&amp;)和std::forward，这些特性帮助我们实现完美转发</p><ul><li>右值引用(T&amp;&amp;)：允许我们捕获右值，并通过移动语义避免不必要的拷贝操作。</li><li>std::forward：作用是保持传递的参数的值类别，如果传入的是左值，则转发为左值；如果传入的是右值，则转发为右值。</li></ul><p>std::forward需要与T&amp;&amp;（通用引用，也叫转发引用）结合使用，通过引用折叠规则来决定是否保持右值引用或左值引用</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 普通函数，接受一个左值引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 普通函数，接受一个右值引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 完美转发函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forwardToPrint</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 下面这样直接传递会导致值类比的丢失</span><br>    <span class="hljs-comment">// print(arg);</span><br>    <span class="hljs-built_in">print</span>(std::forward&lt;T&gt;(arg));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br>    forwardToPrint(x); <span class="hljs-comment">// 传递左值</span><br>    forwardToPrint(<span class="hljs-number">100</span>); <span class="hljs-comment">// 传递右值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>T&amp;&amp;（通用引用）：这个引用可以绑定到任何类型的参数（左值或右值）</li><li>std::forward：在调用print时，使用std::forward来根据传入的参数值类别决定如何转发</li></ul><p><strong>完美转发避免了以下问题：</strong></p><ul><li>避免不必要的拷贝：如果传递的是右值，希望能够直接转发它以避免不必要的拷贝</li><li>避免资源丢失：如果传递的是右值，直接拷贝还会导致资源丢失（如动态分配的内存被拷贝而不再可用）</li></ul><p><strong>限制：</strong></p><ul><li>类型推导问题：如果错误地使用std::forward，可能会导致错误的类型推导，导致编译错误或逻辑错误</li><li>性能问题：虽然完美转发本身是为了避免不必要的拷贝，但如果转发链条过长，可能会引入一些性能开销</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>完美转发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的类型转换</title>
    <link href="/2024/12/26/C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/12/26/C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="类型转换">类型转换</h1><p><strong>概述：</strong> 将一个类型显式地转换为另一个类型的过程</p><p><strong>C风格的强制转换：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> iPi = (<span class="hljs-type">int</span>)pi;<br></code></pre></td></tr></table></figure><ul><li>不安全性：可能会导致一些隐式转换被执行，转换失败没有明显的错误提示</li><li>不推荐</li></ul><p><strong>static_cast（静态转换）：</strong></p><p>在编译时进行类型检查，比C风格强制转换更安全</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<br>ubt iPi = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(pi);<br></code></pre></td></tr></table></figure><p>适用于：</p><ul><li>基础类型之间的转换</li><li>对象之间的转换，前提是二者之间存在继承关系</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Base* base_ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-comment">// 基类指针转换为派生类指针</span><br>Derived* derivedPtr = <span class="hljs-keyword">static_cast</span>&lt;Derived*&gt; base;<br></code></pre></td></tr></table></figure><p>不能用于：</p><ul><li>指针/引用类型不相关，即不在继承体系中</li><li>跨不同类型的复杂转换（如将void* 转换为非void* 类型）</li></ul><p><strong>dynamic_cast（动态转换）：</strong></p><p>用于安全的运行时类型识别(RTTI)，尤其是在多态层次中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);<br><br><span class="hljs-keyword">if</span> (derived_ptr) &#123;<br>    <span class="hljs-comment">// 转换成功</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 转换失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>const_cast（常量转换）：</strong></p><p>用于添加或移除常量性。可以使用它来去掉对象的const或volatile限定符，或者将const指针转换为非const指针，他不会改变对象本身</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* y = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;x); <span class="hljs-comment">// 将const int* 转换为int*</span><br></code></pre></td></tr></table></figure><p><strong>reinterpret_cast（重解释转换）：</strong></p><p>是C++中的最强转换，直接将对象的内存表示解释为另一种类型。它通常用于指针之间的转换（包括将任意类型的指针转换为void*或其他类型的指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br><span class="hljs-type">char</span>* p = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;x);<br></code></pre></td></tr></table></figure><ul><li>无视类型的实际内容，跳过了类型的安全检查</li><li>不安全性</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>类型转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统期末复习笔记</title>
    <link href="/2024/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>推荐几个有关范式的教学视频：</p><ul><li><p><ahref="https://www.bilibili.com/video/BV1Sk4y1H7NK?vd_source=c1c5046dc0ade1491b819bc2614a0149">范式判断</a></p></li><li><p><ahref="https://www.bilibili.com/video/BV1Kc411k73b?vd_source=c1c5046dc0ade1491b819bc2614a0149">将R分解为BCNF</a></p></li><li><p><ahref="https://www.bilibili.com/video/BV1X94y1i7tA?vd_source=c1c5046dc0ade1491b819bc2614a0149">将R分解为3NF</a></p></li></ul><h1 id="关系代数">关系代数</h1><p><strong>概述：</strong>是数据库系统中的一种查询语言，用于对关系模型中的数据进行操作。它提供了一组操作，可以从关系（通常是表格）中派生出新的关系，关系代数是关系型数据库查询的基础之一，能够帮助DBMS(数据库管理系统)执行查询请求</p><h2 id="基本操作">基本操作</h2><p><strong>选择(Selection, σ)：</strong></p><p>选择操作从关系中筛选出满足特定条件的元组（记录）</p><ul><li><p>符号：<span class="math inline">\(σ_{条件}(R)\)</span></p></li><li><p>作用：从关系R中选择所有满足给定条件的元组</p></li><li><p>例子：假设有一个学生表，包含学生的姓名、年龄、成绩等信息，若要选择年龄大于20岁的学生，可以写成：<span class="math display">\[σ_{age}&gt;20\]</span></p></li></ul><p><strong>投影(Projection, π)：</strong></p><p>投影操作用于选择关系中的特性属性（列）</p><ul><li><p>符号：<spanclass="math inline">\(π_{属性列表}(R)\)</span></p></li><li><p>作用：从关系R中选择特定的属性列</p></li><li><p>例子：如果我们只对学生表中的姓名和成绩感兴趣，可以写成： <spanclass="math display">\[π_{name, score}(学生)\]</span> 这将返回一个新的关系，包含学生表中的姓名和成绩列</p></li></ul><p><strong>联接(Join, ⨝)：</strong></p><p>联接操作用于将两个关系中的元组结合起来，形成一个新的关系。常见的联接类型包括：</p><ul><li><p>内联接(Inner Join)：返回两个关系中所有匹配的元组</p></li><li><p>外联接(OuterJoin)：返回所有匹配的元组以及那些没有匹配的元组（根据不同的外联接类型，如左外联接、右外联接、全外联接，结果会有所不同）</p></li><li><p>符号：R ⨝ S</p></li><li><p>例子：假设有两个学生表（包含学生的姓名和学号）和选课（包含学生的学号和课程名称），要找出所有学生及其所选课程的信息：<span class="math display">\[学生⋈选课\]</span>这表示将学生表和选课表通过学号进行联接，返回包含学生姓名、学号、课程等信息的关系</p></li></ul><p><strong>并(Union, ∪)：</strong></p><p>并操作用于合并两个关系中的元组，要求两个关系具有相同的属性集合</p><ul><li><p>符号：R ∪ S</p></li><li><p>作用：返回两个关系中所有不同的元组（对行数据去重）</p></li><li><p>例子：如果有两个关系学生A和学生B，分别表示两个班级的学生信息，要求得到所有学生的集合：<span class="math display">\[学生A ∪ 学生B\]</span> 这表示将两个关系的元组合并，去除重复的学生信息</p></li></ul><p><strong>差(Difference, -)：</strong></p><p>差操作用于返回存在于第一个关系中但不在第二个关系中的元组</p><ul><li><p>符号：R - S</p></li><li><p>作用：返回关系R中存在但不在关系S中存在的元组</p></li><li><p>例子：如果学生A表示某班的学生，学生B表示已参加某考试的学生，那么：<span class="math display">\[学生A - 学生B\]</span> 这表示所有未参加考试的学生</p></li></ul><p><strong>笛卡尔积(Cartesian Product, ×)：</strong></p><p>笛卡尔积操作将两个关系中的所有元组进行组合，生成一个新的关系，新的关系中的每个元组由两个关系中的元组拼接而成</p><ul><li><p>符号：R × S</p></li><li><p>作用：返回两个关系中所有元组的组合</p></li><li><p>例子：假设有学生表和课程表，执行笛卡尔积会返回每个学生与每个课程的组合：<span class="math display">\[学生 × 课程\]</span> 如果学生表有3个学生，课程表有2门课程，结果将有6个元组</p></li></ul><p><strong>重命名(Rename, ρ)：</strong></p><p>重命名操作用于给关系或其属性命名：</p><ul><li><p>符号：<span class="math inline">\(ρ_{新名字}(R)\)</span></p></li><li><p>作用：给关系R重新命名</p></li><li><p>例子：可以给一个关系重新命名，如： <span class="math display">\[ρ_{新学生}(学生)\]</span> 这表示将学生表重命名为新学生</p></li></ul><h2 id="复合操作">复合操作</h2><p><strong>选择和投影的组合：</strong></p><p>假设要查询所有成绩大于80分的学生的姓名和成绩： <spanclass="math display">\[π_{name, score}(σ_{score&gt;80}(学生))\]</span> <strong>联接与其他操作的结合：</strong></p><p>假设要查询所有选了”数据库系统“课程的学生的姓名和成绩，可以使用联接与头因操作：<span class="math display">\[π_{name, score}(学生 ⨝ σ_{course=&quot;数据库系统&quot;}(选课))\]</span></p><h1 id="sql">SQL</h1><p><strong>概述：</strong>SQL(结构化查询语言)是用于与关系型数据库管理系统(RDBMS)进行交互的标准语言。主要用于操作数据库中的表，每个表由列和行组成。</p><h2 id="入门sql">入门SQL</h2><h3 id="数据查询select">数据查询(SELECT)</h3><p>SELECT是SQL中最常用的语句，用于从一个或多个表中检索数据</p><p><strong>查询所有列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><ul><li>*：表示所有列</li><li>table_name：要查询的表名称</li></ul><p><strong>查询特定列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2 <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><ul><li>只选择column1和column2这两列的数据</li></ul><p><strong>使用条件查询(WHERE)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> FORM table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ul><li><p>WHERE子句用来指定查询的条件</p></li><li><p>例如，查询所有年龄大于20岁的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure></li></ul><p><strong>排序查询结果(ORDER BY)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column_name [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>];<br></code></pre></td></tr></table></figure><ul><li><p>ORDER BY用来按照某一列对查询结果进行排序</p></li><li><p>默认是升序ASC，可以使用DESC表示降序</p></li><li><p>例如，按年龄升序排列学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure></li></ul><p><strong>限制查询结果(LIMIT)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT n;<br></code></pre></td></tr></table></figure><ul><li><p>LIMIT用于限制返回的记录数</p></li><li><p>例如，查询前5条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数据插入insert">数据插入(INSERT)</h3><p><strong>插入单条记录：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2) <span class="hljs-keyword">VALUES</span> (value1, value2);<br></code></pre></td></tr></table></figure><ul><li><p>例如向students表插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (name, age, score) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">90</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>插入多条记录：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2) <span class="hljs-keyword">VALUES</span> (value1, value2), (value3, value4);<br></code></pre></td></tr></table></figure><ul><li><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (name, age, score) <br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">88</span>), (<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">91</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="数据更新update">数据更新(UPDATE)</h3><p>用于更新表中已存在的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name <span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ul><li><p>例如：更新学生John的分数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> students <span class="hljs-keyword">SET</span> score <span class="hljs-operator">=</span> <span class="hljs-number">95</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>注意：WHERE子句非常重要，缺少WHERE会更新表中的所有记录</p></li></ul><h3 id="数据删除delete">数据删除(DELETE)</h3><p><strong>用于删除表中的记录：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure><ul><li><p>例如，删除年龄小于18岁的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure></li><li><p>如果没有WHERE子句，所有记录都会被删除</p></li></ul><h3 id="创建数据库和表">创建数据库和表</h3><p><strong>创建数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE database_name;<br></code></pre></td></tr></table></figure><ul><li><p>例如，创建一个名为school的数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE school;<br></code></pre></td></tr></table></figure></li></ul><p><strong>创建表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name &#123;<br>column1 datatype,<br>column2 datatype,<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>例如，创建一个学生表students：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> students (<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    age <span class="hljs-type">INT</span>,<br>    score <span class="hljs-type">FLOAT</span><br>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="修改表结构">修改表结构</h3><p>ALTER用于修改表结构，如添加、删除列等</p><p><strong>添加列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure><ul><li><p>例如，向student表添加 email列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students <span class="hljs-keyword">ADD</span> email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>删除列：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure><ul><li><p>例如，删除students表中的email列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> email;<br></code></pre></td></tr></table></figure></li></ul><h3 id="删除数据库和表">删除数据库和表</h3><p>DROP用于删除数据库中的表或数据库</p><p><strong>删除表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure><ul><li><p>例如，删除students表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> students;<br></code></pre></td></tr></table></figure></li></ul><p><strong>删除数据库：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE database_name;<br></code></pre></td></tr></table></figure><ul><li><p>例如，删除数据库school：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE school;<br></code></pre></td></tr></table></figure></li></ul><h3 id="基本的sql函数">基本的SQL函数</h3><ul><li><p>聚合函数：</p><ul><li><p>COUNT()：计算记录数</p></li><li><p>SUM()：计算列的总和</p></li><li><p>AVG()：计算列的平均值</p></li><li><p>MAX()：获取列的最大值</p></li><li><p>MIN()：获取列的最小值</p></li><li><p>例如，查询所有学生的平均成绩：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(score) <span class="hljs-keyword">FROM</span> students;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>字符串函数：</p><ul><li><p>CONCAT()：将多个字符串连接起来</p></li><li><p>UPPER()：将字符串转换为大写</p></li><li><p>LOWER()：将字符串转换为小写</p></li><li><p>例如，将学生姓名转换为小写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(name) <span class="hljs-keyword">FROM</span> students;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="多表查询">多表查询</h2><p><strong>概述：</strong> 也称联接查询，指的是在同一查询中，涉及两个或多个表的数据操作。多表查询通常用于获取存储在不同表中的相关数据，通过某种条件将它们关联起来，通过多表查询，可以实现更加复杂和灵活的数据提取需求。</p><h3 id="内联接inner-join">内联接(INNER JOIN)</h3><p><strong>概述：</strong>是最常见的多表查询类型，它返回的是两个表中满足联接条件的所有记录，如果某一表中没有匹配的记录，则该记录不会出现在查询结果中</p><p><strong>示例：</strong></p><p>假设有两个表students表和courses表，分别包含以下内容：</p><ul><li>students：student_id、name</li><li>courses：course_id、student_id、course_name</li></ul><p>要查询每个学生和他们所选的课程信息，可以使用INNER JOIN：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> students.name, courses.course_name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> courses<br><span class="hljs-keyword">ON</span> student.student_id <span class="hljs-operator">=</span> courses.student_id;<br></code></pre></td></tr></table></figure><p>解释：这条查询通过students.student_id和courses.student_id继续匹配，只返回那些在students和courses表中有对应记录的学生及课程</p><h3 id="外联接outer-join">外联接(OUTER JOIN)</h3><p><strong>概述：</strong>与内联接的不同之处在于，外联接返回的是所有匹配记录和不匹配的记录）可以进一步细分为三种类型：左外联接(LEFTJOIN)、右外联接(RIGHT JOIN)、全外联接(FULL OUTER JOIN)</p><p><strong>左外联接(LEFT JOIN)：</strong></p><p>左外联接返回左表（查询中的第一个表）中的所有记录，以及右表（查询中的第二个表）中与左表记录匹配的记录。如果右表没有匹配的记录，结果中的对应部分将显示为NULL</p><p>示例：假设想要查询所有学生的信息，以及他们是否选修了某些课程。如果没有选课的学生也需要显示，可以使用左外联接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> students.name, courses.course_name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> courses<br><span class="hljs-keyword">ON</span> students.student_id <span class="hljs-operator">=</span> courses.student_id;<br></code></pre></td></tr></table></figure><p>解释：如果某个学生没有选课，那么该学生的course_name将会显示为NULL，但仍会显示学生的name</p><p><strong>右外联接(RIGHT JOIN)：</strong></p><p>右外联接返回右表（查询中的第二个表）中的所有记录，以及左表（查询的第一个表）中与右表匹配的记录。如果左表没有匹配的记录，结果中对应部分将显示为NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> students.name, courses.course_name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> courses<br><span class="hljs-keyword">ON</span> students.student_id <span class="hljs-operator">=</span> courses.student_id;<br></code></pre></td></tr></table></figure><ul><li>解释：此查询返回所有课程及选修这些课程的学生，如果某个课程没有学生选修，则name列显示为NULL</li></ul><p><strong>全外联接(FULL OUTER JOIN)：</strong></p><p>全外联接返回左表和右表中的所有记录。如果某一边没有匹配的记录，另一边的列会显示为NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> students.name, courses.course_name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">FULL</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> courses<br><span class="hljs-keyword">ON</span> students.studetn_id <span class="hljs-operator">=</span> courses.student_id;<br></code></pre></td></tr></table></figure><ul><li>解释：这条查询返回所有学生和所有课程，如果学生没有选课或课程没有学生选修，则结果中相应部分会显示为NULL</li></ul><h3 id="笛卡尔积cartesian-product">笛卡尔积(CARTESIAN PRODUCT)</h3><p><strong>概述：</strong>笛卡尔积返回两个表中每个记录的组合，笛卡尔积并不基于任何联接条件，因此结果集可能非常庞大</p><p><strong>示例：</strong></p><p>假设有两个表：students表（包含3个学生）和courses表（包含2门课程），笛卡尔积的查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> students.name, courses.course_name<br><span class="hljs-keyword">FROM</span> students, courses;<br></code></pre></td></tr></table></figure><p>解释：这条查询会返回所有学生和所有课程的组合，结果为 3 * 2 = 6条记录，即每个学生都将与每门课程组合成一条记录。</p><h3 id="自联接self-join">自联接(SELF JOIN)</h3><p><strong>概述：</strong>自联接是一种特殊的联接，它用于将同一张表与自身进行联接，通常用于查询表中相互关联的数据。</p><p><strong>示例：</strong></p><p>假设employees表存储了员工信息，包括employee_id和manager_id，通过自联接查询员工及其经理的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e1.name <span class="hljs-keyword">AS</span> employee_name, e2.name <span class="hljs-keyword">AS</span> manager_name<br><span class="hljs-keyword">FROM</span> employees e1<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> employees e2<br><span class="hljs-keyword">ON</span> e1.manager_id <span class="hljs-operator">=</span> e2.employee_id;<br></code></pre></td></tr></table></figure><p>解释：这套查询将employees表与自身进行联接，e1代表员工，e2代表经理，通过manager_id和employee_id进行匹配，返回每个员工及其对应经理的姓名</p><h3 id="联合union">联合(UNION)</h3><p><strong>概述：</strong>联合是将两个或多个SELECT语句的结果合并成一个结果集。UNION会自动去重，如果需要保留重复数据，可以使用UNIONALL</p><p><strong>示例：</strong></p><p>假设有两个表students_2023和students_2024，分别存储2023年和2024年入学的学生信息，要查询所有学生的姓名，可以使用UNION：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> students_2023<br><span class="hljs-keyword">UNION</span> <br><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> students_2024;<br></code></pre></td></tr></table></figure><p>解释：这条查询会返回两个表中的所有学生姓名，并且去除重复的姓名。</p><h2 id="中级sql">中级SQL</h2><h3 id="子查询subquery">子查询(Subquery)</h3><p><strong>概述：</strong>子查询是嵌套在其他查询语句中的查询。它可以出现在SELECT、FROM、WHERE等子句中，通常用于过滤数据、计算聚合值或作为连接条件</p><p><strong>标量子查询：</strong></p><p>返回单一值，可以用在SELECT、WHERE或HAVING子句中</p><p>例如，查询每个学生的姓名及其选修课程的数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name,<br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> courses <span class="hljs-keyword">WHERE</span> courses.student_id <span class="hljs-operator">=</span> students.student_id) <span class="hljs-keyword">AS</span> course_count<br><span class="hljs-keyword">FROM</span> students;<br></code></pre></td></tr></table></figure><p>解释：这里的子查询返回每个学生选修课程的数量，并将其作为列course_count展示</p><p><strong>多行子查询：</strong></p><p>返回多行数据，常用于IN或EXISTS中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">WHERE</span> student_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> student_id <span class="hljs-keyword">FROM</span> courses <span class="hljs-keyword">WHERE</span> course_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Math&#x27;</span>);<br></code></pre></td></tr></table></figure><p>解释：该查询返回所有选修Math课程的学生姓名。子查询返回所有选修该课程的学生ID，然后在主查询中通过IN进行匹配</p><p><strong>多列子查询：</strong></p><p>返回多列数据，常用于WHERE子句中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">WHERE</span> (student_id, age) <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> student_id, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">&gt;</span> <span class="hljs-number">90</span>);<br></code></pre></td></tr></table></figure><p>解释：该查询返回所有年龄和分数大于90分的学生姓名</p><h3 id="联接进阶引用">联接进阶引用</h3><p><strong>自然联接(NATURAL JOIN)：</strong></p><p>根据两个表中具有相同列名的列自动进行联接，他会自动选择相同列名并按这些列进行联接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> departments;<br></code></pre></td></tr></table></figure><p>解释：NATURALJOIN会自动识别两个表中相同的列名进行联接。这个操作等效于执行INNERJOIN和选择相同列的条件。</p><p><strong>复合联接条件(Using Clause)：</strong></p><p>使用USING关键字来指定多个列作为联接条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.name, d.department_name<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">JOIN</span> departments d <span class="hljs-keyword">USING</span> (department_id);<br></code></pre></td></tr></table></figure><p>解释：USING用于指定两个表中需要联接的列，并且这些列必须具有相同的名字。在这种情况下，联接的条件是deparment_id</p><h3 id="聚合函数与分组group-by">聚合函数与分组(GROUP BY)</h3><p>GROUPBY用于将查询结果分组，并对每个组执行聚合函数（如COUNT、SUM、AVG、MIN、MAX）</p><p><strong>GROUP BY 和 HAVING：</strong></p><p>HAVING用于过滤分组后的结果，类似于WHERE，但是作用于聚合后的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, <span class="hljs-built_in">AVG</span>(salary)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(saraly) <span class="hljs-operator">&gt;</span> <span class="hljs-number">50000</span>;<br></code></pre></td></tr></table></figure><p>解释：这条查询会计算每个部分的平均工资，并仅返回平均工资大于50000的部门</p><p><strong>GROUP BY多列：</strong></p><p>你可以按多个列进行分组，这样可以获得更细致的统计结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department_id, job_title, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department_id, job_title;<br></code></pre></td></tr></table></figure><p>解释：该查询返回每个部门、职位的员工数量</p><h3 id="窗口函数window-functions">窗口函数(Window Functions)</h3><p><strong>概述：</strong>是一类特殊的聚合函数，它可以在查询结果集中为每一行计算一个值，而不需要像GROUPBY那样分组。常用的窗口函数包括ROW_NUMBER、RANK、DENSE_RANK、NTILE等。</p><p><strong>ROW_NUMBER()：</strong></p><p>为查询结果集中的每一行分配一个唯一的序号，通常用于分页查询或排名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, salary, <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rank<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p>解释：该查询返回员工的姓名、工资，并根据工资降序排列，每一行都有一个唯一的排名(rank)</p><p><strong>RANK()和DENSE_RANK()：</strong></p><p>RANK()和DENSE_RANK()用于生成排名，区别在于RANK()会跳过排名（例如，若有两个并列第一名，则第三名跳过），而DENSE_RANK()则不会跳过排名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, salary, <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> salary <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rank<br><span class="hljs-keyword">FROM</span> employees;<br></code></pre></td></tr></table></figure><p>解释：这条查询为每个员工计算排名，工资高的员工排名靠前。如果有员工的工资相同，他们的排名也会相同。</p><h3 id="事务控制">事务控制</h3><p><strong>概述：</strong>事务是指一组作为单一工作单元执行的SQL语句。在事务中，所有的操作要么都成功(COMMIT)，要么都失败并回滚(ROLLBACK)</p><p><strong>事务的基本操作：</strong></p><ul><li>BEGIN TRANSACTION：开始一个事务</li><li>COMMIT：提交事务，保存所有的修改</li><li>ROLLBACK：回滚事务，撤销事务中所有的修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">BEGIN</span> TRANSACTION;<br><br><span class="hljs-keyword">UPDATE</span> employees <span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> saraly <span class="hljs-operator">*</span> <span class="hljs-number">1.1</span> <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 如果没有问题，可以提交事务</span><br><span class="hljs-keyword">COMMIT</span>；<br><br><span class="hljs-comment">-- 如果出错了，回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><h3 id="视图view">视图(VIEW)</h3><p><strong>概述：</strong>视图是一个虚拟的表，它是一个包含SQL查询的命令查询。视图可以简化复杂查询的使用，提高查询的可读性和复用性</p><p><strong>创建视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> top_earning_employees <span class="hljs-keyword">AS</span> <br><span class="hljs-keyword">SELECT</span> name, salary<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span>;<br></code></pre></td></tr></table></figure><p>这条语句创建了一个视图，该视图返回所有年薪超过10w的员工信息</p><p><strong>查询视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> top_earning_employees;<br></code></pre></td></tr></table></figure><p>查询视图和查询普通表类似</p><p><strong>删除视图：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> top_earning_employees;<br></code></pre></td></tr></table></figure><h3 id="索引index">索引(Index)</h3><p><strong>概述：</strong>是提高查询性能的关键工具，它允许数据库更快速地查找数据，对于经常用作查询条件的列，可以创建索引</p><p><strong>创建索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_employee_name <span class="hljs-keyword">ON</span> employees (name);<br></code></pre></td></tr></table></figure><p>该索引加速了基于name列的查询</p><p><strong>删除索引：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX idx_employee_name;<br></code></pre></td></tr></table></figure><h2 id="高级sql">高级SQL</h2><h3 id="复杂查询与高级子查询">复杂查询与高级子查询</h3><p><strong>相关子查询(Correlated Subquery)：</strong></p><p>查询条件依赖于外部查询的数据，在执行时，每一行外部查询的记录都将触发一次子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> employees e<br><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary) <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> e.department_id);<br></code></pre></td></tr></table></figure><p>解释：查询薪水高于所在部门平均薪水的员工。子查询是依赖于外部查询的每一行员工的department_id 来计算该部门的平均薪水。</p><p><strong>多层子查询(Nested Subquery)：</strong></p><p>是嵌套的子查询，通常用于执行更复杂的计算或过滤</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> employees<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> department_id<br>                       <span class="hljs-keyword">FROM</span> departments<br>                       <span class="hljs-keyword">WHERE</span> department_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Sales&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p>解释：这条查询首先使用内层子查询查找名为 "Sales" 的部门的department_id，然后在外层查询中使用这个department_id`来查找所有属于该部门的员工。</p><h3 id="存储过程和触发器">存储过程和触发器</h3><p><strong>概述：</strong>它们可以封装复杂的逻辑，自动化任务或响应特定的事件。</p><p><strong>存储过程(Stored Procedure)：</strong></p><p>存储过程是一组预编译的SQL语句，可以在数据库中保存并反复调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> raise_salary(<span class="hljs-keyword">IN</span> dept_id <span class="hljs-type">INT</span>, <span class="hljs-keyword">IN</span> percentage <span class="hljs-type">DECIMAL</span>)<br><span class="hljs-keyword">BEGIN</span> <br><span class="hljs-keyword">UPDATE</span> employees<br><span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> salary <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">+</span> percentage)<br><span class="hljs-keyword">WHERE</span> department_id <span class="hljs-operator">=</span> dept_id;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>解释：这个存储过程根据部门ID和百分比增加该部门员工的薪水</p><p><strong>触发器(Trigger)：</strong></p><p>触发器是由特定事件（如插入、更新、删除）自动触发的SQL代码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> salary_update<br>AFTER <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> employees<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>IF NEW.salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">200000</span> <span class="hljs-keyword">THEN</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> salary_updates (employee_id, old_salary, new_salary)<br><span class="hljs-keyword">VALUES</span> (NEW.employee_id, OLD.salary, NEW.salary);<br>    <span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>解释：这个触发器会在员工的薪水更新后执行，若薪水超过200000，则将更改记录到salary_updates表中</p><h1 id="实体-关系模型">实体-关系模型</h1><p><strong>概述：</strong>ER模型是一种用于描述和设计数据库结构的概念模型。主要由实体、属性、关系三种基本元素组成，通过这些元素，我们能够直观地表示现实世界中数据的结构和它们之间的相互关系。</p><h2 id="实体entity">实体(Entity)</h2><p><strong>概述：</strong>是现实世界可以独立存在并能够被明确描述的对象，通常表示一个表格（关系）的实例。</p><p><strong>实体集(Entity Set)：</strong>由相同类型的实体组成的集合，例如所有的学生或员工可以构成一个实体集</p><p><strong>示例：</strong></p><ul><li>学生：一个学生实体可能包括学生的姓名、学号、年龄等信息</li><li>图书：一本书的实体可能包括书名、作者、ISBN编号等信息</li></ul><h2 id="属性attribute">属性(Attribute)</h2><p><strong>概述：</strong>是描述实体特征的数据项，它表示实体所拥有的某个具体特征或性质。属性通常用于详细描述实体，并且与实体的实例一一对应</p><p><strong>属性的分类：</strong></p><ul><li>简单属性(SimpleAttribute)：不能再进一步分解的属性。例如，”学生姓名“是简单属性</li><li>复合属性(CompositeAttribute)：由多个简单属性组成的属性。例如，地址可能由”街道“、“城市”、“邮政编码”等组成</li><li>多值属性(MultivaluedAttribute)：一个实体可以有多个值的属性。例如，学生的“电话号码”可能有多个</li><li>派生属性(DerivedAttribute)：可以从其他属性中计算得出的属性。例如，学生的“年龄”可以从出生日期计算得出</li></ul><p><strong>示例：</strong></p><ul><li>学生实体的属性：学号、姓名、出生日期、性别、地址</li><li>图书实体的属性：书名、作者、出版日期、ISBN</li></ul><h2 id="关系relationship">关系(Relationship)</h2><p><strong>概述：</strong>表示两个或多个实体之间的联系。关系通过实体之间的联系和约束表示为一个抽象的“关系”，来说明这些实体如何交互</p><p><strong>分类：</strong></p><ul><li>一对一关系(One-to-One,1:1)：一个实体集中的每个实体只与另一个实体集中的一个实体相关联。例如一个学生只能有一个身份证，反之一个身份证只能对应一个学生</li><li>一对多关系(One-to-Many,1:N)：一个实体集中的每个实体可以与另一个实体集中的多个实体相关联，但后者的每个实体只能与前者的一个实体相关联。例如，一个部门可以有多个员工，但每个员工只属于一个部门</li><li>多对多关系(Many-to-Many,M:N)：一个实体集中的每个实体可以与另一个实体集中的多个实体相关联。例如，学生和课程之间是多对多关系，一个学生可以选多门课程，一门课程可以有多个学生</li></ul><h2 id="er图">ER图</h2><p><strong>概述：</strong>是ER模型的图形化表示，通过图形化的方式描述实体、属性和关系，帮助设计人员更直观地理解和设计数据库。</p><p><strong>ER图的基本符号：</strong></p><ul><li>实体：用矩形表示</li><li>属性：用椭圆表示，并通过线连接到相应的实体</li><li>关系：用菱形表示，连接参与关系的实体</li><li>主键属性：用双椭圆表示</li><li>多值属性：用双椭圆表示</li></ul><p><strong>约束：</strong>用来限制数据的合法性和有效性。常见的约束有：</p><ul><li>基数约束(CardinalityConstraint)：描述实体之间的关系数量限制。例如，学生与课程的关系是多对多的，这意味着每个学生可以选多门课程，反之，每门课程也可以被多个学生选修</li><li>参与约束(ParticipationConstraint)：描述一个实体是否必须参与某个关系。它分为全参与和部分参与：<ul><li>全参与：表示实体必须参与某个关系</li><li>部分参与：表示实体可以参与，也可以不参与某个关系</li></ul></li></ul><p><strong>扩展：</strong></p><ul><li>弱实体(WeakEntity)：表示没有足够属性来唯一标识的实体。通常，弱实体依赖于一个或多个强实体来标识。例如，订单项(OrderItem)依赖于订单(Order)来唯一标识</li><li>继承(Inheritance)：表示实体集之间的继承关系，通常是在面向对象的数据库设计中使用。例如，一个员工实体可以是全职员工和兼职员工的父类，后者继承了前者的属性</li></ul><h1 id="数据库设计">数据库设计</h1><p><strong>目标：</strong></p><ul><li>提供高效的数据存取</li><li>保证数据的完整性和一致性</li><li>降低数据冗余</li><li>使数据库易于扩展和维护</li></ul><h2 id="设计过程">设计过程</h2><p><strong>需求分析：</strong>明确数据库需要存储什么样的数据，这些数据之间的关系是什么，如何使用这些数据</p><p><strong>概念设计(Conceptual Design)：</strong>从业务需求出发，抽象出一个全面的数据类型，并使用ER模型来描述数据和它们之间的关系</p><ul><li>实体集：定义要存储的主要数据对象</li><li>属性：定义每个实体的特性</li><li>关系：定义实体之间的联系</li></ul><p><strong>逻辑设计(Logical Design)：</strong>将概念设计转换为具体的数据库模型，通常是关系模型。逻辑设计的目标是确定如何将实体-关系模型（ER模型）转换为数据库的表结构。</p><p>步骤：</p><ul><li>实体转换为表格：每个实体集通常转换为一个数据库表（关系）。表的每一行代表一个实体实例，表的每一列代表实体的属性</li><li>关系转换为外键：实体之间的关系（如一对多、一对一、多对多）需要用外键(ForeignKey)来表示。例如，一个学生选修课程的关系可以用学生表的外键来表示学生与课程之间的关系。</li><li>规范化(Normalization)：规范化是关系模型中一种用于减少冗余数据和防止数据差异的过程。通过分解大表，确保表结构的高效性和一致性</li></ul><p>规范化：目的是减少数据冗余和数据异常，规范化有多个级别，常见的有：</p><ul><li>第一范式(1NF)：要求每个字段的值都是原子性的，即不可再分的</li><li>第二范式(2NF)：在1NF的基础上，要求表中的每个非主属性都完全依赖于主键</li><li>第三范式(3NF)：在2NF的基础上，要求表中的非主属性不依赖于其他非主属性</li><li>BCNF：是3NF的进一步强化，要求每个决定因素都是候选键</li></ul><p>在实际的设计中，有时为了优化查询性能，可以适当进行反规范化，即引入冗余数据来提升查询效率</p><p><strong>物理设计(Physical Design)：</strong>是将逻辑模型转换为实际的数据库实现。它关注如何优化数据存储和访问性能</p><ul><li>数据存储结构：确定数据在硬盘上的存储方式。选择适当的数据存储结构（例如B树、哈希表）和索引结构，以提高查询和更新的效率</li><li>索引(Index)：索引是加速查询操作的一种数据结构，它通过为表中的一列或多列创建索引，来提高查询速度。常见的索引类型有：<ul><li>单列索引：针对表中的单一列创建索引</li><li>复合索引：针对表中的多个列创建索引</li><li>唯一索引：确保某列的数据值是唯一的</li><li>全文索引：用于文本数据的全文搜索</li></ul></li><li>存储优化：选择合适的存储介质和存储方式（例如，表空间、分区、压缩等）来优化数据库性能</li><li>数据分区(Partitioning)：将大型表分割成较小的部分，以提高查询性能和数据库维护的效率，常见的分区方法有：<ul><li>范围分区(Range Partitioning)：根据数据范围将数据分区</li><li>哈希分区(Hash Partitioning)：根据数据值的哈希值进行分区</li><li>列表分区(List Partitioning)：根据预定义的值将数据分区</li></ul></li></ul><p><strong>数据库实施：</strong>涉及将设计好的数据库模型实现到实际的数据库管理系统中</p><ul><li>使用SQL语句创建数据库结构</li><li>输入数据并进行出测试</li><li>根据需求调整数据库结构和索引</li></ul><p><strong>数据库测试与优化：</strong></p><ul><li>查询优化：通过分析查询执行计划、索引涉及、表结构调整等来优化查询性能</li><li>数据完整性和一致性检查：确保数据遵循业务规则，并且在各种操作下保持一致性</li><li>事务管理和并发控制：确保多个事务在并发操作时不会引发数据冲突或不一致</li></ul><h2 id="关键概念">关键概念</h2><p><strong>超键、候选键、主键与外键：</strong></p><ul><li>超键(Superkey)：是一个属性集，能够唯一标识关系模式中的每一元组，可以包含冗余属性</li><li>候选键(CandidateKey)：是最小的超键，不能删除任何属性，否则无法我i一标识元组</li><li>主键：从候选键选出一个作为主键，表中的唯一标识符，用于唯一标识每一行数据，每个表只能有一个主键</li><li>外键：表中的字段，它引用另一个表的主键，表示两个表之间的关联。外键用于维护表之间的关系完整性</li></ul><p><strong>数据完整性约束(Data Integrity Constraints)：</strong>用来确保数据库中数据的准确性和可靠性的规则：</p><ul><li>实体完整性(Entity Integrity)：确保每个表都有唯一主键</li><li>参照完整性(ReferentialIntegrity)：确保外键字段的值在相关表中存在</li><li>域完整性(Domain Integrity)：确保字段的数据值符合预定义的域</li><li>用户定义完整性(User-DefinedIntegrity)：由用户自定义的规则或约束，通常用于表示业务逻辑</li></ul><p><strong>事务(Transaction)：</strong>是数据库操作的一个基本单位，由一组SQL语句组成，执行这些语句要保证原子性、一致性、隔离性和持久性(ACID属性)。在设计时，需要考虑事务的并发控制和数据一致性</p><h1 id="检索">检索</h1><h2 id="存储">存储</h2><h3 id="数据库存储结构">数据库存储结构</h3><p><strong>行(Tuple)：</strong></p><p>数据库中的一行数据称为行（在RDBMS中也叫元组或记录）。一行数据是按列存储的，每一列对应一个属性（字段）。行存储在页中，每个页可以存储多行</p><p><strong>页(Page)：</strong></p><p>数据库的基本存储单元是页（也叫块block），一个页通常由一块固定大小的内存或磁盘空间组成（常见大小为4KB、8KB、16KB等）。数据表、索引、以及其他数据库对象中的数据都是在页中存储的</p><ul><li>页头：包含一些元数据，例如页的标识符、页的类型（数据页、索引页等）、页的状态（已使用、空闲等）</li><li>数据区：实际存储数据的区域。每个页可以存储多行数据记录</li></ul><p><strong>文件(File)：</strong></p><p>多个页可以组成一个文件。数据库表、索引等对象通常由对应的文件，这些文件会存储数据记录、索引信息或其他数据库对象</p><h3 id="文件组织方式">文件组织方式</h3><p><strong>概述：</strong>指在物理存储介质上如何组织数据库文件以及如何高效地存储、访问这些文件。文件组织的不同方式影响到数据检索的速度和效率。</p><p><strong>堆组织(Heap Organization)：</strong></p><p>是最简单的文件组织方式，其中数据行是无序地插入到文件中的。每当有新纪录插入时，数据将直接追加到文件的末尾。</p><p>特点：</p><ul><li>简单、插入操作开销小</li><li>查询效率低</li><li>适用于数据量小或不常查询的场景</li></ul><p><strong>顺序组织(Sequential Organization)：</strong></p><p>是将数据行按照某个列的值进行排序，并且数据在文件中按照顺序存储。</p><p>特点：</p><ul><li>查询效率较高，特别是范围查询和按顺序检索</li><li>插入操作较慢，因为要保证数据顺序</li><li>删除操作可能导致空间碎片，需要定期整理</li><li>适用于查询中有大量范围检索或顺序扫描的场景</li></ul><p><strong>哈希组织(Hash Organization)：</strong></p><p>通过哈希函数将数据映射到一个预定大小的桶中。对于某些特定字段（如主键或其他唯一标识符），可以通过哈希算法来定位数据的位置</p><p>特点：</p><ul><li>查询效率高，特别是对于精确查找</li><li>不支持范围查询，因为哈希是无序的</li><li>插入和删除操作通常较为高效</li><li>遇到哈希冲突时，系统需要采取一定的冲突解决策略（如链式法、开放地址法）</li></ul><p><strong>B+树组织(B+ Tree Organization)：</strong></p><p>是一种多路平衡树，广泛应用于数据库索引的文件组织中。所有数据都存储在叶子节点中，而内部节点仅存储索引信息。B+树的叶子节点通过链表连接，支持高效的范围查询</p><p>特点：</p><ul><li>支持高效的查询、插入、删除操作，尤其适合于范围查询</li><li>适合处理大量数据，具有较好的平衡性，查询性能优良</li><li>支持动态更新，数据量增大时也能保持平衡</li></ul><p><strong>B树组织(B Tree Organization)：</strong></p><p>是一种多路平衡树，类似于B+树，不同之处在于，B树的内部节点也存储实际的数据记录</p><p>特点：</p><ul><li>支持高效的查找、插入和删除操作</li><li>不适合范围查询，因为数据存储在内部节点中</li><li>在某些情况下，由于数据存储在内部节点，B树的内存效率较差</li></ul><h3 id="索引">索引</h3><p><strong>概述：</strong>是提高数据库查询性能的关键技术，可以快速定位数据的位置</p><p><strong>聚焦索引(Clustered Index)：</strong></p><p>将数据表的物理存储顺序与索引顺序一致，表中的数据行按照索引的顺序存储。在一个表中，只能有一个聚焦索引</p><p>特点：</p><ul><li>查询性能高，尤其是范围查询</li><li>插入和删除操作可能导致索引的重排</li></ul><p><strong>非聚焦索引(Non-Clustered Index)：</strong></p><p>是指索引结构与数据表的存储顺序无关。索引记录中保存了数据表中记录的物理地址或主键值</p><p>特点：</p><ul><li>支持多个索引</li><li>查询速度较快，但比聚焦索引稍慢</li><li>插入和删除较快，因为数据的物理顺序不受影响</li></ul><p><strong>唯一索引(Unique Index)：</strong></p><p>确保某一列（或多列）中的值唯一，它在保证数据完整性的同时，也提高了查询速度</p><p>特点：</p><ul><li>适用于需要确保唯一性的字段，如主键、唯一约束等</li><li>提高查询效率，同时避免重复数据</li></ul><p><strong>全文索引(Full-text Index)：</strong></p><p>用于全文检索，特别适用于大规模文本数据的检索，它可以建立一个词汇表，映射每个单词的位置</p><p>特点：</p><ul><li>对于文本数据，尤其是内容查询非常高效</li><li>不适合结构化数据，通常用于文章、评论等文本内容的搜索</li></ul><h3 id="存储优化">存储优化</h3><p><strong>数据压缩：</strong> 通过减少存储空间来提高存储效率</p><ul><li>无损压缩：保证压缩后的数据可以完全恢复</li><li>有损压缩：通过丢弃一些冗余数据来减少存储空间</li></ul><p><strong>分区和分片：</strong></p><p>分区是将表的数据按某些标准（如日期、地理位置等）分割到多个物理文件中</p><p>分片是将数据库的不同部分（如不同的数据表或数据库）分散存储在不同服务器上</p><p><strong>缓存：</strong></p><p>DBMS会使用缓存（内存中的缓存或磁盘缓存）来加速对频繁访问数据的读取。通过使用高速缓存，可以显著减少磁盘IO操作，提高查询性能</p><h2 id="查询处理">查询处理</h2><p><strong>概述：</strong>负责将用户的查询请求转换为数据库能够执行的具体操作，并在尽可能高效的方式下执行查询。</p><h3 id="查询解析">查询解析</h3><p><strong>概述：</strong>将用户输入的查询转换为数据库能够理解的内部表示形式的过程。该过程由查询解析器(Parser)来执行。</p><p><strong>词法分析和语法分析：</strong></p><ul><li>词法分析(LexicalAnalysis)：将输入的SQL查询字符串分解成一系列的tokens，例如关键字、表名、列名、操作符等</li><li>语法解析(SyntaxAnalysis)：根据SQL的语法规则，将tokens组织成一个语法树或解析树。这一阶段会检查SQL查询的语法是否正确，并生成一个树形结构，表示SQL查询的结构化信息</li></ul><p><strong>生成查询树：</strong></p><p>是一个抽象语法树(AST)，表示查询的逻辑结构。</p><h3 id="查询优化">查询优化</h3><p><strong>概述：</strong> 为查询生成一个高效的执行计划</p><p><strong>查询执行计划：</strong></p><p>Query Execution Plan是数据库系统执行查询时所采用的具体步骤序列。执行计划包含了如何访问数据、如何连接不同表、如何执行操作（如排序、过滤等）等信息</p><p>常见的执行计划：</p><ul><li>选择(Selection)：从表中筛选出符合条件的行</li><li>投影(Projection)：选择需要显示的列</li><li>连接(Join)：将多个表的数据根据连接条件组合起来</li><li>排序(Sort)：对数据进行排序操作</li><li>聚合(Aggregation)：进行数据的汇总、分组等操作</li></ul><p><strong>查询优化的目标：</strong></p><p>最优执行计划通常具有以下特点：</p><ul><li>最小的IO成本：尽可能少地访问磁盘</li><li>最小的计算成本：尽可能少地进行计算，避免不必要的操作</li><li>最小的内存使用：尽量减少内存的使用量，避免内存溢出</li></ul><p><strong>查询优化策略：</strong></p><ul><li>选择谓词推送(Predicate Pushdown)：将查询中的过滤条件(WHERE子句)尽早地应用于数据，减少不必要的行的读取</li><li>投影谓词推动(Projection Pushdown)：将查询中的投影条件(SELECT子句)尽早地应用于数据，减少传递不必要的列</li><li>连接顺序优化(Join OrderOptimization)：确定连接多个表的最优顺序，不同的连接顺序可能会大幅度影响查询效率</li><li>索引使用：查询优化器可能会选择合适的索引来加速数据检索过程。通过使用索引，可以避免全表扫描，直接定位到需要的行。</li><li>视图合并（ViewMerging）：对于复杂查询，优化器可以考虑合并视图或子查询，避免不必要的中间结果。</li></ul><p><strong>代价估算：</strong></p><p>查询优化器会根据数据统计信息（如表的大小、列的基数、索引的选择性等）来估算执行不同计划的代价。通常，代价会以某种形式的成本度量（如CPU 时间、磁盘I/O、内存使用量等）来表示。优化器会选择代价最小的执行计划。</p><p><strong>启发式优化与成本基优化：</strong></p><ul><li>启发式优化：利用经验规则和启发式方法来生成和优化执行计划。启发式优化不考虑所有可能的执行计划，但通过一些简单规则来尽量提升性能。</li><li>成本基优化：通过详细计算不同执行计划的代价，并选择最优的执行计划。成本基优化通常需要对每个操作的代价进行估算，并选择代价最小的方案。</li></ul><h2 id="联接实现">联接实现</h2><h3 id="嵌套循环联接nested-loop-join-nlj">嵌套循环联接(Nested Loop Join,NLJ)</h3><p><strong>概述：</strong>是一种常用的数据库联接算法，特别适用于没有索引或者联接的列没有排序的情况</p><p><strong>主要步骤：</strong></p><ol type="1"><li>外层循环：选择一个表作为外层表，通常是较小的表，在外层循环中，逐行扫描外层表的每一行记录</li><li>内层循环：对于外层表中的每一行记录，扫描另一个表（内层表）的每一行记录</li><li>比较：对于外层表和内层表的每一对记录，执行连接条件的比较。</li></ol><p><strong>伪代码：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">for each row r1 in Table1:<br>for each row r2 in Table2:<br>if r1 and r2 satisfy the join condition:<br>ADD (r1, r2) to the result set<br></code></pre></td></tr></table></figure><h3 id="块嵌套循环联接block-nested-loop-join-bnlj">块嵌套循环联接(BlockNested Loop Join, BNLJ)</h3><p><strong>概述：</strong>是NLJ的改进算法，旨在减少内存的消耗并提高效率</p><p><strong>主要步骤：</strong></p><ol type="1"><li>分块：首先将关系R和S按照块大小B进行分块，确保每次扫描一个数据库可以完全加载到内存中</li><li>外层循环：从外部关系R中取出一个数据块</li><li>内存循环：<ul><li>对于每一个外部快，扫描内部关系S中的每个数据块</li><li>对内外两个块中的每对元组进行连接操作，找出符合联接条件的元组</li></ul></li></ol><p><strong>性能优化：</strong></p><ul><li>内存利用：BNLJ利用内存缓存多个块，减少了磁盘IO的频繁访问</li><li>减少IO操作：BNLJ通过加载数据块而不是单独的元组，显著减少了磁盘访问的次数</li></ul><h1 id="事务恢复">事务恢复</h1><p><strong>概述：</strong> 确保数据库出现故障时能够恢复到一致状态</p><h2 id="事务">事务</h2><p><strong>事务恢复的目标 ：</strong></p><ul><li>持久性(Durability)：即使发生故障，已提交的事务结果也不会丢失</li><li>原子性(Atomicity)：事务要么全部成功，要么完全不做更改。如果事务在执行过程中出现故障，数据库需要回滚(undo)事务操作，恢复到事务执行前的状态</li><li>一致性(Consistency)：事务应将数据库从一个一致的状态转换到另一个一致的状态。即使发生故障，事务执行后的状态应满足数据库的约束条件</li><li>隔离性(Isolation)：事务的执行不应受到其他事务的影响。恢复过程中，要保证正在执行的事务互不干扰</li></ul><p><strong>故障类型：</strong></p><ul><li>系统崩溃：如操作系统崩溃、硬件故障、突然断电等</li><li>媒体故障：如磁盘损坏，数据文件丢失</li><li>事务故障：事务在执行过程中由于逻辑错误、死锁等问题被中止或回滚</li><li>存储故障：如数据库日志损坏，导致恢复时缺少关键数据</li></ul><p><strong>事务日志(WAL)：</strong></p><p>日志的作用：记录了数据库操作的详细信息，包括每个事务的开始、提交和混滚操作，数据修改前后的值等。</p><p>日志格式：</p><ul><li>写操作日志：记录每个修改操作的详细信息，包括修改前的数据和修改后的数据</li><li>事务开始日志：记录了事务的启动，包括事务ID</li><li>事务提交日志：记录事务的提交，表示该事务的修改已持久化</li><li>事务回滚日志：记录事务的回滚，撤销该事务的所有修改</li></ul><p><strong>恢复的基本过程：</strong></p><ol type="1"><li>分析阶段：恢复系统会扫描日志文件，找出所有已经提交的事务，未提交的事务以及在故障发生前已执行的操作。</li><li>重做阶段(Redo)：系统会重新执行日志中已经提交的事务，确保所有已提交的事务操作已经持久化</li><li>回滚阶段(Undo)：系统会撤销所有未完成的事务（包括崩溃前已开始但未提交的事务），恢复它们开始前的状态。</li></ol><h2 id="并发控制">并发控制</h2><p><strong>概述：</strong>是指在多个事务并行执行时，确保它们能够互补干扰且不会破坏数据库的一致性和完整性的机制。</p><h3 id="问题">问题</h3><p><strong>丢失更新(Lost Update)：</strong></p><p>如果两个事务都读取同一数据并进行更新，且更新操作没有同步，就可能导致其中一个事务的更新被另一个事务的更新覆盖，造成数据丢失</p><p><strong>脏读(Dirty Read)：</strong></p><p>是指事务A读取了事务B修改但未提交的数据。如果事务B回滚，事务A就会读到无效数据。</p><p><strong>不可重复读(Non-repeatable Read)：</strong></p><p>发生在同一事务内多次读取相同数据时，由于其他事务修改了数据，导致读取到不同的值</p><p>举例：</p><ul><li>事务T1读取帐户余额为100</li><li>事务T2修改帐户余额为120并提交</li><li>事务T1再次读取帐户余额是，得到120，而第一次读取时是100</li></ul><p><strong>幻读(Phantom Read)：</strong></p><p>指的是同一事务内多次查询数据时，由于其他事务插入、删除或修改了数据，导致查询结果发生变化</p><p>举例：</p><ul><li>事务T1查询符合条件的帐户列表，结果是10个帐户</li><li>事务T2插入了一个新帐户并提交</li><li>事务T1再次查询时，发现结果是11个帐户</li></ul><h3 id="目标">目标</h3><p>主要目标时保障DBMS中的事务隔离性</p><p>事务的隔离性通常有4个级别：</p><ul><li><p>读未提交(ReadUncommited)：事务可以读取未提交事务的数据，容易出现脏读问题</p></li><li><p>读已提交(ReadCommited)：事务只能读取已提交事务的数据，但可能会出现不可重复读</p></li><li><p>可重复读(RepeatableRead)：事务在执行期间多次读取同一数据时，保证读取结果不变，防止不可重复读，但可能出现幻读</p></li><li><p>串行化(Serializable)：事务按照顺序串行执行，完全避免幻读、不可重复读和脏读，但性能最差</p></li></ul><h3 id="技术">技术</h3><p><strong>锁机制：</strong></p><p>锁的种类：</p><ul><li>共享锁(Shared Lock,S-Lock)：允许多个事务同时读取数据，但不允许修改。多个事务可以持有共享锁，但不能对数据进行修改</li><li>排他锁(Exclusive Lock,X-Lock)：事务在修改数据时需要获得排他锁，排他锁会阻止其他事务读取或修改相同的数据</li><li>意向锁(Intent Lock)：指示事务打算在某个粒度的数据上获得锁</li><li>悲观锁与乐观锁：悲观锁假设会发生冲突，因此通过加锁来避免；乐观锁假设冲突概率较低，通过版本控制或数据验证等方式来避免冲突</li></ul><p>锁的管理：</p><ul><li>两阶段锁协议(Twp-Phase Locking,2PL)：为了避免死锁，数据库系统通常要求事务在执行期间按一定顺序获取锁，并在事务结束前不释放任何锁，但是还是不能完全避免死锁</li><li>死锁：当两个或多个事务在持有锁的情况下等待对方释放锁时，便发生了死锁，解决死锁的方法包括：<ul><li>死锁检测：系统监控锁的状态，并通过算法发现死锁</li><li>死锁避免：通过资源分配策略（如银行家算法）避免死锁的发生</li><li>死锁恢复：当检测到死锁时，回滚某个事务以释放锁</li></ul></li></ul><p><strong>时间戳排序：</strong></p><p>通过为每个事务分配一个唯一的时间戳来控制事务的顺序，每个事务在执行时必须遵循一个全局的时间戳顺序，数据库根据事务的时间戳来判断对其他事务的影响</p><ul><li>时间戳排序的核心：如果事务T1时间戳早于事务T2，则事务T1必须先执行，T2必须等待</li><li>时间戳排序方法通过比较事务的读/写时间戳来确保不发生冲突。</li></ul><p><strong>多版本并发控制(MVCC)：</strong></p><p>MVCC通过为数据创建多个版本来避免锁的竞争。每当一个事务对数据进行修改时，数据库会为该数据创建一个新版本，而不会直接覆盖旧版本。其他事务仍然可以访问旧版本的数据，这样避免了对数据的阻塞。</p><ul><li>事务视图：MVCC通过维护每个事务可见的数据版本来实现并发控制</li><li>快照隔离(SnapshotIsolation)：在MVCC中，事务看到的是一个数据快照，保证事务在执行期间的数据一致性</li></ul><p><strong>乐观并发控制(Optimistic Concurrency Control,OCC)：</strong></p><p>假设事务之间不会发生冲突，因此事务执行时无需锁定数据，事务在执行结束后，通过检查数据是否被其他事务修改来决定是否提交。如果发生冲突，事务会回滚并重新执行</p>]]></content>
    
    
    <categories>
      
      <category>大学课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的模板元编程</title>
    <link href="/2024/12/23/C-%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/23/C-%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="模板元编程">模板元编程</h1><h2 id="简要介绍">简要介绍</h2><p><strong>模板：</strong>是C++提供的一种泛型编程工具，可以让函数和类在编译时根据类型参数进行实例化。</p><p><strong>模板元编程：</strong>核心思想是将计算推迟到编译时，利用模板递归、特化和偏特化等机制，进行类型推导、编译期计算和代码生成。这样可以减少运行时开销。</p><p><strong>基本技巧：</strong></p><ul><li>类型特化：根据不同类型提供不同的实现</li><li>递归模板：通过模板的递归实例化，在编译期进行计算</li><li>std::integral_constant：用于封装常量值，以便在编译时作为类型传递</li></ul><h2 id="基本例子">基本例子</h2><p><strong>计算阶乘：</strong>通过模板递归，可以在编译期间计算出一个数的阶乘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义一个递归模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N - <span class="hljs-number">1</span>&gt;::value;<br>&#125;;<br><br><span class="hljs-comment">// 特化阶乘终止条件</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Factorial of 5 is: &quot;</span> &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>编译时常量表达式：</strong>std::integral_constant是C++11引入的一个模板类，用于封装常量值，可以在编译时传递常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Non-integral type: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printType</span>(<span class="hljs-number">42</span>);<br>    <span class="hljs-built_in">printType</span>(<span class="hljs-number">3.14</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类型选择：</strong>std::conditional是C++11引入的一个模板类，它根据条件选择两种类型中的一种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> Type = <span class="hljs-keyword">typename</span> std::conditional&lt;std::is_integral&lt;T&gt;::value, <span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;::type;<br>    Type result = <span class="hljs-built_in">static_cast</span>&lt;Type&gt;(value);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printType</span>(<span class="hljs-number">42</span>);<br>    <span class="hljs-built_in">printType</span>(<span class="hljs-number">3.14</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模板特化：</strong>指的是对某个特定类型或特定类型组合提供模板的定制实现。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Generic template: &quot;</span> &lt;&lt; t &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 完全特化模板</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span> t) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Specialized template for int: &quot;</span> &lt;&lt; t &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 使用特化模板</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 使用通用模板</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模板偏特化：</strong>通常用于处理模板参数中的某些类型特征（比如说指针类型、数组类型等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostrea&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Generic template: &quot;</span> &lt;&lt; t &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T* t)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Template specialized for pointer type: &quot;</span> &lt;&lt; *t &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* p = &amp;a;<br>    <br>    <span class="hljs-built_in">func</span>(a); <span class="hljs-comment">// 使用通用模板</span><br>    <span class="hljs-built_in">func</span>(p); <span class="hljs-comment">// 使用偏特化模板</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数重载与模板特化/偏特化的区别：</strong></p><ul><li>函数重载：指的是为同一个函数名提供多个不同参数列表的实现。编译器根据传入参数的类型来选择合适的重载版本。函数重载是基于函数参数的类型和数量来选择执行哪个函数，而不涉及模板概念</li><li>模板特化/偏特化：是针对模板的类型参数进行定制，根据传入的类型来选择对应的模板实例化。</li></ul><h2 id="其他">其他</h2><p><strong>常用的模板元编程技巧：</strong></p><ul><li>类型列表(Type List)：一种用于存储多个类型的容器</li><li>SFINAE(Substitution Failure Is Not AnError)：一种技巧，通过使模板在不适用时失败，从而为某些类型提供特化版本</li></ul><p><strong>元编程工具：</strong></p><ul><li><p>std::enable_if：条件启用模板功能的一种方法</p></li><li><p>std::is_same：判断两个类型是否相同</p></li><li><p>std::tuple：一个可以容纳多个不同类型的容器，类似于vector，但每个元素可以是不同的类型</p></li><li><p>std::index_sequence：生成从0到N的整数序列，通常用于编写递归和展开参数包</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>模板元编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的虚函数和虚函数表</title>
    <link href="/2024/12/22/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    <url>/2024/12/22/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="虚函数和虚函数表">虚函数和虚函数表</h1><p><strong>动态多态：</strong>在程序运行时根据对象的实际类型确定调用哪个类的成员函数</p><p><strong>C++是如何实现动态多态的？</strong></p><p>通过虚函数实现的，为每一个包含虚函数的对象分配一个虚函数指针，这个虚函数指针指向一个放在常量区的虚函数表。在运行时运行到某个虚函数时，根据这个虚函数指针来找到对应的虚函数表，然后根据对应的这个函数的下标值在虚函数表中找到对应的虚函数来完成调用。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> B &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2024/12/22/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/image-20241221234919256.png" class=""><p><strong>内存布局相关：</strong></p><p>一个类多重继承了几个父类，就有几张虚函数表。一个类有几个虚函数表，一个类的对象就有几个虚函数指针。虚函数指针按照继承父类的顺序，从对象的首地址开始依次排布。</p><ul><li>单继承中：父类的虚函数在子类虚函数前面，按照声明顺序排序，共同形成一张表，如果子类有和父类相同的虚函数，会对父类的虚函数进行覆盖。</li><li>多继承中：子类和第一个继承的父类形成一张表，剩下的父类单独形成一个虚函数表，同样的，如果子类有和父类相同的虚函数，会对父类的虚函数进行覆盖。</li></ul><p><strong>析构函数为什么要是虚函数？</strong></p><p>由于基类的多态性，基类指针可以指向派生类对象，如果删除该基类指针，就会调用该指针指向的派生类析构函数，然后派生类析构函数又自动调用积累的析构函数，这样整个派生类对象就会被完全释放。</p><p>如果析构函数不被声明为虚函数，删除基类指针时只会调用基类的析构函数而不会调用派生类析构函数。</p><p><strong>构造函数可以是虚函数吗？</strong></p><p>不可以</p><ul><li>如果构造函数是虚函数，就需要通过虚函数表中对应的虚函数指针来调用，可是对象如果还没有实例化，也就没有内存空间，就没有虚函数指针了。</li><li>构造函数是自动调用的，不用通过父类的指针或者引用去调用，不需要将其设置为虚函数</li></ul><p><strong>虚函数和普通函数之间的区别：</strong></p><p>主要体现在多态的支持和调用方式上，虚函数是实现运行时多态（动态绑定）的核心机制</p><ul><li>绑定方式：<ul><li>虚函数：采用动态绑定，调用哪个函数由对象的实际类型决定。</li><li>普通函数：采用静态绑定，函数的调用在编译时就已经确定，不依赖于运行时的对象类型。</li></ul></li><li>性能差异：<ul><li>虚函数：调用比普通函数蛮，因为它需要通过虚表进行动态查找</li><li>普通函数：直接调用，不需要通过虚表，因此速度较快</li></ul></li><li>内存开销：<ul><li>虚函数：需要为每个对象增加一个虚函数表指针，该指针指向虚函数表，这个虚表包含了该类的虚函数的地址。增加了内存开销</li><li>普通函数：没有虚表，没有额外内存开销</li></ul></li></ul><p><strong>计算这个类的大小：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base1</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; (<span class="hljs-built_in">sizeof</span>(base1));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>int a通常占4个字节</li><li>char c通常占1个字节，但是有3个填充字节为了对齐虚表指针</li><li>虚表指针在64位系统中为8字节，在32位系统中为4字节</li></ul><p>所以32位系统为12字节，64位系统为16字节</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>虚函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的进程虚拟内存布局</title>
    <link href="/2024/12/20/C-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <url>/2024/12/20/C-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="进程虚拟内存布局">进程虚拟内存布局</h1><p><strong>进程虚拟内存布局：</strong></p><ul><li><p>.text（代码段）：存放的是程序源代码编译后的机器指令，是只读的。</p></li><li><p>.rodata（只读数据段）：存放的是程序中的只读数据，一般是程序里面的只读变量和字符串常量。</p></li><li><p>.data（数据段）：存放的是已经初始化了的全局静态变量和局部静态变量</p></li><li><p>.bss：存放的是未初始化的全局静态变量和局部静态变量</p></li><li><p>堆：一般由程序员分配释放，若程序员不释放，存放一些new创建出来的对象</p></li><li><p>栈：由编译器自动分配释放，存放函数的参数值，局部变量的值等</p></li><li><p>内核空间：是OS内存管理的一部分，用于存储和运行操作系统内核的代码和数据</p></li></ul><img src="/2024/12/20/C-%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/image-20241220160957674.png" class=""><p><strong>生命周期：</strong></p><ul><li>代码段：在程序加载到内存时被分配，并在程序结束时释放</li><li>数据段：与程序生命周期相同</li><li>堆：堆上的内存需要在运行时手动分配和释放，如果不手动释放，堆上内存在程序结束时，由系统释放</li><li>栈：离开它的作用域后由系统释放</li></ul><p><strong>栈和堆的区别：</strong></p><ul><li>内存分配方式不同：<ul><li>栈：栈上的内存是自动分配和释放的，通常用于存储函数调用过程中的局部变量、调用参数和使用的寄存器状态等信息。</li><li>堆：堆上的内存是动态分配的，程序在运行时可以根据需要分配和释放内存。在C++中可以通过new/new[]分配堆内存，使用delete/delete[]释放堆内存。在C中可以使用malloc、calloc和realloc函数分配堆内存，使用free函数释放堆内存</li></ul></li><li>生命周期不同：<ul><li>栈：栈上的内存生命周期与函数调用相关。局部变量在函数被调用时自动分配内存，函数返回时自动释放内存</li><li>堆：堆上内存的生命周期取决于程序员手动分配和释放。分配的内存在程序运行过程中移植存在，直到被显式释放或程序结束</li></ul></li><li>内存管理不同：<ul><li>栈：栈上的内存由操作系统和编译器自动管理</li><li>堆：堆上的内存需要程序员手动管理。可能导致错误，如内存泄露、野指针、重复释放等</li></ul></li><li>内存大小不同：<ul><li>栈：栈的大小相对较小，适用于存储较小的数据结构和对象。分配和释放栈内存的操作非常快速，但栈空间有限，可能导致栈溢出错误</li><li>堆：堆的大小通常比栈大得多，因此可以用于存储较大的数据结构和对象。然而，分配和释放堆内存的操作相对较慢，可能导致程序性能下降</li></ul></li></ul><p><strong>可执行文件和进程虚拟内存布局：</strong></p><p>可执行文件中存在.text、.rodata和.data，不存在.bss、堆和栈。因为.bss上的内存是在可执行文件中存储未初始化的全局变量和静态变量的内存区域，为了节省空间，在程序加载到内存时，.bss段中的变量会被自动初始化为0或空指针，所以不占用任何空间。而栈和堆是在程序运行时分配的。</p><p><strong>为什么要把程序的指令和数据分开？</strong></p><ul><li>出于保护只读区域的原因：数据区域堆进程来说是可读写的，而指令是只读的</li><li>对于现代CPU来说：现代CPU的缓存一般都设计成指令缓存和数据缓存，指令和数据分开有利于提高程序的局部性，有助于提高CPU缓存命中率</li><li>从共享的角度：程序中运行多个程序时，使用的指令是一样的，内存只用保存一份，将指令和数据分开，可以使指令共享，节省资源。</li></ul><p><strong>栈何时会溢出？(栈的大小是可以修改的)</strong></p><ul><li>递归调用层数过深</li><li>局部变量占用过多空间：一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽</li><li>大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出。</li></ul><p><strong>栈和堆分别存放着什么？</strong></p><ul><li>栈：函数返回地址、调用参数、局部变量以及使用的寄存器状态等信息</li><li>堆：程序运行时使用new，malloc等动态分配的内存</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的new和malloc</title>
    <link href="/2024/12/20/C-%E4%B8%AD%E7%9A%84new%E5%92%8Cmalloc/"/>
    <url>/2024/12/20/C-%E4%B8%AD%E7%9A%84new%E5%92%8Cmalloc/</url>
    
    <content type="html"><![CDATA[<h1 id="new和malloc">new和malloc</h1><p><strong>new和malloc的区别：</strong></p><ul><li>性质不同：new是一个C++中特有的操作符，而malloc是C中的内存分配函数</li><li>内存分配方式不同：malloc分配的内存是未初始化的，而new不仅分配了内存，还调用了对象的构造函数来初始化对象</li><li>使用语法不同：malloc使用时需要制定分配内存的大小，如malloc(sizeof(int))，但new不用，使用更加简洁（newint）</li><li>返回类型：malloc返回void*类型指针，需要强制转换成其他指定类型，而new直接返回响应的数据类型的指针，无需类型转换</li><li>错误处理：内存分配失败后，malloc返回null，而new会抛出std::bad_maclloc异常</li><li>配对操作：maclloc分配内存使用free释放，而new分配内存要使用delete释放</li></ul><p><strong>使用new操作符分配内存，可以使用free释放吗？</strong></p><p>不可以，只能使用delete</p><p><strong>使用new[]操作符分配内存，可以使用delete释放吗？</strong></p><p>不可以，只能使用delete[]</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的左值和右值</title>
    <link href="/2024/12/20/C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <url>/2024/12/20/C-%E4%B8%AD%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="左值和右值">左值和右值</h1><p><strong>概述：</strong></p><ul><li>左值：指向一个指定内存的，具有名称的值，它通常拥有一个稳定的内存地址，并且有一段较长时间的生命周期。</li><li>右值：通常不指向稳定内存地址的匿名值，生命周期很短，通常是暂时的。</li><li>基于此特性，可以取地址符来判断，能取到地址的是左值，不能取到地址的是右值</li></ul><p><strong>前置++和后置++</strong></p><ul><li>前置++：实现是直接对传入的对象自增，然后将此对象返回，因此它返回的是一个具有名称的稳定的值，它是一个左值</li><li>后置++：实现是创建一个临时对象，然后对传入的对象自增，但是返回的是这个临时对象</li></ul><p><strong>左值引用：</strong> 普通的引用类型，它绑定到左值。</p><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp;ref = a; <span class="hljs-comment">// ref是a的左值引用</span><br></code></pre></td></tr></table></figure><p>场景：在函数参数传递时，通常用于避免不必要的复制，节省性能</p><p><strong>右值引用：</strong> 是C++11引入的新特性，它绑定到右值</p><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>&amp;&amp; ref = <span class="hljs-number">10</span>; <span class="hljs-comment">// 10 是一个右值</span><br></code></pre></td></tr></table></figure><p>场景：通过启用移动语义，可以显著优化性能，特别是在处理临时对象和大对象时。一个重要应用是转移资源（如动态内存、文件句柄等），而不是进行昂贵的复制</p><p>移动语义：通过右值引用和std::move，可以将一个对象的资源转移到另一个对象，而不是复制一份相同的资源（类似于rust中的move关键字）</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_vector</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过左值引用，复制传入的 v</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Left value reference\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_vector</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; v)</span> </span>&#123;<br>    <span class="hljs-comment">// 通过右值引用，移动传入的 v</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Right value reference\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-built_in">process_vector</span>(vec1);  <span class="hljs-comment">// 左值引用调用</span><br><br>    <span class="hljs-built_in">process_vector</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);  <span class="hljs-comment">// 右值引用调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RVO(Return Value Optimization)：</strong></p><p>是一种编译器优化技术，用于消除不必要的临时对象拷贝，从而提高代码性能。主要针对函数返回局部对象的情况，通过优化，可以避免创建临时对象并执行拷贝构造函数。</p><p>RVO基本思想：在函数调用栈上直接构造返回值，而不是先构造一个局部对象，然后再拷贝到调用者的栈空间。这样可以减少临时对象的创建和销毁，提高代码运行效率。</p><p><strong>移动构造函数：</strong></p><p>就是构造函数使用右值引用作为接收，可以使我们在构造新对象时，将资源聪一个右值“move”到新对象，而不是创建新资源的拷贝，可以避免不必要的拷贝操作，从而提高代码的性能</p><p>存在的问题：当一个对象的资源移动到另一个对象时发生了异常，这样就会导致新对象是不完整的。可以使用noexcept说明符限制该移动构造函数，这样函数抛出异常时就会停止以免造成其他影响</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IT项目管理期末复习笔记</title>
    <link href="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="项目管理介绍">项目管理介绍</h1><h2 id="项目">项目</h2><p><strong>概述：</strong>是指为创造独特的产品、服务或成果而进行的临时性努力。项目具有明确的目标、时间限制和资源约束，通常需要在特定的范围内交付成果。</p><p><strong>属性：</strong></p><ul><li>临时性：项目是有起点和终点的，不是持续性的工作<ul><li>起点：项目开始时定义目标和需求</li><li>终点：项目在目标达成或因其他原因终止时结束</li><li>示例：开发一个新软件、举办一场活动、建设一座桥梁等</li></ul></li><li>独特性：项目的产出或结果是独一无二的，具有特定的目标和要求<ul><li>体现：即使是类似的项目，其交付成果、参与人员、执行环境等都会有所不同</li><li>示例：即使两座大桥外观相似，但建设的地理位置、施工环境、设计细节等使其独特</li></ul></li><li>渐进明细：项目计划和成果逐步细化和完善。项目初期目标较模糊，随着项目推进，细节逐步清晰<ul><li>特点：不断迭代、逐步优化和明确项目的范围、成本和进度</li><li>示例：软件开发初期可能只有一个框架概念，后续逐步细化功能需求和实现路径</li></ul></li><li>目标导向：项目的核心是实现预定目标，这个目标可以是产品、服务或特定的成果<ul><li>目标类型：<ul><li>具体的产品：如开发一款新手机</li><li>服务的提供：如实施一项培训课程</li><li>成果的实现：如提高公司生产效率10%</li></ul></li></ul></li></ul><h2 id="项目管理">项目管理</h2><p><strong>概述：</strong>通过应用知识、技能、工具和技术，对项目活动进行计划、组织、执行、控制、收尾的过程，目的是实现项目目标并满足目标的需求和期望。项目管理的目标是确保项目按时、按预算、高质量地交付成果，最大程度地满足项目干系人的要求</p><p><strong>IT项目管理的挑战：</strong></p><ul><li>需求变化频繁</li><li>时间和预算压力</li><li>技术复杂性</li><li>风险管理不足</li><li>沟通不畅</li></ul><p><strong>IT项目管理工具和方法：</strong></p><ul><li>敏捷方法(Agile)：适用于需求变化快的项目，常用Scrum、Kanban等方法<ul><li>Scrum：是一种敏捷项目管理框架，通过迭代和增量交付，使团队能够快速响应变化并持续改进。</li></ul></li><li>瀑布模型(Waterfall)：适用于需求明确且变化少的项目</li><li>项目管理工具： Jira、Trello、Asana、Microsoft Project、GitLab等</li><li>DevOps：通过持续集成和持续部署(CI/CD)加速项目交付</li></ul><p><strong>IT项目管理的优点：</strong></p><ul><li>明确目标，确保交付成果</li><li>提高资源利用率</li><li>增强团队协作与沟通</li><li>提高项目风险管理能力</li><li>控制项目进度和成本</li><li>提高项目质量</li><li>积累项目经验</li></ul><p><strong>IT项目管理的三角约束关系：</strong></p><ul><li>时间(Time)：指项目完成所需的时间，时间约束体现在项目进度表中</li><li>成本(Cost)：指项目实施所需的预算，包括人力、物力、技术等各种资源的成本</li><li>范围(Scope)：指项目需要完成的工作和交付成果，包括项目的功能、特性和目标</li></ul><p>任何一个要素的改变，都会对其他两个要素产生影响：</p><ul><li>如果想要缩短项目实时间，通常需要增加成本或减少项目范围</li><li>如果想要扩展项目范围，可能需要增加时间或成本</li><li>如果想要降低项目成本，可能会减少项目范围或延长项目时间</li></ul><h2 id="项目经理">项目经理</h2><p><strong>项目经理的重要性：</strong></p><ul><li>项目经理负责制定目标和方向，确保项目按计划推进</li><li>项目经理需要协调团队成员、资源、预算和时间，确保资源分配合理</li><li>在项目推进过程中，项目经理识别潜在风险，采取措施进行风险规避和应对</li><li>项目经理需要建立良好的团队合作和氛围，激励团队成员保持积极性和创造力</li><li>IT项目中经常会出现需求变更，项目经理需要快速评估变更的影响并做出决策</li></ul><p><strong>项目经理所需的素质：</strong></p><ul><li>领导能力</li><li>沟通能力</li><li>责任心与抗压能力</li><li>问题解决能力</li><li>团队合作精神</li><li>灵活应变能力</li></ul><p><strong>IT项目管理的核心知识领域(PMBOK指南)：</strong></p><p>在IT项目管理中，项目经理需要掌握以下十大知识领域：</p><ul><li>项目集成管理：确保项目所有部分协同工作</li><li>项目范围管理：定义和管理项目的交付内容</li><li>项目进度管理：制定项目时间表并按时完成任务</li><li>项目成本管理：预算控制，确保项目在预算内完成</li><li>项目质量管理：保证项目成果符合质量标准</li><li>项目资源管理：合理分配和管理项目所需的人力和物力资源</li><li>项目沟通管理：确保项目信息高效传达，团队队员和干系人信息同步</li><li>项目风险管理：识别、评估和应对项目中的潜在风险</li><li>项目采购管理：管理项目外包和供应商资源</li><li>项目干系人管理：识别项目干系人，管理他们的期望和参与度</li></ul><h2 id="项目管理的认证pmp">项目管理的认证PMP</h2><p>两大项目管理组织：美国PMI，欧洲IPMP</p><h1 id="项目管理和it背景">项目管理和IT背景</h1><h2 id="系统观点">系统观点</h2><blockquote><p>项目经理要有系统性思维，即在组织的背景中执行项目的观点</p></blockquote><p><strong>系统方法：</strong>采用整体的和分析的方法来解决复杂问题，包括使用系统哲学、系统分析和系统管理等方法。</p><p><strong>系统哲学：</strong> 是一整套系统地思考事务的思维模式</p><p><strong>系统分析：</strong>是解决问题的一种方法，需要定义所研究系统的范围，然后将它分解成各个部分来确认与评估相应的问题、机会、约束和需求。</p><p><strong>系统管理：</strong>处理与系统的创建、维护和改变相关的业务、技术和组织问题。</p><h2 id="了解组织">了解组织</h2><h2 id="项目阶段和项目生命周期">项目阶段和项目生命周期</h2><h2 id="影响itpm的最新趋势">影响ITPM的最新趋势</h2><h1 id="项目管理5个过程组">项目管理5个过程组</h1><p><strong>五大过程组：（PMBOK指南标准）</strong></p><ol type="1"><li>启动阶段(Initiating)<ul><li>主要活动：制定项目章程、确定项目目标和范围</li><li>示例：确定要开发一款电商平台，初步定义平台的功能和目标</li></ul></li><li>规划阶段(Planning)【耗时第二】<ul><li>主要活动：<ul><li>项目范围管理：明确项目要交付什么，不交付什么</li><li>项目时间管理：指定项目进度计划</li><li>项目成本管理：估算项目预算</li><li>风险管理：识别和评估风险，并制定应对计划</li></ul></li><li>示例：指定开发电商平台的详细功能需求，开发时间表和预算计划</li></ul></li><li>执行阶段(Executing)【花的时间最多】<ul><li>主要活动：<ul><li>开发团队开展编码和测试工作</li><li>确保项目资源按计划分配</li><li>与干系人保持沟通，报告项目进展</li></ul></li><li>示例：开发电商平台的前端和后端代码，进行系统集成</li></ul></li><li>监控和控制阶段(Monitoring and Controlling)<ul><li>主要活动：<ul><li>监控项目API（关键绩效指标）</li><li>识别和解决项目变更</li></ul></li><li>示例：监控开发进度，确保开发工作在预定时间和预算内完成</li></ul></li><li>收尾阶段(Closing)<ul><li>主要活动：<ul><li>项目交付与验收</li><li>文件归档与总结报告</li></ul></li><li>示例：交付电商平台，进行用户验收测试，编写项目总结报告</li></ul></li></ol><h1 id="项目集成管理">项目集成管理</h1><h2 id="简介">简介</h2><p><strong>概述：</strong> Project IntergrationManagement在项目的整个生命周期中协调所有其他知识领域。包括以下几个过程：</p><ul><li>和干系人制定项目章程(The project charter)</li><li>制定项目管理计划</li><li>指导并管理项目执行</li><li>监控项目工作</li><li>综合变更控制</li><li>项目或阶段收尾</li></ul><h2 id="战略计划与项目选择">战略计划与项目选择</h2><p><strong>概述：</strong> Strategic plnning分析组织优劣势，研究商业环境中的机会和威胁，确定长期目标，预测未来趋势，预测新产品和服务的需求</p><p><strong>SWOT分析：</strong> 分析优势、劣势、机会和威胁</p><p><strong>选择IT项目的计划过程：</strong></p><ol type="1"><li>IT战略计划</li><li>业务领域分析</li><li>项目计划</li><li>资源分配</li></ol><p><strong>选择项目的方法：</strong></p><ul><li>关注主要的组织需求：是否满足组织需求、资金、意愿</li><li>使用IT项目分类</li><li>使用财务分析，如净现值(Net Present Value, NPV)、投资回报率(Return OnInverstment, ROI)、回收分析(Payback Analysis)等</li><li>使用加权评分模型</li><li>实施平衡记分卡</li></ul><p><strong>净现值(Net Present Value, NPV)：</strong></p><p>通过将项目的所有未来现金流折算为当前的现值，并与初始投资成本相比较，来判断项目是否具有正的财务回报。公式如下：<span class="math display">\[NPV=\sum^n{\frac{C_t}{(1+r)^t}} - C_0\]</span></p><ul><li>n：项目的生命周期</li><li><span class="math inline">\(C_t\)</span>：第t年的现金流</li><li>r：贴现率（即资金的时间价值，通常是项目的资本成本或期望的回报率）</li><li>t：项目的时间周期（通常是年），从0开始</li><li><spanclass="math inline">\(C_0\)</span>：初始投资（即项目开始时的支出）</li></ul><p>计算过程：</p><ol type="1"><li>确定项目的现金流，首先需要识别项目的现金流入和流出。流入通常是项目实施后获得的收益（如软件销售收入、服务收费等），流出则是项目开发和运营的费用（如开发成本、人员工资、硬件采购等）</li><li>选择合适的贴现率，贴现率是用来折现未来现金流的比率，通常可以使用项目的资本成本或预期的回报率。贴现率考虑了资金的时间价值——即今天的钱比明天更值钱</li><li>计算各年的现金流现值，将每年或每期的现金流折算为当前价值，由于未来的现金流需要折现，所以会使用公式中的折现因子<spanclass="math inline">\(\frac{1}{(1+r)^t}\)</span>进行计算</li><li>计算NPV，如果NPV为正，表示项目产生的回报超过了投资成本，项目是可行的，否则反之。</li></ol><p><strong>投资回报率(Return On Inverstment, ROI)：</strong></p><p>是衡量投资回报与投资成本之间比例关系的指标，它表示项目的净收益相对于初始投资的比列。ROI通常以百分比表示，数值越大，表示投资回报越高。公式如下：<span class="math display">\[ROI=\frac{净收益}{投资成本} × 100%\]</span> <strong>回收分析(Payback Analysis)：</strong></p><p>指项目产生的累计净现金流刚好等于初始投资成本所需的时间，回收期越短说明项目回本速度越快。计算公式如下：<span class="math display">\[投资回收期=\frac{初始投资}{每年净现金流}\]</span>示例分析，某个IT项目需要初始投资100万元，每年的净现金流为20万元，计算投资回收期：<span class="math display">\[投资回收期=\frac{100万元}{20万元/年}=5年\]</span> 看图，就看交点： <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217212444987.png" class=""></p><p><strong>加权评分模型：</strong></p><p>用于对多个项目进行评估和排序。通过将不同的评估标准赋予权重，并根据各项目的表现进行评分，加权后进行排序</p><p>核心组成：</p><ul><li>评价标准(Criteria)：用于衡量项目的重要因素，例如成本、风险、收益、可行性等</li><li>权重(Weight)：各评价标准的重要程度，通常以百分比表示，所有权重之和为100%</li><li>评分(Score)：针对每个项目，按照各个标准的表现进行评分</li><li>加权总分：将评分与对应权重相乘，在相加得到总分</li></ul><p>公式： <span class="math display">\[加权总分=\sum(评分×权重)\]</span></p><h2 id="其他">其他</h2><p><strong>项目章程：</strong>正式承认项目存在并为项目目标和管理提供指导的文件</p><p><strong>项目管理计划：</strong>协调所有项目计划、指导项目执行和控制的文件。包括项目简介、项目如何组织、采用的管理和技术、进度安排和预算等</p><p><strong>执行综合变更控制：</strong></p><p>综合变更控制涉及在项目生命周期中识别、评估和管理变更</p><p>三个主要目标：</p><ul><li>影响产生变更的因素，以确保变更是有益的</li><li>确定一个变更发生过</li><li>及时管理真正的变更</li></ul><p>变更请求书的意义：变更请求书包括了变更目标和范围等，是项目综合变更的基础，是变更请求管理的书面化体现，有助于对变更管理规范化，对变更进行有效的控制，便于达到所需求的目标</p><h1 id="项目范围管理">项目范围管理</h1><p><strong>概述：</strong>是为了确保项目包括所有必须完成的工作，以成功交付产品、服务或结果所需要的过程。</p><p><strong>目标：</strong></p><ul><li>明确项目的边界（做什么、不做什么）</li><li>定义项目的主要工作内容和交付成果</li><li>防止项目过程中出现范围蔓延，即未经控制的新增工作</li><li>确保项目按时、按预算交付符合需求的产品或服务</li></ul><p><strong>六个过程：</strong></p><ol type="1"><li>规范范围管理(Plan Scope Management)：<ul><li>目的：制定管理项目范围的策略和方法</li><li>关键工具：范围管理计划，包括如何定义、确认和控制项目范围</li><li>输出：范围管理计划</li></ul></li><li>收集需求(Collect Requirements)：<ul><li>目的：收集项目干系人对产品或服务的需求和期望</li><li>方法：<ul><li>访谈、问卷调查</li><li>头脑风暴</li><li>观察</li><li>原型开发</li><li>用户故事</li></ul></li><li>输出：需求文档、需求跟踪矩阵</li></ul></li><li>定义范围(Define Scope)：<ul><li>目的：明确项目范围，包括项目的边界和交付成果</li><li>关键工具：<ul><li>项目范围说明书(Project Scope Statement</li><li>详细说明项目的目标、交付物、边界、约束条件和假设</li></ul></li><li>输出：项目范围说明书</li></ul></li><li>创建工作分解结构(WBS)：<ul><li>目的：将项目工作分解为更小、可管理的工作包</li><li>关键工具：<ul><li>WBS(Work Breakdown Structure)：分层描述项目工作</li><li>每个工作包都有明确的责任、可交付成果和时间预算</li></ul></li><li>输出：WBS、WBS词典（说明每个工作包的详细内容）</li></ul></li><li>确认范围(Validate Scope)：<ul><li>目的：通过干系人的验收确认项目的可交付成果是否符合需求</li><li>方法：<ul><li>检查交付物</li><li>干系人审查和验收</li></ul></li><li>输出：已验收的交付成果</li></ul></li><li>控制范围(Control Scope)：<ul><li>目的：监控项目范围，防止范围蔓延，确保范围变更得到控制</li><li>方法：<ul><li>范围变更控制</li><li>变更管理流程</li><li>比较实际工作与WBS和范围说明书</li></ul></li><li>输出：范围控制报告、变更请求</li></ul></li></ol><p><strong>项目范围管理中的关键工具和文档：</strong></p><ul><li>项目范文说明书：定义项目目标、交付物、边界、约束和假设</li><li>WBS：将项目分解为更小的工作包，以便分配责任、控制进度和预算</li><li>需求跟踪矩阵：确保需求与项目目标、交付成果、测试和验收标准之间保持一致【深入了解一下，好像作业有写到过，可以看一下】</li><li>变更控制流程：处理范围变更请求，确保变更经过批准和记录</li></ul><h1 id="项目进度管理">项目进度管理</h1><p><strong>概述：</strong>包括为项目完成所需的活动进行定义、排序、估算时间，并对进度进行监控和管理的一系列过程</p><ul><li>目标：确保项目按计划时间完成</li><li>核心：高效管理时间、资源和任务依赖关系</li></ul><p><strong>六个过程：</strong></p><ol type="1"><li><p>规范进度管理(Plan Schedule Management)：</p><ul><li>目的：制定项目进度管理的方法和标准</li><li>内容：<ul><li>如何制定进度计划</li><li>如何监控项目进度</li><li>如何应对进度偏差</li></ul></li><li>输出：进度管理计划</li></ul></li><li><p>定义活动(Define Activities)：</p><ul><li>目的：将WBS的工作包进一步细化为具体的活动</li><li>关键工具：<ul><li>分解(Decomposition)：将工作包分解为活动</li><li>活动清单：记录所有需要完成的项目活动</li></ul></li><li>输出：（应当与WBS和WBS字典一致）<ul><li>活动清单</li><li>活动属性（活动描述、资源、前置任务等）</li></ul></li></ul></li><li><p>排序活动(Sequence Activities)：</p><ul><li>目的：确定项目活动之间的顺序关系和依赖关系，形成活动网络图</li><li>关键工具：<ul><li>前后关系绘图法(PDM)：确定活动间的依赖关系，如：<ul><li><p>完成-开始(Finish-to-Start, FS)：任务A完成后任务B开始</p></li><li><p>开始-开始(Start-to-Start, SS)：任务A开始后任务B开始</p></li><li><p>完成-完成(Finish-to-Finish, FF)：任务A完成后任务B完成</p></li><li><p>开始-完成(Start-to-Finish, SF)：任务A开始后任务B结束</p><img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217230122484.png" class=""><img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218152747398.png" class=""><img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217230012548.png" class=""></li></ul></li></ul></li><li>输出：项目进度网络图、活动顺序</li></ul></li><li><p>估算活动持续时间(Estimate Activity Durations)：</p><ul><li><p>目的：估算完成每个活动所需的时间</p></li><li><p>关键工具：</p><ul><li><p>专家判断</p></li><li><p>类比估算：基于类似项目的历史数据估算时间</p></li><li><p>参数估算：是用公式或参数（如每人每天完成多少工作量）</p></li><li><p>三点估算（PERT）： <span class="math display">\[预计时间=\frac{乐观时间+4×最可能时间+悲观时间}{6}\]</span></p></li><li><p>资源日历：考虑资源的可用性</p></li></ul></li><li><p>输出：活动持续时间估算</p></li></ul></li><li><p>制定进度计划(Develop Schedule)：</p><ul><li>目的：基于活动顺序、持续时间估算和资源可用性，制定项目进度表</li><li>关键工具：<ul><li>关键路径法(Critical Path Method,CPM)：识别项目中最长的路径和关键任务</li><li>关键链法(Critical Chain Method)：考虑资源限制</li><li>甘特图(Gantt Chart)：用于可视化项目进度</li><li>资源优化：如资源平衡和资源平滑</li></ul></li><li>输出：<ul><li>项目进度计划</li><li>里程碑列表：使用SMART准则：<ul><li>Specific 明确的</li><li>Measurable 可度量的</li><li>Assignable 可分配的</li><li>Realistic 现实的</li><li>Time-framed 有时间限制的</li></ul></li><li>进度数据</li></ul></li></ul></li><li><p>控制进度(Control Schedule)：</p><ul><li>目的：监控项目进度，识别偏差，及时进行调整和纠正</li><li>关键工具：<ul><li>进度基准与实际进度对比</li><li>进度偏差分析（如净值分析EVM）</li><li>进度压缩：<ul><li>快速跟进(Fast Tracking)：并行执行任务</li><li>赶工(Crashing)：增加资源缩短任务实践</li></ul></li></ul></li><li>输出：<ul><li>进度变更请求</li><li>进度绩效报告</li></ul></li></ul></li></ol><p><strong>时差(Slack)或浮动时间(Float)：</strong>在不延迟后续活动完成日期的情况下，可以延迟一项活动的时间</p><p><strong>自由时差：</strong>不延误后续活动最早开始时间的情况下，该活动可以被延误的时间 <spanclass="math display">\[min(后续的ES-当前的EF)\]</span> <strong>总时差：</strong>从活动最早开始时间起，在没有拖延计划项目完成日期的情况下被耽搁的时间。<span class="math display">\[LS-ES\]</span> <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217232925865.png" class=""></p><p><strong>关键路径上：</strong> 最早开始=最晚开始，最早完成=最晚完成，无自由时差和总时差</p><p><strong>示例：</strong></p><ol type="1"><li><p>确定关键路径和工期 <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217233234871.png" class=""></p><p>由上图可知关键路径为A-D-F-G，工期为15天</p></li><li><p>关键路径上的ES=LS，EF=LF，且无自由时差和总时差<img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217233337654.png" class=""></p></li><li><p>确定非关键路径上活动的ES和EF（正推法，即从左往右推理<img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241217233502741.png" class=""></p></li><li><p>确定非关键路径上的LS和LF（逆推法，即从右往左推理</p></li><li><p>求C的总时差：3-2=1</p></li></ol><h1 id="项目成本管理">项目成本管理</h1><p><strong>概述：</strong>用于规划、估算、预算、筹措和控制项目所需的成本，确保项目在既定预算内完成</p><ul><li>核心目标：确保项目成本控制在批准的预算内，避免超支</li><li>关键因素：成本估算、成本预算、成本控制</li></ul><p><strong>四个过程：</strong></p><ol type="1"><li><p>规划成本管理(Plan Cost Management)</p><ul><li>目的：制定成本管理的方针、方法和程序</li><li>内容：<ul><li>如何进行成本估算</li><li>如何制定项目预算</li><li>如何监控成本和管理偏差</li></ul></li><li>输出：成本管理计划，包括估算精度、单位成本度量、控制阈值、报告格式等</li></ul></li><li><p>估算成本(Estimate Costs)：</p><ul><li><p>目的：估算完成项目各项活动所需的成本，包括人力、设备、材料、技术等。三种估算类型：粗粒度估算(Roughorder of magnitude, ROM)，预算估算(BudgetaryEstimate)，确定性估算(Definitive Estinmate)。</p></li><li><p>方法：</p><ul><li><p>类比估算(Analogous Estimating)：</p><ul><li>参考类似项目的历史数据进行估算</li><li>优点：快速简单；缺点：不够精确</li></ul></li><li><p>参数估算(Parametric Estimating)：</p><ul><li>基于历史数据与数学模型，通过参数比例关系进行估算</li><li>如每小时成本 × 工作市场</li></ul></li><li><p>三点估算(PERT) ：</p><ul><li><p><span class="math display">\[估算值=\frac{(乐观估算+4×最可能估算+悲观估算)}{6}\]</span></p></li><li><p>增强估算的准确性</p></li></ul></li><li><p>自下而上估算(Bottom-up Estimating)：</p><ul><li>将项目活动分解到最小任务单元，逐个估算，然后汇总</li><li>优点：精确度高；缺点：耗时</li></ul></li><li><p>专家判断</p></li></ul></li><li><p>输出：</p><ul><li>活动成本估算</li><li>成本估算依据</li><li>风险应急储备</li></ul></li></ul></li><li><p>制定预算(Determine Budget)：</p><ul><li>目的：将各活动成本估算汇总，确定项目的整体预算，为项目提供成本基准</li><li>方法：<ul><li>成本汇总：将活动或工作包的成本估算逐层汇总</li><li>储备分析：<ul><li>应急储备：应对已知风险的预算</li><li>管理储备：应对未知风险的预算</li></ul></li><li>资金分配：根据时间进度和项目阶段分配预算</li></ul></li><li>输出：<ul><li>成本基准(Cost Baseline)：作为项目成本控制的基准</li><li>项目资金需求(Cash Flow)：项目各阶段的资金需求计划</li></ul></li></ul></li><li><p>控制成本(Control Costs)：</p><ul><li>目的：监控项目成本，识别偏差并及时采取措施，保证成本控制在预算范围内</li><li>关键工具和技术：<ul><li>挣值管理(Earned Value Management, EVM)：<ul><li>通过成本、进度与完成工作的综合分析，评估项目绩效</li><li>关键指标：<ul><li>计划值(PV)：计划完成工作的成本</li><li>挣值(EV)：实际完成工作的计划成本</li><li>实际成本(AC)：完成工作的实际支出成本</li><li>成本偏差(CV)：CV = EV - AC，CV大于0，成本节约，反之成本超支</li><li>成本绩效(CPI)：<spanclass="math inline">\(CPI=\frac{EV}{AC}\)</span>，CPI大于1，成本节约，反之成本超支</li><li>进度偏差(SV)：SV = EV - PV，大于0则表示实际用时比计划短</li><li>进度绩效(SPI)：<spanclass="math inline">\(SPI=\frac{EV}{PV}\)</span>，大于0则表示项目超前计划</li></ul></li></ul></li><li>成本预测：<ul><li>预测项目最终成本，评估项目成本是否超支</li><li>公式：<spanclass="math inline">\(完工估算(EAC)=\frac{预算总成本(BAC)}{成本绩效指数(CPI)}\)</span></li></ul></li><li>偏差分析：对比实际成本与成本基准，分析偏差原因</li><li>成本压缩：<ul><li>赶工(Crashing)：增加资源以缩短任务时间</li><li>快速跟进(Fast Tracking)：并行执行活动，节约时间</li></ul></li></ul></li><li>输出：<ul><li>成本控制报告</li><li>成本基准的更新</li><li>纠正措施</li></ul></li></ul></li></ol><h1 id="项目质量管理">项目质量管理</h1><p><strong>概述：</strong>指的是为确保项目交付成果满足明确或隐含需求而采取的一系列活动。它关注以下两点：</p><ul><li>产品质量：项目的交付成果是否满足客户需求与标准</li><li>过程质量：项目的管理和执行过程是否高效且无偏差</li></ul><p><strong>三个过程：</strong></p><ol type="1"><li>规划质量管理(Plan Quality Management)：<ul><li>目的：确定项目的质量要求和标准，并制定满足这些要求的质量管理计划</li><li>输入：<ul><li>项目章程</li><li>项目管理计划</li><li>干系人登记册</li><li>风险登记册</li></ul></li><li>活动：<ul><li>确定项目的质量标准</li><li>制定质量管理计划，包括质量目标、指标和监控方法</li><li>定义质量工具和技术</li></ul></li><li>输出：<ul><li>质量管理计划</li><li>质量指标和标准</li><li>过程改进计划</li></ul></li></ul></li><li>管理质量(Manage Quality)：<ul><li>目的：实施质量管理计划，通过过程改进和质量活动确保项目能够交付高质量的产品</li><li>关键活动：<ul><li>质量保证(Quality Assurance)：<ul><li>确保项目执行过程遵循既定的质量标准</li><li>关注过程改进而非最终产品检查</li></ul></li><li>质量评估：通过质量审查、过程分析和绩效报告，找出改进点</li><li>技术评审：检查关键技术环节的实现质量（如代码审查、性能测试）</li></ul></li><li>方法与工具：<ul><li>鱼骨图：分析质量问题的根本原因</li><li>流程图：识别过程中的低效或瓶颈</li><li>帕累托图：识别主要质量问题</li></ul></li><li>输出：<ul><li>质量审查报告</li><li>过程改进建议</li></ul></li></ul></li><li>控制质量(Control Quality)：<ul><li>目的：监控项目成果，确保产品符合质量标准，并识别和纠正偏差</li><li>关键活动：<ul><li>质量检查：<ul><li>对项目交付的产品进行检查或测试</li><li>确保产品满足需求和标准</li></ul></li><li>纠正措施：发现问题后，采取措施消除偏差</li><li>文档化问题：记录质量问题，改进未来项目</li></ul></li><li>方法与工具：<ul><li>检查表：验证是否完成所有任务</li><li>控制图：监控过程是否在控制范围内</li><li>统计抽样：抽取样本数据进行分析</li></ul></li><li>输出：<ul><li>验收的交付物</li><li>质量控制测量结果</li><li>变更请求</li><li>质量改进记录</li></ul></li></ul></li></ol><p><strong>质量控制的工具和技术：</strong></p><p>鱼骨图(因果图)： <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218121107156.png" class=""></p><p>控制图： <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218121115319.png" class="">结合七点运行法则，即看连续七个点是否都在平均值一侧，出现的话可能有问题</p><p>帕累托图(Pareto)：80%的问题经常是由20%的原因引起的：<img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218121217326.png" class=""></p><h1 id="项目人力资源管理">项目人力资源管理</h1><p><strong>概述：</strong>核心是规划和管理团队，确保每个团队成员都能够清除自己的角色和职责，发挥其最大潜力。包括技术技能的管理，沟通、协调和鼓励</p><p><strong>关键理论：</strong></p><ul><li>激励理论：<ul><li>内在激励(Intrinsic motivation)：满足个人的兴趣爱好而参加活动</li><li>外在激励(Extrinsic motivation)：为了工资或免受处罚而做事</li></ul></li><li>影响力和权力理论：<ul><li>权力：影响行为的潜在能力，可以驱使人们做本来不会做的事。主要有5中：强制权力、法定权利、专家权力、奖励权力、感召权力</li></ul></li><li>有效性（效率）理论：项目经理提高工作效率的7中习惯：<ul><li>积极主动</li><li>开始时就想好如何结束</li><li>优先事优先做</li><li>考虑双赢</li><li>先去理解别人，再寻求别人理解</li><li>协同</li><li>“磨锯子”，即不断更新自我</li></ul></li></ul><p><strong>四个过程：</strong></p><ol type="1"><li>规划资源管理(Plan Resource Management)：<ul><li>目的：制定如何定义、管理和分配项目资源的计划</li><li>关键活动：<ol type="1"><li>确定团队需求：评估需要多少资源</li><li>定义角色与职责：为每个团队成员明确分工</li><li>创建资源管理计划：<ul><li>定义如何获取、培训、管理和释放资源</li><li>包括团队结构、责任分配矩阵（如RACI图表）<ul><li>组织结构图：<ul><li>项目副经理(Deputy ProjectManager)：在项目经理不在的情况下代替他工作，并在需要时协助项目经理工作</li><li>子项目经理(SubprojectManager)：负责管理一个由大型项目分解出来的子项目</li><li><img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218123623127.png" class=""></li></ul></li><li>组织分解结构(OBS)：一种特殊的组织结构图，显示每个组织单元负责哪些工作</li><li>责任分配矩阵(RAM)：将WBS条目和OBS相匹配。R：责任组织单元，P：执行单元<img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218124139783.png" class=""></li></ul></li></ul></li></ol></li><li>输出：<ul><li>资源管理计划</li><li>团队章程</li></ul></li></ul></li><li>组建团队(Acquire Project Team)：<ul><li>目的：通过招聘、分配现有资源或外包等方式，组建项目团队</li><li>关键活动：<ol type="1"><li>选择团队成员：根据技能需求、经验、兴趣选择合适的人员</li><li>资源分配：合理分配工作任务</li><li>谈判与合作：与职能部门或第三方合作，确保所需人力资源到位</li><li>确保团队支持：获取高层对团队组建和项目的支持</li></ol></li><li>工具与技术：<ul><li>多准则决策分析</li><li>资源日历</li></ul></li><li>输出：<ul><li>项目团队成员名单</li><li>资源分配记录</li></ul></li></ul></li><li>发展团队(Develop Project Team)：<ul><li>目的：提高团队成员的能力、增强团队凝聚力和士气，从而提高项目绩效</li><li>关键活动：<ol type="1"><li>提供培训：根据项目需求对团队成员进行技能培训</li><li>团队建设活动：如团队合作游戏、聚会等</li><li>绩效鼓励：通过奖励机制激励成员贡献</li><li>解决冲突：有效处理团队中的冲突，维护协作氛围</li></ol></li><li>工具与技术：<ul><li>培训与技能提升</li><li>激励机制</li><li>团队表现评估</li></ul></li><li>输出：<ul><li>团队绩效评估报告</li><li>项目环境改进计划</li></ul></li></ul></li><li>管理团队(Manage Project Team)：<ul><li>目的：监控团队绩效、解决问题、激励成员，确保团队始终高效运作</li><li>关键活动：<ol type="1"><li>绩效管理：评估成员工作绩效并提供反馈</li><li>冲突管理：及时处理团队内部冲突，选择适合的解决方法（如协作、妥协）</li><li>激励团队：使用奖励和认可提升团队士气</li><li>问题解决：确保团队成员间的协作和沟通顺畅， 消除障碍</li></ol></li><li>工具与技术：<ul><li>冲突管理技术（如谈判）</li><li>项目管理软件跟踪团队进展</li></ul></li><li>输出：<ul><li>绩效改进计划</li><li>变更请求</li><li>团队队员调整记录</li></ul></li></ul></li></ol><p><strong>其他概念：</strong></p><p>资源负荷(ResourceLoading)：现有计划在特定时间段内所需的单个资源的数量</p><p>过度分配：特定时间内，分配给某项工作的资源超过其现有资源</p><p>资源平衡(Resource Leveling)：通过任务延迟来解决资源冲突的技术</p><h1 id="项目沟通管理">项目沟通管理</h1><p><strong>概述：</strong>指的是为确保项目信息在合适的时间传递给正确的人，以合适的方式进行的规划、分发、管理和监控活动。它包含如何生成信息、如何分发信息、以及如何确保信息有效理解</p><p><strong>三个过程：</strong></p><ol type="1"><li>规划沟通管理(Plan Communications Management) :<ul><li>目的：制定沟通计划，明确如何沟通、与谁沟通、通过什么渠道，以及沟通频率</li><li>关键活动：<ol type="1"><li>识别沟通需求：分析项目干系人，确定他们的信息需求</li><li>选择沟通渠道：选择适当的沟通工具和技术（如电子邮件、会议、即使通讯等）</li><li>编制沟通管理计划：定义沟通目标、频率、内容和责任人</li></ol></li><li>工具与技术：<ul><li>沟通需求分析</li><li>干系人登记表</li><li>RACI图表</li></ul></li><li>输出：<ul><li>沟通管理计划：项目沟通的指导性文件</li><li>项目进度计划：确定沟通的时间节点</li></ul></li></ul></li><li>管理沟通(Manage Communications)：<ul><li>目的：按照沟通管理计划分发信息，确保信息传递的及时性和准确性</li><li>关键活动：<ol type="1"><li>生成信息：创建与项目相关的报告或更新信息</li><li>分发信息：通过适当渠道将信息发送给目标受众</li><li>收集反馈：确认信息是否被正确理解</li><li>管理沟通障碍：解决因语言、文化、技术等原因导致的沟通问题</li></ol></li><li>工具与技术：<ul><li>信息管理系统</li><li>项目状态报告</li><li>技术沟通工具</li></ul></li><li>输出：<ul><li>项目报告</li><li>反馈记录</li></ul></li></ul></li><li>监督沟通(Monitor Communications)：<ul><li>目的：确保沟通计划被遵守，并对沟通的效果进行评估和改进</li><li>关键活动：<ol type="1"><li>监控沟通流程：检查信息是否按照计划分发</li><li>评估沟通效果：确保干系人正确接收和理解信息</li><li>改进沟通策略：根据反馈优化沟通方式或频率</li></ol></li><li>工具与技术：<ul><li>干系人反馈分析</li><li>状态审查会议</li><li>数据分析工具</li></ul></li><li>输出：<ul><li>改进的沟通管理计划</li><li>变更请求</li></ul></li></ul></li></ol><h1 id="项目风险管理">项目风险管理</h1><p><strong>概述：</strong>指的是识别、评估和控制项目中潜在的风险因素，制定应对策略，以减少负面风险的影响并利用正面机会，确保项目目标的实习那。它是动态的，需要随着项目和环境变化而不断更新和调整</p><p><strong>六个过程：</strong></p><ol type="1"><li>规划风险管理(Plan Risk Management)：<ul><li>目的：制定如何将进行项目风险管理的总体策略和计划</li><li>关键活动：<ol type="1"><li>确定风险管理计划：定义如何识别、分析、响应和监控风险</li><li>确定风险管理方法：选择定性分析、定量分析或两者结合的方法</li><li>确定风险的角色与责任：明确谁负责哪些风险管理活动</li></ol></li><li>输出：风险管理计划（包括风险管理策略、风险类别、评估方法、风险跟踪方法等）</li></ul></li><li>识别风险(Identify Risks)：<ul><li>目的：识别所有可能对项目产生影响的风险，包括负面和正面的风险</li><li>关键活动：<ol type="1"><li>头脑风暴：集思广益，广泛讨论可能的风险因素</li><li>专家访谈：与领域专家讨论潜在的项目风险</li><li>SWOT分析：分析项目的优势、劣势、机会和威胁</li><li>历史数据回顾：参考类似项目的经验和教训</li></ol></li><li>工具和技术<ul><li>风险登记册</li><li>团队讨论与头脑风暴</li><li>文档分析</li></ul></li><li>输出：风向登记册，记录已识别的风险、风险的特点及其可能的影响</li></ul></li><li>执行定性风险分析(Perform Qualitative Risk Analysy)：<ul><li>目的：对识别的风险进行优先排序，评估其可能性和影响，确定哪些风险是最需要关注的</li><li>关键活动：<ol type="1"><li>评估风险的发生概率：分析每个风险事件发生的可能性</li><li>评估风险的影响：分析每个风险事件对项目目标的潜在影响</li><li>风险分类：基于风险的概率和影响，优先处理高风险</li></ol></li><li>工具与技术；<ul><li>风险概率和影响矩阵 <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218134238879.png" class=""></li><li>风险分类</li><li>敏感性分析（了解哪些变量对项目影响最大）</li></ul></li><li>F：风向评估报告，对风险进行排序，列出高优先级风险</li></ul></li><li>执行定量风险分析(Perform Quantitative Risk Analysis)：<ul><li>目的：对高优先级风险进行更精确的定量分析，量化其对项目的影响，以便做出更有依据的决策</li><li>关键活动：<ol type="1"><li>构建风险模型：使用统计模型或模拟来量化风险的影响（如蒙特克罗模拟）</li><li>风险预测：通过模拟分析评估风险对项目进度、成本等关键目标的影响</li></ol></li><li>工具与技术：<ul><li>蒙特卡洛模拟</li><li>决策树分析 <img src="/2024/12/20/IT%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241218134335937.png" class=""></li><li>敏感性分析：通过改变一个或多个变量来观察对结果的影响</li></ul></li><li>输出：<ul><li>风险模型</li><li>风险响应计划的更新（定量分析结果提供支持）</li></ul></li></ul></li><li>制定风险响应计划(Plan Risk Responses)：<ul><li>目的：根据风险分析的结果，为每个风险制定硬度i策略，尽量减少负面影响并利用正面机会</li><li>关键活动：<ol type="1"><li>应对负面风险：采取规避、转移、减轻或接受等策略</li><li>应对正面风险：采取利用、增强、风险或接受等策略</li><li>应对风险的优先级排序：针对高影响、高可能性风险采取积极响应策略</li></ol></li><li>工具与技术：<ul><li>风险应对策略（规避、转移、减轻、接受、利用、增强、分享等）</li><li>风险优先级排序</li></ul></li><li>输出：<ul><li>风险响应计划</li><li>风险应对措施</li></ul></li></ul></li><li>监控风险(Monitor RIsks)：<ul><li>目的：在项目执行过程中持续监控风险，评估风险应对措施的有效性，并根据需要调整策略</li><li>关键活动：<ol type="1"><li>跟踪风险：确保风险应对计划得到有效执行</li><li>评估风险的变化：识别新风险并更新风险管理计划</li><li>审核应对措施：评估风险应对措施的效果，确保达到预期的目标</li></ol></li><li>工具与技术：<ul><li>风险审查会议</li><li>风险监控报告</li><li>风险趋势分析</li></ul></li><li>输出：<ul><li>风向更新报告</li><li>风险登记册的更新</li></ul></li></ul></li></ol><h1 id="项目采购管理">项目采购管理</h1><p><strong>概述：</strong>指的是为满足项目需求而识别、获取和管理外部供应商或承包商提供的资源、服务和产品的过程。它不仅仅是购买、还涉及合同管理、供应商评估、风险管理等多方面内容，确保采购活动能够支持项目目标的实现</p><p><strong>四个过程：</strong></p><ol type="1"><li>规划采购管理(Plan Procurement Management)：<ul><li>目的：为项目的采购活动制定一个全面的计划，确保项目资源的获取符合项目目标</li><li>关键活动：<ol type="1"><li>确定采购需求：明确项目需要哪些外部资源，是否需要购买、租赁或外包</li><li>制定采购策略：根据项目的需求，选择合适的采购方式，如招标、合同采购或合作协议</li><li>明确采购管理流程：定义采购的流程，包括采购的评审、选择、签订合同、管理合同等</li><li>选择合适的采购类型：根据采购物品的特性，决定是采取固定价格合同、成本加成合同、时间与材料合同等</li></ol></li><li>工具与技术：<ul><li>市场调研</li><li>采购管理计划</li><li>供应商选择标准</li></ul></li><li>输出：<ul><li>采购管理计划：涵盖采购的策略、流程、角色责任、采购方式等</li><li>采购需求文档：明确项目所需资源、产品、服务等</li></ul></li></ul></li><li>实施采购(Conduct Procurements)：<ul><li>目的：选择合适的供应商，并通过谈判、签约等过程完成采购活动</li><li>关键活动：<ol type="1"><li>发布采购信息：将项目需求与采购信息发布给潜在供应商，如通过招标、RFQ(请求报价)等方式</li><li>接受和评估提案：评审供应商的提案或报价，选择最符合需求和条件的供应商</li><li>谈判与合同签订：与供应商进行谈判，确定条款，并签订正式合同</li></ol></li><li>工具与技术：<ul><li>采购文件（如招标书、合同文件）</li><li>供应商评估</li><li>评审矩阵</li></ul></li><li>输出：<ul><li>合同：明确供应商责任、价格、交付日期等内容</li><li>采购文件：包括合同协议、报价单、技术规范等</li></ul></li></ul></li><li>控制采购(Control Procurements)：<ul><li>目的：监控和管理与供应商相关的活动，确保合同的执行符合项目按要求，并及时解决出现的问题</li><li>关键活动：<ol type="1"><li>监控合同执行：确保供应商按合同约定提供资源、产品或服务</li><li>管理合同变更：处理合同中的变更请求，确保变更符合项目的需求</li><li>解决争议：处理与供应商之间的纠纷或违约问题</li></ol></li><li>工具与技术：<ul><li>合同变更控制系统</li><li>项目管理信息系统（PMIS）</li><li>风险管理工具</li></ul></li><li>输出：<ul><li>采购变更记录</li><li>绩效报告：记录供应商的表现和合同执行情况</li></ul></li></ul></li><li>关闭采购(Close Procurements)：<ul><li>目的：完成所有与供应商的合同活动，确保所有交付物按期交付，并关闭采购合同</li><li>关键活动：<ol type="1"><li>确认交付物：确保供应商按照合同要求完成交付</li><li>验收合同成果：确认交付的产品或服务符合项目标准</li><li>合同结算和管理：处理供应商账单和结算事宜，关闭合同</li></ol></li><li>工具与技术：<ul><li>合同结算</li><li>供应商评估报告</li></ul></li><li>输出：<ul><li>关闭合同的确认</li><li>合同结束报告</li></ul></li></ul></li></ol><p><strong>关键概念：</strong></p><ul><li>组织需要做出<strong>自制/外购决策(Make-orBuy Decision)</strong></li><li>固定价格合同(Fixed-Price Contract)：明确规定产品价格的合同</li><li>总假设点(Point of Total Assumption, PTA)</li><li>工作说明书(Statement of Work, SOW)：采购所需工作的描述</li></ul><h1 id="项目干系人管理">项目干系人管理</h1><p><strong>概述：</strong>指识别所有项目干系人，了解他们的需求、期望及利益，并制定策略以满足这些需求，确保干系人在项目过程中积极参与，并减少冲突、提高项目成功率。干系人的需求和期望会直接影响项目的决策和实施。</p><p><strong>四个过程：</strong></p><ol type="1"><li>识别干系人(Identify Stakeholders)：<ul><li>目的：确定所有对项目有影响或受到项目影响的干系人，并识别他们的需求和期望</li><li>关键活动：<ol type="1"><li>识别干系人：确定所有潜在的干系人，包括项目团队、客户、供应商、监管机构、合作伙伴等</li><li>分析干系人的影响力和利益：了解每个干系人对项目的影响程序及其需求、期望</li><li>记录干系人信息：通过干系人登记册记录干系人的身份、角色、需求、期望、沟通要求等信息</li></ol></li><li>工具与技术：<ul><li>头脑风暴</li><li>干系人分析矩阵</li><li>访谈和问卷</li><li>组织图(Organizational Charts)</li></ul></li><li>输出：干系人登记册，记录干系人的基本信息、需求、期望、影响力等</li></ul></li><li>规划干系人管理(Plan Stakeholder Engagement)：<ul><li>目的：指定干系人参与的策略，确保干系人在整个项目生命周期得到适当的管理和沟通</li><li>关键活动：<ol type="1"><li>分析干系人的期望与需求：确定干系人对项目的期望、需求和目标，并评估其对项目成功的影响</li><li>定义干系人管理策略：根据干系人的影响力、关注度和利益，确定他们的管理策略和沟通方式</li><li>规划沟通渠道：确定如何与干系人沟通，包括沟通频率、渠道、语言、沟通内容等</li></ol></li><li>工具与技术：<ul><li>干系人参与矩阵</li><li>沟通管理计划</li><li>风险管理计划</li></ul></li><li>输出：干系人参与计划，制定与干系人有效沟通和互动的策略，确保干系人在项目过程中的需求和期望能够得到满足</li></ul></li><li>管理干系人参与(Manage Stakeholder Engagement)：<ul><li>目的：通过有效的沟通和管理，确保干系人积极参与，减少冲突，增强干系人对项目的支持</li><li>关键活动：<ol type="1"><li>与干系人保持沟通：定期向干系人提供可能的不满和潜在的冲突，及时进行沟通并调整</li><li>解决干系人关注问题：主动识别干系人可能的不满和潜在的冲突，及时进行沟通与调整</li><li>获取干系人的支持：通过定期沟通和满足干系人需求，建立和维持干系人对项目的支持和信任</li><li>处理干系人期望变更：当干系人需求或期望发生变化时，及时调整管理策略，确保项目目标与干系人期望一致</li></ol></li><li>工具与技术：<ul><li>会议和工作坊</li><li>定期报告和更新</li><li>冲突解决技巧</li><li>干系人参与跟踪工具</li></ul></li><li>输出：干系人参与报告，记录干系人参与情况、解决的冲突、干系人对项目的支持情况等</li></ul></li><li>监控干系人参与(Monitor Stakeholder Engagement)：<ul><li>目的：评估干系人管理策略的效果，确保干系人参与和需求得到持续惯出，并采取必要的调整措施</li><li>关键活动：<ol type="1"><li>评估干系人参与情况：定期评估干系人对项目的参与度和支持情况</li><li>调整干系人管理策略：根据干系人需求的变化或项目进展情况，调整干系人管理计划</li><li>评估干系人满意度：定期检查干系人对项目的满意度，采取适当的改进措施以提升干系人支持</li></ol></li><li>工具与技术：<ul><li>项目管理信息系统(PMIS)</li><li>反馈调查和调查问卷</li><li>干系人参与评估工具</li></ul></li><li>输出：干系人管理更新报告，记录干系人参与的变更、调整的策略以及干系人的反馈意见</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>大学课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IT项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件架构期末复习笔记</title>
    <link href="/2024/12/16/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/16/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="软件架构">软件架构</h1><p><strong>定义：</strong>是一个系统的基本组织，由其组件、组件之间的关系以及与环境的关系组成，同时包括设计和演化的原则</p><p><strong>核心概念：</strong></p><ul><li>组件：系统的功能单元，负责特定任务的执行。例如模块、服务、类、库等</li><li>连接器：定义组件之间如何交互的机制，包括数据流、调用协议等。例如HTTP、消息队列、函数调用等</li><li>关系：描述组件之间的依赖或交互方式。例如调用关系、数据共享、事件发布-订阅模式等</li><li>架构风格：一组通用的设计原则和模式，例如分层架构、微服务架构、事件驱动架构等</li><li>质量属性(QA)：系统非功能需求，包括性能、安全性、可扩展性、可维护性等，这些属性对架构设计有重要影响</li><li>视图：软件架构通常以不同的视图来呈现，帮助不同角色（如开发者、运维人员）理解系统。常见的视图有逻辑视图、物理视图、开发视图、运行时视图等</li></ul><p><strong>作用：</strong></p><ul><li>指导开发：提供系统开发的蓝图，明确系统的结构和开发方向</li><li>支持决策：帮助团队衡量QA，如性能和安全之间的平衡</li><li>促进沟通：通过架构视图和文档，促进团队成员之间的沟通和理解</li><li>适应变化：通过合理的设计原则和模式，使系统能适应需求变化和技术演进</li></ul><p><strong>实践：</strong></p><ul><li>需求分析：识别功能性和非功能性需求</li><li>选择架构模式：单体架构、微服务架构</li><li>定义组件和接口：明确系统模块的职责和交互方式</li><li>验证和优化：通过架构评审或原型验证设计是否合理</li></ul><h2 id="三种视图结构">三种视图结构</h2><h3 id="模块结构">模块结构</h3><p><strong>概述：</strong>描述系统的静态分解，即系统由哪些模块组成，以及这些模块之间的关系</p><p><strong>核心特点：</strong></p><ul><li><p>关注开发时的静态组织</p></li><li><p>体现模块的职责分配和分层结构</p></li><li><p>主要面向开发者和架构师，帮助理解代码的分解和组织</p></li></ul><p><strong>主要形式：</strong></p><ul><li>分层结构 ：<ul><li>系统被分为若干层，每层负责特定功能，并依赖于下层</li><li>示例：表示层（UI） -&gt; 业务逻辑层（BLL） -&gt;数据访问层（DAL）</li></ul></li><li>分块结构：<ul><li>系统被分解为功能模块，强调模块的职责和边界</li><li>示例：用户模块、订单模块、支付模块</li></ul></li><li>使用结构：<ul><li>描述模块之间的依赖关系</li><li>示例：模块A使用模块B的接口</li></ul></li></ul><p><strong>作用：</strong></p><ul><li>确定模块的职责和边界，便于开发分工</li><li>明确模块之间的依赖关系，避免循环依赖</li></ul><h3 id="分配结构">分配结构</h3><p><strong>概述：</strong>描述系统的动态部署，即软件模块如何分配到硬件或组织上运行</p><p><strong>核心特点：</strong></p><ul><li>关注系统在实际运行中的部署形态</li><li>面向运维工程师、架构师、强调部署、性能和资源分配</li></ul><p><strong>主要形式：</strong></p><ul><li>部署结构(Deployment Structure)：<ul><li>描述模块与物理硬件的映射关系</li><li>示例：Web服务部署在服务器A，数据库部署在服务器B</li></ul></li><li>实施结构(Implementation Structure)：<ul><li>关注模块分配到开发团队或代码仓库的组织方式</li><li>示例：模块X分配给团队A，模块Y分配给团队B</li></ul></li><li>工作分配结构(Work Assignment Structure)：<ul><li>关注模块与团队或人员的对应关系</li><li>示例：订单服务由团队A开发维护</li></ul></li></ul><p><strong>作用：</strong></p><ul><li>确保资源利用的效率和系统性能</li><li>提供开发、部署和运维的清晰指导</li></ul><h3 id="cc架构">C&amp;C架构</h3><p><strong>概述：</strong>描述系统的运行时视角，即组件如何通过连接器交互完成工作</p><p><strong>核心特点：</strong></p><ul><li>关注系统的动态行为和交互模式，面向架构师和性能分析师</li><li>组件是独立功能单元，连接器是组件之间的通信机制</li></ul><p><strong>主要形式：</strong></p><ul><li>通信结构(Communication Structure)：<ul><li>描述组件之间的通信模式</li><li>示例：HTTP请求、消息队列、RPC调用</li></ul></li><li>并发结构(Concurrency Structure)：<ul><li>关注组件之间的并发交互</li><li>示例：多个线程或进程之间的协作</li></ul></li><li>协作结构(Coordination Structure)：<ul><li>描述组件如何协同完成任务</li><li>示例：客户端调用服务端，服务端调用数据库</li></ul></li></ul><p><strong>作用：</strong></p><ul><li>描述系统的运行时行为，指导实现动态交互逻辑</li><li>帮助分析系统的性能、并发性和容错能力</li></ul><h2 id="七类设计决策">七类设计决策</h2><h3 id="技术决策">技术决策</h3><p><strong>概述：</strong>选择实现系统的技术栈和工具，包括编程语言、框架、库、数据库、消息队列等</p><p><strong>目的：</strong>确保技术选型满足功能和非功能需求，同时考虑团队能力和项目环境</p><p><strong>示例：</strong></p><ul><li>选择JS或TS开发前端</li><li>使用PostgreSQL作为关系型数据库</li><li>引入Kafka作为消息队列处理异步任务</li></ul><h3 id="架构模式决策">架构模式决策</h3><p><strong>概述：</strong>决定系统使用的整体架构模式，影响系统的高层结构和模块间交互方式</p><p><strong>目的：</strong> 为系统的组织和分解提供整体指导框架</p><p><strong>常见模式：</strong></p><ul><li>分层架构：将系统分为UI层、业务逻辑层和数据层</li><li>微服务架构：将系统拆分为多个独立服务，按业务模块划分</li><li>事件驱动架构：通过事件队列实现松耦合和异步通信</li></ul><p><strong>示例：</strong></p><ul><li>一个电商系统采用微服务架构来支持模块化和独立扩展</li></ul><h3 id="模块划分决策">模块划分决策</h3><p><strong>概述：</strong>决定如何将系统划分为功能模块，以及模块之间的职责和依赖关系</p><p><strong>目的：</strong>确保模块化设计，提高系统的可维护性和可扩展性</p><p><strong>示例：</strong></p><ul><li>划分出用户模块、订单模块、支付模块，每个模块独立负责一部分业务逻辑</li><li>采用依赖注入(Dependenccy Injection)管理模块间的依赖</li></ul><h3 id="接口设计决策">接口设计决策</h3><p><strong>概述：</strong>决定模块或组件之间的交互接口，包括接口的协议、数据格式和调用方式</p><p><strong>目的：</strong> 确保模块间的通信高效、清晰且符合需求</p><p><strong>示例：</strong></p><ul><li>REST API设计：定义一个/api/orders的POST接口用于创建订单</li><li>使用gRPC协议传输结构化数据，提高通信性能</li><li>确定内部模块使用接口，而外部模块暴露公共API</li></ul><h3 id="数据管理决策">数据管理决策</h3><p><strong>概述：</strong>决定如何存储、管理和访问数据，包括数据库选型、分区策略、缓存方案等</p><p><strong>目的：</strong> 保证系统的数据一致性、持久性和高效访问</p><p><strong>示例：</strong></p><ul><li>使用MySQL作为主数据库，redis用于缓存热数据</li><li>对大规模数据库采用分库分表策略</li><li>引入ElasticSearch提供全文检索功能</li></ul><h3 id="非功能需求决策">非功能需求决策</h3><p><strong>概述：</strong>围绕系统的QA（性能、可用性、安全性、扩展性等）所作的设计决策</p><p><strong>目的：</strong> 确保系统在功能之外的特性满足需求</p><p><strong>示例：</strong></p><ul><li>为高并发场景设计负载均衡方案</li><li>提供每日备份机制以增强灾难恢复能力</li><li>使用OAuthr2协议确保系统的安全性</li></ul><h3 id="运维部署决策">运维部署决策</h3><p><strong>概述：</strong>涉及系统在实际运行环境中的部署方式、监控方案和故障处理策略</p><p><strong>目的：</strong> 提高系统在生产环境中的可用性和可操作性</p><p><strong>示例：</strong></p><ul><li>使用Docker容器化所有服务</li><li>部署Kubernetes集群管理微服务</li><li>设计健康检查和自动重启机制来处理服务故障</li></ul><h2 id="lts">LTS</h2><p><strong>概述：</strong> Long-Term Support是一个软件产品或版本提供长期维护和支持的策略，旨在为用户和开发团队提供更稳定的环境和更低的项目风险。</p><h3 id="稳定性和可靠性">稳定性和可靠性</h3><p><strong>作用：</strong></p><ul><li>LTS版本专注于稳定性，通常不会频繁引入重大变化和新特性</li><li>开发团队可以依赖一个稳定的版本，避免频繁的版本迁移带来的不确定性</li></ul><p><strong>降低风险：</strong></p><ul><li>减少由于升级或兼容性问题导致的功能中断</li><li>降低开发过程中不可预测的环境变化风险</li></ul><h3 id="安全性保障">安全性保障</h3><p><strong>作用：</strong></p><ul><li>LTS版本的厂商或社区通常会长期提供安全补丁和漏洞修复</li><li>用户可以确保系统在生命周期内的安全性，即使版本较老</li></ul><p><strong>降低风险：</strong></p><ul><li>避免因不再维护的旧版本导致的安全漏洞</li><li>提供定期安全更新，降低系统收到攻击的可能性</li></ul><h3 id="成本控制">成本控制</h3><p><strong>作用：</strong></p><ul><li>LTS版本减少了频繁升级或迁移的需求，从而降低开发和运维成本</li><li>团队可以专注于功能开发，而非花费大量时间适配新版本</li></ul><p><strong>降低风险：</strong></p><ul><li>避免因频繁升级导致的不必要投入</li><li>减少开发周期内技术债务的积累</li></ul><h3 id="提高开发效率">提高开发效率</h3><p><strong>作用：</strong></p><ul><li>LTS版本提供长期支持，意味着工具链、依赖库和文档会保持一致性</li><li>团队可以专注于产品的核心功能，而非对应工具的环境的频繁变更</li></ul><p><strong>降低风险：</strong></p><ul><li>减少开发团队因频繁学习和适应新技术导致的效率下降</li><li>提高开发流程的一致性和可预测性</li></ul><h3 id="减少技术不确定性">减少技术不确定性</h3><p><strong>作用：</strong></p><ul><li>LTS版本的特性和行为经过充分测试和验证</li><li>减少因使用实验性或不稳定功能导致的不可预测后果</li></ul><p><strong>降低风险：</strong></p><ul><li>避免因新技术选择错误而引发的项目失败</li><li>提供长期验证的技术方案，适合关键任务和大规模项目</li></ul><h3 id="满足合规性和行业标准">满足合规性和行业标准</h3><p><strong>作用：</strong></p><ul><li>LTS版本通常更符合行业合规性要求</li><li>企业用户在选择软件时，LTS版本更易于通过合规审查</li></ul><p><strong>降低风险：</strong></p><ul><li>避免因使用未经过支持的版本导致的法律或合规问题</li><li>确保系统满足长期运行所需的行业标准</li></ul><h2id="模式patterns与策略tactics的关系">模式(Patterns)与策略(Tactics)的关系</h2><h3 id="定义与作用">定义与作用</h3><p><strong>模式：</strong></p><ul><li>定义：模式是经过验证的、在特定上下文中解决特定问题的高层设计方案或模板</li><li>作用：提供系统整体结构和模块间交互的通用解决方案</li><li>示例：<ul><li>架构模式：如分层架构、微服务架构、事件驱动架构</li><li>设计模式：观察者模式、单例模式、工厂模式</li></ul></li></ul><p><strong>策略：</strong></p><ul><li>定义：策略是实现系统QA的低层次技术方法或设计选择</li><li>作用：通过具体的实现手段优化系统的特定属性</li><li>示例：<ul><li>性能策略：缓存数据、使用异步处理</li><li>安全策略：使用加密、身份验证</li></ul></li></ul><h3 id="层次关系">层次关系</h3><p><strong>模式是高层次的，策略是低层次的：</strong></p><ul><li>模式描述了整体设计框架，用于组织系统结构</li><li>策略是在模式中应用的具体方法，用于实现质量目标</li></ul><p><strong>模式包含策略：</strong></p><ul><li>一个模式通常由多个策略组成，这些策略支持模式的实现</li><li>示例：在微服务架构模式中，可能需要使用缓存策略来提高性能，或者使用服务注册与发现策略来增强可用性</li></ul><p><strong>策略支持模式的质量目标：</strong></p><ul><li>模式的选择通常受到QA的驱动，而策略的应用则是为了更好地满足这些QA</li></ul><h3 id="设计关系">设计关系</h3><p><strong>模式与策略的设计关系：</strong></p><ul><li>驱动关系：系统的QA需求驱动模式的选择，而模式的实现依赖策略的具体应用</li><li>组合关系：模式之间可以相互组合，一个系统可能同时应用多个模式，每个模式中使用相应的策略来支持QA</li><li>实践关系：在实际项目中，模式提供了整体解决方案，策略在实施过程中细化模式的细节</li></ul><h3 id="举例说明">举例说明</h3><p><strong>分层架构模式：</strong></p><ul><li>模式描述：系统被分为表示层、业务逻辑层和数据访问层，每层负责特定职责</li><li>应用的策略：<ul><li>性能策略：在业务逻辑层引入缓存以减少对数据层的请求</li><li>可靠性策略：在表示层使用超时和重试机制应对网络问题</li><li>安全策略：在数据访问层增加数据库连接加密</li></ul></li></ul><p><strong>微服务架构模式：</strong></p><ul><li>模式描述：系统被拆分为多个独立服务，每个服务独立部署、独立运行</li><li>应用的策略：<ul><li>性能策略：在每个服务之间引入消息队列以处理高并发</li><li>安全策略：使用OAuth2进行服务间身份验证</li><li>可用性策略：实现断路器模式以防止单点故障</li></ul></li></ul><p><strong>事件驱动架构模式：</strong></p><ul><li>模式描述：系统基于事件通知机制运行，模块通过事件消息通信</li><li>应用的策略：<ul><li>性能策略：使用异步事件队列处理大量并发事件</li><li>可靠性策略：引入事件持久化以防止消息丢失</li><li>扩展性策略：使用分布式事件总线支持水平扩展</li></ul></li></ul><h1 id="质量属性qa">质量属性(QA)</h1><h2 id="类型">类型</h2><p><strong>运行时QA：</strong></p><table><thead><tr><th>运行时QA</th><th>概念和目标</th><th>示例策略</th></tr></thead><tbody><tr><td>性能(Performance)</td><td>系统响应速度、吞吐量及资源利用率。目标是满足用户对响应时间或处理能力的期望。</td><td>缓存、负载均衡、异步处理、数据分片</td></tr><tr><td>可用性(Availability)</td><td>系统在指定时间内的正常运行能力，通常以"运行时间的百分比"度量</td><td>冗余(Redundancy)设计、容错机制、健康检查与自动恢复</td></tr><tr><td>安全性(Security)</td><td>保护系统免受未授权访问或攻击，保证数据和系统的机密性、完整性和可用性</td><td>加密、身份验证、访问控制、日志审计</td></tr><tr><td>可靠性(Reliability)</td><td>系统在规定条件下和规定时间内执行成功功能的能力</td><td>冗余设计、重试机制、监控和报警</td></tr><tr><td>可扩展性(Scalability)</td><td>系统在增加负载或资源后，仍然能有效处理任务的能力</td><td>水平扩展(增加节点)、垂直扩展(增强单节点能力)、使用分布式架构</td></tr><tr><td>可用性(Usability)</td><td>系统对最终用户的易用性和可操作性</td><td>友好的用户界面、直观的导航、帮助文档</td></tr></tbody></table><p><strong>非运行时QA：</strong></p><table><thead><tr><th>非运行时QA</th><th>概念和目标</th><th>示例策略</th></tr></thead><tbody><tr><td>可维护性(Maintainability)</td><td>系统的可修改性和可调试性，易于修复缺陷和适应需求变化</td><td>模块化设计、清晰的代码规范、自动化测试</td></tr><tr><td>可测试性(Testability)</td><td>测试系统是否符合需求的容易程度，目标是确保问题可以快速发现和定位</td><td>测试驱动开发(TDD)、依赖注入、使用模拟(mock)测试</td></tr><tr><td>可部署性(Deployability)</td><td>系统的快速部署能力，支持灵活升级和版本回退</td><td>容器化部署、蓝绿部署、持续交付</td></tr><tr><td>可移植性(Portability)</td><td>系统在不同硬件或软件环境中运行的能力</td><td>使用平台无关技术、抽象接口层</td></tr><tr><td>可复用性(Resuability)</td><td>系统组件的复用能力，用于节省开发时间和资源</td><td>组件化设计、使用共享库、标准化接口设计</td></tr><tr><td>互操作性(Interoperability)</td><td>系统与其他系统或组件协同工作的能力</td><td>使用开放标准(如RESTful API)、数据格式转换(如JSON与XML)</td></tr></tbody></table><h2 id="概念">概念</h2><p><strong>核心特点：</strong></p><ul><li>非功能需求(NFRs)：QA通常不直接涉及系统的功能，但它们对于系统是否能否满足用户需求至关重要的</li><li>权衡与优先级：不同QA之间可能存在冲突，例如提高性能可能会降低安全性，架构涉及需要根据项目目标进行平衡</li><li>驱动设计决策：QA决定了架构模式、组件划分和系统部署方式</li></ul><p><strong>属性场景(Quality Attributes Scenarios) ：</strong></p><p>为了明确和测试QA，通常使用属性场景来定义其需求和评估标准。一个完整的属性场景包括：</p><ul><li>刺激源：触发系统的外部或内部事件</li><li>刺激：对系统施加的具体操作</li><li>环境：系统在何种状态下发生刺激（如正常负载或高负载）</li><li>响应：系统在刺激下的行为</li><li>响应度量：用于评估响应是否达到期望的指标</li></ul><h2 id="策略">策略</h2><h3 id="通用策略">通用策略</h3><ul><li>模块化设计：通过分离关注点提高可维护性、可测试性和可复用性</li><li>分层架构：支持扩展性、可移植性和安全性</li><li>容错设计：提高可靠性和可用性</li><li>性能优化：如引入缓存、压缩数据、负载均衡等</li></ul><h3 id="具体qa策略">具体QA策略</h3><p><strong>概览：</strong></p><table><thead><tr><th>QA</th><th>策略</th></tr></thead><tbody><tr><td>性能</td><td>使用缓存| CDN | 索引优化 | 减少数据传输量 | 异步处理耗时任务</td></tr><tr><td>安全性</td><td>加强访问控制 | 实现日志记录与审计 | 使用TLS/SSL协议保护传输数据</td></tr><tr><td>可用性</td><td>实现自动恢复机制 | 增加故障转移(Failover) | 使用负载均衡</td></tr><tr><td>可靠性</td><td>数据冗余与备份 | 使用事务来保证数据一致性 | 实现健康检查与监控</td></tr><tr><td>可维护性</td><td>实现代码分层与模块化 | 遵循编码规范 |使用自动化工具生成测试和文档</td></tr><tr><td>可扩展性</td><td>引入分布式架构 | 水平扩展(增加服务器) | 垂直扩展(提高硬件性能)</td></tr><tr><td>互操作性</td><td>使用开发协议和标准 | 提供明确的API文档 | 支持多种数据格式的转换</td></tr></tbody></table><h4 id="可用性和相关策略">可用性和相关策略</h4><p><strong>概述：</strong>系统在指定时间内保持正常运行并提供服务的能力，通常用”运行时间百分比“来衡量</p><p><strong>目标：</strong></p><ul><li>确保服务不中断</li><li>快速恢复故障</li><li>提供冗余和容错能力</li></ul><p><strong>故障检测：</strong></p><ul><li>健康检查(HealthCheck)：周期性检查服务或组件是否正常工作。比如HTTP健康检查接口<code>/health</code></li><li>心跳机制(HeartbeatMechanism)：服务通过定期发送心跳信号告知其他组件其状态。比如分布式系统中，节点通过心跳确认彼此在线</li><li>监控与日志：实时监控关键性能指标（如响应时间、错误率），并记录日志以便问题排查。工具Prometheus、Grafana</li></ul><p><strong>故障处理：</strong></p><ul><li>自动故障转移(Failover)：在主节点故障时，将流量自动切换到备用节点。使用AWS的弹性负载均衡(ELB)和多区域部署</li><li>数据冗余与备份：通过复制数据或定期备份防止因数据丢失导致系统不可用。比如使用RAID、数据库库复制（MySQL主从复制）</li><li>断路器模式(Circuit BreakerPattern)：在故障频繁时临时停止对问题服务的调用，避免系统过载</li></ul><p><strong>快速恢复：</strong></p><ul><li>重试机制：在失败时自动重试，以应对短暂性故障。比如API调用失败后每隔几秒重试</li><li>自动化恢复：利用容易编排工具（如Kubernetes）自动重新启动失败的服务</li></ul><h4 id="性能和相关的策略">性能和相关的策略</h4><p><strong>概述：</strong>衡量系统在不同负载下完成任务的效率，主要涉及响应时间、吞吐量和资源利用率</p><p><strong>目标：</strong></p><ul><li>降低响应时间</li><li>提高系统处理能力（吞吐量）</li><li>合理使用系统资源</li></ul><p><strong>响应时间优化：</strong></p><ul><li>缓存(Caching)：减少重复计算或数据库查询，将常用数据缓存在内存中。比如使用Redis或Memcached</li><li>CDN(内容分发网络)：加速静态内容的分发，减少延迟。比如使用Cloudflare加快网页加载速度</li><li>异步处理：将耗时任务放入后台队列，避免阻塞主线程。比如使用消息队列RabbitMQ/Kafka</li></ul><p><strong>吞吐量提升：</strong></p><ul><li>负载均衡(LoadBalancing)：将请求分发到多个服务器，避免单点瓶颈。比如Nginx、HAProxy</li><li>数据库分片(Sharding)：将数据分布到多个数据库，提高读写并发性能</li></ul><p><strong>资源优化：</strong></p><ul><li>压缩与最小化：压缩文件大小，减少网络传输开销</li><li>优先级调度：为高优先级任务分配更多资源</li></ul><h4 id="安全性及相关的策略">安全性及相关的策略</h4><p><strong>概述：</strong>是保护系统及其数据免受未授权访问、攻击和恶意行为的能力</p><p><strong>目标：</strong></p><ul><li>保证数据的机密性、完整性和可用性</li><li>防止未授权的访问和攻击</li></ul><p><strong>身份验证与授权：</strong></p><ul><li>身份验证(Authentication)：确认用户身份。比如使用OAuth2、JWT(JSON WebToken)</li><li>授权(Authorization)：确定用户可以访问的资源范围。比如基于角色的访问控制(RBAC)</li></ul><p><strong>数据保护：</strong></p><ul><li>加密(Encryption)：保护数据在传输和存储中的安全性。比如使用HTTPS(TLS/SLL)，数据库字段加密</li><li>数据校验：使用哈希算法（如SHA-256）验证数据完整性</li></ul><p><strong>攻击防护：</strong></p><ul><li>输入验证：防止SQL注入和跨站脚本攻击（XSS）。比如使用参数化查询，过滤用户输入</li><li>防火墙与WAF(Web Application Firewall)：阻止恶意流量。比如CloudflareWAF</li><li>速率限制：限制单个IP或用户的请求频率，防止DoS攻击</li></ul><p><strong>安全监控：</strong></p><ul><li>安全事件日志：记录用户登录、失败尝试等行为。比如使用SIEM(SecurityInformation and Event Management)工具</li><li>实时威胁检测：利用AI分析系统日志，识别潜在威胁</li></ul><h4 id="互操作性和相关策略">互操作性和相关策略</h4><p><strong>概述：</strong>是指系统能够与其他系统或组件协同工作，并交换和利用信息的能力</p><p><strong>目标：</strong></p><ul><li>通过标准接口实现不同系统间的兼容性</li><li>使服务之间可以无缝发现和协作</li></ul><p><strong>标准化通信：</strong></p><ul><li>使用开放协议和标准：如REST、gRPC、SOAP等</li><li>数据格式兼容性：支持JSON、XML等通用数据格式</li></ul><p><strong>服务发现：</strong>服务发现使得系统组件能动态地找到彼此的位置，尤其是在分布式环境中。</p><ul><li>客户端发现模式：客户端通过服务注册表查找其他服务的位置。比如NetflixEureka</li><li>服务器端发现模式：客户端将请求发送到负载均衡器，由负载均衡器查找服务。比如AWSElastic Load Balancing</li><li>DNS发现：通过DNS查找服务。比如Kubernete的CoreDNS</li></ul><p><strong>数据转换：</strong></p><ul><li>数据网关：在不同数据格式间转换。APIGateway将JSON数据转换为XML数据</li><li>中间件：提供不同系统之间的桥梁，解决协议或数据不匹配的问题</li></ul><p><strong>API设计：</strong></p><ul><li>提供清晰的文档和版本控制</li><li>使用工具如 Swagger/OpenAPI自动生成文档</li></ul><h1 id="架构模式">架构模式</h1><h2 id="p2p">P2P</h2><h3 id="简介">简介</h3><p><strong>概述：</strong> Peer to Peer是一种分布式网络架构，其中每个节点(Peer)既可以充当客户端发送请求，也可以充当服务器响应请求。与传统的客户端-服务器模型不同，P2P取消了中心化的控制节点，所有节点地位平等</p><p><strong>基本概念：</strong></p><ul><li>节点(Peer)：系统中的每个实体都称为节点，既可以请求服务，也可以提供服务</li><li>去中心化：系统中不存在单一的中央控制点或服务器，减少了单点故障</li><li>资源共享：节点共享计算机资源（如存储、带宽）以提高整体效率</li><li>动态拓扑：节点可以自由加入和离开网络，网络拓扑结构可能会实时变化</li><li>分布式查找与路由：数据存储和检索由多个节点协同完成，典型算法由DHT(分布式哈希表)和超节点路由</li></ul><h3 id="相关的qa">相关的QA</h3><h4 id="可用性">可用性</h4><p><strong>挑战：</strong></p><ul><li>节点动态加入和离开可能导致网络不稳定</li><li>数据丢失或部分节点不可用时，服务可能受到影响</li></ul><p><strong>相关策略：</strong></p><ul><li>数据冗余与副本存储：将数据复制到多个节点以提高数据可用性</li><li>智能路由 与重试机制：在节点故障时，自动重新路由请求到其他节点</li><li>超节点：在纯P2P网络中引入部分高性能节点，负责关键任务（如路由或数据存储）</li></ul><h4 id="性能">性能</h4><p><strong>挑战：</strong></p><ul><li>网络通信延迟：因分布式特性，节点间通信可能较慢</li><li>数据检索效率：节点数量庞大时，查找目标数据可能耗时较长</li></ul><p><strong>相关策略：</strong></p><ul><li>缓存策略(Caching)：在常用节点间缓存常用数据以减少通信延迟</li><li>高效路由协议：采用如Chord和Kademlia的DHT算法，优化节点间查找</li><li>负载均衡：将任务动态分配到多个节点，避免部分节点过载</li></ul><h4 id="可靠性">可靠性</h4><p><strong>挑战：</strong></p><ul><li>节点故障可能导致数据丢失或网络分割</li><li>系统规模扩大可能影响网络健壮性</li></ul><p><strong>相关策略：</strong></p><ul><li>容错机制(FaultTolerance)：通过校验和机制、节点间心跳检测确保网络健壮性</li><li>定期同步：确保副本数据一致性和完整性</li></ul><h4 id="可扩展性">可扩展性</h4><p><strong>挑战：</strong></p><ul><li>节点数量大幅增加时，可能引发网络拥堵或管理复杂度</li></ul><p><strong>相关策略：</strong></p><ul><li>分层架构：通过超节点实现逻辑分区管理，减少全网通信</li><li>动态负载均衡：实时检测并调整节点任务分配，减轻单点压力</li></ul><h3 id="优势">优势</h3><ul><li>去中心化</li><li>高扩展性</li><li>高资源利用率</li><li>低成本</li></ul><h3 id="弱点及改进方法">弱点及改进方法</h3><p><strong>不稳定性（节点频繁加入或离开）：</strong></p><ul><li>使用稳定性协议（如Gossip协议）快速感知网络拓扑变化</li><li>引入超节点机制，让稳定节点承担重要角色</li></ul><p><strong>数据一致性问题：</strong></p><ul><li>使用强一致性模型（如Paxos、Raft）保障关键数据的一致性</li><li>引入事件驱动的同步机制确保节点间的状态同步</li></ul><p><strong>安全问题：</strong></p><ul><li>采用加密通信（如TLS）防止数据泄露</li><li>通过认证机制防止恶意节点加入</li></ul><p><strong>查找效率问题：</strong></p><ul><li>优化分布式哈希表(DHT)路由协议（如Kademlia的高效查找算法）</li><li>引入缓存机制减少频繁数据查找</li></ul><h3 id="跟踪">跟踪</h3><p><strong>跟踪系统需要监控以下方面：</strong></p><ul><li>节点状态：监控节点的在线状态、负载情况以及资源利用率</li><li>网络拓扑：实时可视化网络连接结构，记录拓扑变化</li><li>数据传输：跟踪数据传输延迟、吞吐量以及失败率</li><li>故障日志：记录节点故障、网络分裂等异常事件，用于分析和改进</li></ul><p><strong>工具和技术：</strong></p><ul><li>分布式监控系统，如Prometheus和ELK</li><li>去中心化追踪协议，如分布式日志协议</li></ul><h2 id="mapreduce">MapReduce</h2><p><strong>概述：</strong>是一种分布式计算架构模式，用于处理和生成大规模数据库。核心思想是将任务分为映射(Map)和归约(Reduce)两个阶段，适用于大规模数据的并行处理</p><h3 id="核心概念">核心概念</h3><p><strong>映射(Map)：</strong></p><ul><li>将输入数据分割成小的子任务，每个子任务独立处理</li><li>通过映射函数生成键值对(Key-Value Pair)，便于后续分组和归约</li></ul><p><strong>归约(Reduce)：</strong></p><ul><li>将映射阶段生成的中间键值对按照键分组</li><li>对每个分组应用归约函数，聚合或总结结果，生成最终输出</li></ul><p><strong>分发(Distribution)：</strong></p><ul><li>数据和任务分布在多个节点上进行并行计算</li><li>中间结果通过分布式存储进行管理</li></ul><p><strong>容错机制：</strong></p><ul><li>由于MapReduce在分布式环境中运行，节点可能发生故障，系统会自动重新分配失败任务，确保整体计算的完成</li></ul><h3 id="工作流程">工作流程</h3><ol type="1"><li>数据分片(DataSplitting)：将输入数据划分成固定大小的分片(Split)，分配到各个计算节点</li><li>Map阶段：每个节点运行Map函数，将数据转换为中间键值对</li><li>Shuffle阶段（分组与排序）：<ul><li>将Map输出的中间结果根据键值分组并排序</li><li>分发到相应的Reduce节点</li></ul></li><li>Reduce阶段：每个Reduce节点对每组数据运行归约函数，生成最终结果</li><li>结果输出：通常存储在分布式文件系统中</li></ol><h3 id="相关的qa-1">相关的QA</h3><p><strong>可扩展性(Scalability)：</strong></p><ul><li>特点：支持通过增加节点扩展处理能力</li><li>策略：任务分片和分发机制，使任务能够动态适应集群大小</li></ul><p><strong>性能(Performance)：</strong></p><ul><li>特点：支持大规模并行计算</li><li>策略：<ul><li>数据本地化（将任务调度到数据所在节点）</li><li>任务管道化（不同阶段的任务同时运行）</li></ul></li></ul><p><strong>可靠性(Reliability)：</strong></p><ul><li>特点：内置容错机制，支持节点故障恢复</li><li>策略：<ul><li>定期存储中间结果（快照）</li><li>使用任务重试机制处理失败任务</li></ul></li></ul><p><strong>可用性(Availability)：</strong></p><ul><li>特点：分布式存储和计算，避免单点故障</li><li>策略：<ul><li>主节点和从节点分工协作</li><li>使用分布式文件系统（如HDFS）保证数据持久性</li></ul></li></ul><h3 id="优势-1">优势</h3><ul><li>高并行性：分布式任务分配使得多个节点可以同时处理任务，提高效率</li><li>容错能力：自动任务重试和故障节点检测保证计算任务顺利完成</li><li>易于扩展：可以通过增加节点线性扩展系统性能</li><li>适应大规模数据库：适合对TB到PB级别的大数据集进行处理</li></ul><h3 id="弱点及改进方法-1">弱点及改进方法</h3><p><strong>数据传输开销大：</strong></p><ul><li>问题：Map和Reduce阶段之间的数据传输量可能非常打，导致性能瓶颈</li><li>改进方法：<ul><li>使用压缩减少数据传输量</li><li>优化Shuffle阶段的分组算法（如预分区）</li></ul></li></ul><p><strong>不适合低延迟应用：</strong></p><ul><li>问题：MapReduce的批处理模式对实时性要求高的应用效果较差</li><li>改进方法：<ul><li>使用Spark的内存计算替代MapReduce的磁盘IO模式</li></ul></li></ul><p><strong>编程模型有限：</strong></p><ul><li>问题：MapReduce的编程模型适合线性任务，但对复杂逻辑支持有限</li><li>改进方法：<ul><li>使用更高级的分布式计算框架（如Flink、Beam）</li></ul></li></ul><p><strong>单点故障风险：</strong></p><ul><li>问题：主节点失效可能导致整个任务失败</li><li>改进方法：<ul><li>主节点高可用配置</li><li>使用分布式协调服务（如ZooKeeper）管理任务</li></ul></li></ul><h3 id="应用场景">应用场景</h3><ul><li>大规模日志处理：分析网站访问日志、提取用户行为模式</li><li>搜索引擎索引构建：解析网页内容并生成倒排索引</li><li>分布式数据库处理：数据清洗、排序、聚合等操作</li><li>机器学习训练：并行计算模型参数</li></ul><h2 id="pubsub">Pub/Sub</h2><p><strong>概述：</strong>Pub/Sub是一种面向消息通信的架构模式，适用于松散耦合的系统。在该模式中，发布者(Publisher)和订阅者(Subscriber)不直接交互，而是通过一个消息代理(Broker)或事件总线作为中介，实现消息的分发和处理。</p><h3 id="核心概念-1">核心概念</h3><p><strong>发布者：</strong></p><ul><li>负责生成消息或事件并发送给消息代理</li><li>特点：不关心谁会接收消息，只专注于生产</li></ul><p><strong>订阅者：</strong></p><ul><li>通过消息代理订阅感兴趣的消息类型</li><li>特点：只处理于自身相关的消息，不关系消息来源</li></ul><p><strong>消息代理(Message Broker)：</strong></p><ul><li>作为中间层，负责消息的路由、分发和存储</li><li>典型实现包括RabbitMQ、Kafka、ActiveMQ</li></ul><h3 id="工作流程-1">工作流程</h3><p><strong>基本步骤：</strong></p><ol type="1"><li>发布者将消息发送到消息代理，并附带消息的主题或标签（Topic/Channel）</li><li>消息代理根据主题或标签，将消息分类并存储</li><li>已订阅相关主题的订阅者接收消息代理推送的消息</li></ol><p><strong>消息类型：</strong></p><ul><li>主题(Topic)：一种广播模式，消息发送到一个特定的主题，所有订阅者均可接收</li><li>队列(Queue)：一种点对点模式，消息按FIFO顺序分发给单个订阅者</li></ul><h3 id="相关的qa-2">相关的QA</h3><p><strong>可扩展性(Scalability)：</strong></p><ul><li>特点：通过分布式消息代理扩展系统处理能力</li><li>策略：<ul><li>分片消息存储</li><li>使用多个代理节点均衡负载（如Kafka的分区）</li></ul></li></ul><p><strong>可用性(Availability)：</strong></p><ul><li>特点：分布式架构和副本机制确保消息持久化和高可用</li><li>策略：<ul><li>副本存储（如Kafka）</li><li>主从备份和自动故障转移</li></ul></li></ul><p><strong>性能(Performance)：</strong></p><ul><li>特点：支持高吞吐量的并行消息处理</li><li>策略：<ul><li>使用批量传输降低网络开销</li><li>消息压缩优化传输性能</li></ul></li></ul><p><strong>可靠性(Reliability)：</strong></p><ul><li>特点：确保消息不丢失或重复传递</li><li>策略：<ul><li>消息确认机制(ACK/NACK)</li><li>使用事务性消息处理</li></ul></li></ul><h3 id="优势-2">优势</h3><ul><li>松耦合：发布者和订阅者互相独立，通过消息代理解耦</li><li>高扩展性</li><li>异步通信</li></ul><h3 id="弱点及改进方法-2">弱点及改进方法</h3><p><strong>延迟问题：</strong></p><ul><li>问题：消息代理可能称为瓶颈，导致消息延迟增加</li><li>改进方法：<ul><li>增加代理节点，提升并发处理能力</li><li>优化网络协议（如使用gRPC替代HTTP）</li></ul></li></ul><p><strong>消息丢失风险：</strong></p><ul><li>问题：系统崩溃或网络中断可能导致消息丢失</li><li>改进方法：<ul><li>使用持久化存储</li><li>消息代理支持事务性消息</li></ul></li></ul><p><strong>重复消息处理：</strong></p><ul><li>问题：消息代理可能导致重复消息发送</li><li>改进方法：<ul><li>使用幂等性设计，在订阅者侧确保重复消息无害</li><li>消息代理引入唯一标识符</li></ul></li></ul><p><strong>运维复杂性：</strong></p><ul><li>问题：分布式消息代理系统需要专业运维</li><li>改进方法：<ul><li>引入自动化运维工具（Kubernetes</li><li>使用托管服务（AWS SNS、Azure Service Bus</li></ul></li></ul><h3 id="应用场景-1">应用场景</h3><ul><li>实时事件驱动系统</li><li>分布式日志处理（如Kafka）</li><li>消息通知和广播系统（如电子邮件、短信通知）</li><li>流处理：分析实时数据流</li></ul><h2 id="mvc">MVC</h2><p><strong>概述：</strong> Model-View-Controller广泛应用于构建交互式应用程序，特别是在Web开发中。MVC模式通过将应用程序分为三个主要部分：模型、视图和控制器实现了关注点分离(Sperationof Concerns)，使得代码更加模块化、可维护和可扩展</p><h3 id="核心概念-2">核心概念</h3><p><strong>模型：</strong></p><ul><li>职责：负责处理应用程序的核心数据和业务逻辑，它代表了应用程序的状态、数据以及数据库或其他持久化存储交互的功能</li><li>特点：<ul><li>包含数据结构（如对象、表格、文档等）</li><li>提供数据访问和业务逻辑操作的接口</li><li>不依赖于视图或控制器，可以单独测试或维护</li></ul></li></ul><p><strong>视图：</strong></p><ul><li>职责：负责显示模型的数据，并为用户提供交互界面，是用于与系统交互的界面部分，通常是HTML页面、桌面窗口或移动界面等</li><li>特点：<ul><li>视图与模型解耦，只关心如何展示数据，而不关心数据的实际来源</li><li>接收用户输入，但不会直接处理这些输入，通常将其传递给控制器</li></ul></li></ul><p><strong>控制器：</strong></p><ul><li>职责：负责接收用户输入、处理用户请求并更新模型和视图。它是视图和模型之间的中间层，确保数据流和控制流的正确性</li><li>特点：<ul><li>接收用户操作（如点击按钮、提交表单）并调用模型进行数据更新</li><li>根据模型的变化更新视图，或者根据用户输入选择展示不同的视图</li></ul></li></ul><h3 id="工作流程-2">工作流程</h3><ol type="1"><li>用户通过视图与应用交互</li><li>用户的输入事件被控制器捕捉，控制器将请求转发给模型</li><li>模型根据控制器的请求处理数据，并更新状态</li><li>模型状态变化后，控制器更新视图，重新渲染数据给用户</li></ol><p>用户输入 -&gt; 控制器 -&gt; 模型 -&gt; 控制器 -&gt; 视图</p><h3 id="相关的qa-3">相关的QA</h3><p><strong>可扩展性(Scalability)：</strong></p><ul><li>特点：由于MVC模式将应用程序的不同部分分离，可以独立扩展模型、是视图和控制器</li><li>策略：<ul><li>模型和视图可以在不同的服务中扩展，控制器可以通过路由机制动态处理不同的请求</li></ul></li></ul><p><strong>可维护性(Maintainability)：</strong></p><ul><li>特点：通过关注点分离，MVC使得应用程序的各个部分更易于修改和扩展</li><li>策略：<ul><li>通过解耦的设计，修改模型、视图或控制器的一部分不影响其他部分</li><li>可以在不同层次独立进行单元测试</li></ul></li></ul><p><strong>可重用性(Reusability)：</strong></p><ul><li>特点：模块化设计促进了不同部分的宠用，视图和控制器可以多次复用</li><li>策略：<ul><li>视图和模型的解耦使得同一模型可以支持多个视图形式</li></ul></li></ul><h3 id="优势-3">优势</h3><ul><li>关注点分离</li><li>易于维护和扩展</li><li>支持多种视图展示（Web、桌面、移动程序）</li><li>提高开发效率</li></ul><h3 id="弱点及改进方法-3">弱点及改进方法</h3><p><strong>复杂性增加：</strong></p><ul><li>问题：MVC模式处理简单应用时可能显得过于复杂</li><li>改进方法：<ul><li>对于小型项目可以采用MVVM、MVP等轻量设计模式</li><li>在MVC中加入设计模式，如工厂模式和策略模式减轻复杂性</li></ul></li></ul><p><strong>不适用所有应用：</strong></p><ul><li>问题：MVC模式特别适合数据驱动型应用，但对于具有复杂界面和业务逻辑的应用可能不够灵活</li><li>改进方法：使用MVVM或MVP</li></ul><h3 id="应用场景-2">应用场景</h3><ul><li>许多Web框架如Django、Rails、Sping MVC</li><li>桌面开发框架如Java Swing、.NET WinForms等</li><li>移动应用开发</li></ul><h2 id="pipe-and-filter">Pipe-and-Filter</h2><p><strong>概述：</strong>管道-过滤器是一种常用于数据流处理的架构模式，特别适合处理流数据或需要依次处理多个阶段的任务。这个模式将应用程序的处理过程分解为多个独立的过滤器，并通过管道将过滤器连接起来。</p><h3 id="核心概念-3">核心概念</h3><p><strong>过滤器(Filter)：</strong></p><ul><li>职责：是管道中的一个处理单元，负责对输入数据进行某种处理（如数据转换、过滤、聚合等）。每个过滤器通常是单一职责的、独立进行某一特定任务</li><li>特点：<ul><li>接收输入数据，处理并输出结果</li><li>通常具有清晰的输入和输出接口</li><li>过滤器之间没有直接的依赖关系，增加或修改一个过滤器不会影响其他部分</li></ul></li></ul><p><strong>管道(Pipe)：</strong></p><ul><li>职责：管道用于连接各个过滤器，数据通过管道从一个过滤器流向下一个过滤器</li><li>特点：<ul><li>管道是数据的传输通道，允许过滤器之间的数据流动</li><li>数据本身通常不进行任何数据处理，只负责传输数据</li></ul></li></ul><h3 id="工作流程-3">工作流程</h3><ol type="1"><li>数据输入：输入数据流经过管道进入第一个过滤器</li><li>数据处理：第一个过滤器处理数据，并将结果输出到下一个过滤器</li><li>数据传递：每个过滤器接收前一个过滤器的输出，进行处理，然后将结果传递给下一个过滤器</li><li>数据输出：最终通过管道传递给输出端</li></ol><h3 id="相关的qa-4">相关的QA</h3><p><strong>可扩展性(Scalability)：</strong></p><ul><li>特点：可以灵活地通过增加新的过滤器或管道来扩展系统</li><li>策略：<ul><li>增加更多过滤器来处理不同的任务</li><li>通过多线程或分布式计算提升性能和吞吐量</li></ul></li></ul><p><strong>可维护性(Maintainability)：</strong></p><ul><li>特点：每个过滤器都是独立的模块，易于修改和替换，不会影响整个系统</li><li>策略：<ul><li>可以独立测试和更新每个过滤器</li><li>新功能可以通过添加新的过滤器来实现，而不需要重构整个系统</li></ul></li></ul><p><strong>性能(Performance)：</strong></p><ul><li>特点：是用于处理大量数据的场景，尤其是当数据需要经过多个独立处理阶段时</li><li>策略：<ul><li>通过管道并行化或分布式处理提升性能</li><li>针对每个过滤器的性能进行优化</li></ul></li></ul><h3 id="优势-4">优势</h3><ul><li>模块化设计</li><li>可扩展性强</li><li>清晰的责任分离</li><li>简化调试与测试</li><li>支持并行处理</li></ul><h3 id="弱点及改进方法-4">弱点及改进方法</h3><p><strong>数据传输开销：</strong></p><ul><li>问题：每个过滤器需要通过管道传递数据，可能会引入性能开销，特别时数据需要频繁地在过滤器之间传递时</li><li>改进方法：<ul><li>可以优化管道的设计，减少不必要的传输步骤</li><li>在需要时将数据批量处理，减少管道开销</li></ul></li></ul><p><strong>过滤器之间的依赖问题：</strong></p><ul><li>问题：如果过滤器之间存在数据依赖关系，处理链可能变得复杂</li><li>改进方法：<ul><li>在设计时尽量减少过滤器间的依赖，可以通过异步处理或消息队列进行解耦</li></ul></li></ul><p><strong>错误处理和恢复：</strong></p><ul><li>问题：由于过滤器通常是单向流动的数据，错误可能在中间阶段发生，导致整个数据流失败</li><li>改进方法：<ul><li>引入容错机制，例如在每个过滤器中加入错误捕获和恢复策略</li><li>使用事务会回滚机制来确保数据处理的可靠性</li></ul></li></ul><h3 id="应用场景-3">应用场景</h3><ul><li>数据流处理系统：如数据分析系统，ETL工具</li><li>编译器：编译器的各个阶段（如词法分析、语法分析、优化）通常会采用管道与过滤器模式，每个过滤器负责特定的编译任务</li><li>日志处理系统：在日志收集与分析系统中，日志数据通过多个过滤器进行预处理（如解析日志格式、过滤敏感信息、转换日志格式等）</li><li>音视频处理系统：在音视频流处理中，每个过滤器负责处理视频帧、音频数据、最后输出处理后的流媒体数据</li></ul><h1 id="软件架构设计和评估工具">软件架构设计和评估工具</h1><h2 id="atam">ATAM</h2><p><strong>概述：</strong> Architecture Tradeoff Analysis Method是一种架构评估方法，旨在帮助架构师和团队分析软件架构的质量属性和设计决策之间的权衡(tradeoff)，并帮助确定最适合项目的设计决策</p><p><strong>步骤：</strong></p><ol type="1"><li>准备阶段：<ul><li>选择架构团队：组件由架构师、开发人员、质量保证人员以及可能的利益相关者组成的评估团队</li><li>收集架构文档：准备架构文件、设计描述、功能要求等，以便评估</li></ul></li><li>质量属性场景的定义：<ul><li>需求收集：收集系统的主要质量属性要求（如性能、安全性等）</li><li>场景定义：与利益相关者一起，确定系统必须处理的关键场景，这些场景描述了系统如何在不同条件下运行，以及如何满足质量属性</li></ul></li><li>架构分析：<ul><li>识别架构决策：通过分析架构设计，识别与质量属性相关的架构设计决策</li><li>分析权衡：评估不同设计决策如何影响系统的质量属性，并识别潜在的权衡点。例如，提高系统的可扩展性可能会降低可维护性</li></ul></li><li>风险识别与评估：<ul><li>识别风险：基于架构决策的分析，识别可能影响系统成功的关键风险</li><li>评估风险的影响：评估每个风险的严重性和可能性，并提出相应的缓解措施</li></ul></li><li>总结与报告：<ul><li>总结结果：撰写评估报告，包含架构决策、风险、权衡和改进建议</li><li>建议架构改进：为架构的改进和优化提出建议，帮助架构团队做出更合适的设计决策</li></ul></li></ol><p><strong>优势：</strong></p><ul><li>帮助识别架构设计中潜在风险和问题</li><li>使架构决策变得更加透明，并为利益相关者提供更清晰的决策依据</li><li>促进架构师之间的沟通和协作</li></ul><h2 id="asrs">ASRs</h2><p><strong>概述：</strong> Architecture SignificantRequirements（架构显著需求）是影响软件架构设计的关键需求。它们不仅定义了系统的功能需求，还涉及到性能、安全性、可用性、扩展性等质量属性。ASRs通常决定了架构涉及的关键决策，并且对架构的整体结构、组件、接口设计等有重大影响</p><p><strong>步骤：</strong></p><ol type="1"><li>需求收集：<ul><li>从项目的需求文档、利益相关者会议等来源收集所有功能性和非功能性需求</li><li>需求通常被分为“显著需求”和“普通需求”，显著需求(ASRs)是那些直接影响架构设计的需求</li></ul></li><li>需求分类：<ul><li>功能性需求：描述系统需要做说明（如用户认证、数据处理等）</li><li>非功能性需求：描述系统应如何做（如性能、可用性、可扩展性等）</li></ul></li><li>识别ASRs：<ul><li>从非功能性需求中，选择那些对架构有重大影响的需求。例如，若一个系统需要高并发数据访问，这将影响系统的架构设计，需要考虑性能、可扩展性等架构方面的决策</li></ul></li><li>跟踪ASRs变化：<ul><li>在软件开发过程中，跟踪ASRs的变化，确保架构设计始终符合这些关键需求</li></ul></li></ol><p><strong>优势：</strong></p><ul><li>确保架构设计能够有效地满足项目的关键需求</li><li>通过定义ASRs，有助于明确架构的设计目标和评估标准</li></ul><h2 id="add">ADD</h2><p><strong>概述：</strong> Attribute-Driven Design是一种迭代方法，允许架构师选择系统的一部分进行设计，并为这一部分所有具有架构意义的需求，然后创建并测试针对这一部分的设计。ADD的核心是围绕系统的质量属性，逐步细化架构，同时满足功能和非功能需求</p><p><strong>关键点：</strong></p><ul><li>基于系统的QA和ASR来驱动设计过程的</li><li>是一种迭代方法，强调逐步设计和验证架构</li></ul><h2 id="utility-tree">Utility Tree</h2><p><strong>概述：</strong>效用树是用于分析架构决策对质量属性的影响的工具。它是ATAM方法的一部分，帮助架构师和评估者理解不同设计决策对系统QA的具体影响。效应树通过将质量属性的要求分解为更小的子目标，帮助团队识别优先级最高的QA需求，并在架构设计中做出相应的权衡</p><p><strong>步骤：</strong></p><ol type="1"><li>定义质量属性</li><li>构建效用树：<ul><li>将每个QA进一步分解为更小的子目标。子目标描述了如何衡量和优化该QA</li><li>例如，性能的目标可以分解为“响应时间”、“吞吐量”、“并发性”等</li></ul></li><li>确定优先级：<ul><li>根据项目的需求和目标，评估不同QA和子目标的优先级。哪些QA对项目的成功最为关键，哪些是可以在后续阶段优化的</li></ul></li><li>评估架构决策：<ul><li>使用效用树来评估架构设计中的各个决策，通过分析这些决策如何影响不同QA和子目标，架构师可以更好地衡量结果</li></ul></li><li>更新和调整：<ul><li>在项目进展中，根据实际情况和需求变化调整效用树，确保架构设计能够始终满足关键QA需求</li></ul></li></ol><p><strong>优势：</strong></p><ul><li>提供了一种系统化的方式来分析和优化QA</li><li>帮助团队聚焦于最重要的QA，并确保这些QA在架构设计中得到优先考虑</li></ul><h2 id="参与者角色">参与者角色</h2><p><strong>概述：</strong> Participants' Roles是指在架构过程中的不同参与者及其职责。</p><p><strong>架构师(Architect)：</strong>是架构设计过程中的核心任务，负责整体架构的设计、决策和指导。架构师在设计和决策过程中通常具有主导地位，确保系统架构能够满足所有QA</p><ul><li>定义系统架构、技术堆栈和设计模式</li><li>确保架构能满足业务需求和质量属性需求</li><li>管理架构的复杂性，并确保其可扩展性和可维护性</li><li>在系统生命周期中，跟踪架构的变化，确保其与需求变化一致性</li><li>为开发团队提供架构指导，并解答架构相关问题</li></ul><p><strong>开发人员(Developer)：</strong>负责根据架构师的设计实现具体的功能和模块。开发人员通常会根据架构文档和设计方案来编码和构建系统的各个部分，并可能会在实现过程中提出技术上的改进建议</p><ul><li>根据架构设计实现系统功能</li><li>保证代码质量，遵循架构设计中的约定和标准</li><li>与架构师和其他开发人员合作，确保各个模块的接口和交互符合架构要求</li><li>参与单元测试和系统集成，确保架构的实现能够顺利工作</li></ul><p><strong>项目经理(Project Manager)：</strong>负责管理项目的进度、资源、预算和团队协作。虽然项目经理不直接参与架构设计，但他们必须确保架构设计能够按时完成，并满足项目的资源需求和时间安排</p><ul><li>管理项目进度和风险，确保架构设计按计划完成</li><li>协调各方参与者的合作</li><li>跟踪项目预算和资源分配，确保架构设计能够在可用资源范围内实现</li><li>与客户和利益相关者沟通，确保架构设计符合业务需求</li></ul><p><strong>测试人员(Tester)：</strong>验证架构设计和实现的系统是否符合质量标准。测试人员会根据架构文档和需求文档设计测试用例，并执行各种测试（单元测试、集成测试、系统测试等），确保架构的正确性和可靠性</p><ul><li>设计和执行测试用例，确保系统的各项功能和QA符合要求</li><li>发现系统中的缺陷并报告给开发人员</li><li>参与架构评审和风险评估，帮助架构师识别潜在的设计问题</li><li>确保架构实现具有高可用性、可扩展性和安全性等关键QA</li></ul><p><strong>利益相关者(Stakenholder)：</strong>是对系统有直接或间接影响的人或组织。他们可以是业务人员、客户、终端用户、市场团队、法律团队等。利益相关者通常不会直接参与架构设计，但他们提供需求和反馈，这些反馈对架构设计的调整和优化至关重要</p><ul><li>提供系统需求，确保架构能够满足业务目标</li><li>提供对架构设计和决策的反馈</li><li>参与架构评审过程，确保架构设计与业务需求一致</li><li>根据系统运行和维护的情况，提出对架构的改进建议</li></ul><p><strong>安全专家(Security Expert)：</strong>负责确保架构在设计和实现过程中满足安全性要求</p><ul><li>识别架构设计中的安全风险，并提出相应的改进措施</li><li>设计并实施安全控制措施，如身份认证、数据加密和访问控制</li><li>在架构评审过程中审查系统的安全性，并验证架构是否符合安全最佳实践</li></ul><h1 id="开放题">开放题</h1><h2id="抽象公共服务策略旨在减少耦合但它也可能降低内聚性">抽象公共服务策略旨在减少耦合，但它也可能降低内聚性</h2><p><strong>耦合与内聚性：</strong></p><ul><li>耦合(Coupling)：指的是系统中各个模块或组件之间的依赖关系。耦合越低，意味着模块间的依赖越少，系统的各个部分相对独立，便于维护和扩展。</li><li>内聚性(Cohesion)：指的是模块内部各个组件或功能之间的关联程度。内聚性越高，意味着模块内的功能和组件越紧密地协作。</li></ul><p><strong>抽象公共服务策略：</strong></p><ul><li>指的是将系统中多个组件共享的功能或服务进行抽象，形成一个公共的服务层。这样，多个组件可以通过访问这个公共服务来避免重复实现相同的功能。通常，公共服务通过定义接口或服务抽象层来隐藏具体的实现细节</li><li>示例：一个电商系统中有多个模块（如支付、订单、用户管理等），这些模块可能会共享某些基础功能，如日志记录、身份验证、数据库访问等。为了避免各个模块重复实现这些功能，设计师可能会将这些功能抽象成一个公共服务，所有模块通过调用这个公共服务来获得这些功能</li></ul><p><strong>减少耦合：</strong></p><ul><li><p>抽象公共服务策略的核心目的是减少耦合，通过将常见的功能抽象成公共服务，系统的各个模块可以通过该服务进行交互，而不需要知道具体的实现细节。这种设计使得模块间的依赖减少，因为每个模块不再需要直接引用其他模块的具体实现，只需要依赖于公共服务的接口，这种松散的耦合关系提高了系统的灵活性和可维护性</p></li><li><p>示例：支付模块可以通过公共的支付服务接口来进行支付处理，这样更容易地修改或替换支付服务而不影响其他模块</p></li></ul><p><strong>可能降低内聚性：</strong></p><ul><li>因为通过抽象和拆分系统功能，可能会使得一些模块的职责变得不再单一，甚至不再专注于一个功能领域</li><li>示例：支付模块本应该专注于支付相关的逻辑，但如果它频繁地依赖于公共服务层来进行日志记录、身份验证等功能，那么支付模块的职责就变得不那么清晰，变得更加“分散”。虽然各个服务可以独立开发和维护，但这也可能导致模块的功能变得不再紧密相关，降低了模块内部的内聚性。</li></ul><h2id="讨论编程语言的选择技术选择的一个例子及其与体系结构的一般关系">讨论编程语言的选择（技术选择的一个例子）及其与体系结构的一般关系</h2><h3 id="编程语言选择的考虑因素">编程语言选择的考虑因素</h3><p><strong>系统需求与目标：</strong></p><ul><li>性能要求：对于高性能系统（如游戏引擎、实时系统等），可能需要选择具有高执行效率的编程语言，如C/C++</li><li>开发速度与易用性：如果系统需要快速开发，且业务逻辑比较复杂，可能更倾向于选择动态语言，如Python、Ruby或JavaScript，这些语言具有丰富的库和框架支持，可以大大加快开发速度</li><li>并发和分布式处理：对于需要大量并发处理的系统（如大规模分布式系统、云计算平台等），可以能会选择Go、Erlang、Rust这样的语言，它们内建强大的并发支持</li></ul><p><strong>体系结构的需求：</strong></p><ul><li>微服务架构：在微服务架构中，每个微服务可能采用不同的技术栈和编程与语言，可能是Java或C#，因为它们在企业级应用中有成熟的支持，而另一些微服务可能使用Go或Node.js，因为它们能够高效地处理并发请求</li><li>服务器无关架构：如果架构目标是跨平台或无服务器架构（如云函数），编程语言的选择就变得更加最重要。选择支持容器化（Docker）和五服务器架构的语言（如Node.js、Python或Go）可能会使得系统更容易部署到云平台上</li></ul><p><strong>团队技术栈与经验：</strong></p><p>如果团队对某种语言有很强的熟练度，可以选择该语言提高开发效率和降低学习曲线。</p><p><strong>性能与资源限制：</strong></p><p>对于资源受限的系统（如嵌入式设备或移动设备），可能需要选择更加轻量级的语言或针对硬件优化的语言。例如C或Rust在性能和内存管理方面的控制能力优于Java或Python。</p><p><strong>维护和可扩展性：</strong></p><p>某些编程语言的设计理念和生态系统使得它们更适合维护和扩展，比如Java和C#</p><h3 id="编程语言与体系架构的关系">编程语言与体系架构的关系</h3><p><strong>架构风格的选择：</strong></p><ul><li>微服务架构：强调系统由多个独立的服务组成，每个服务可以使用不同的编程语言和技术栈。因此在这种架构下，编程语言的选择更多地受到服务单元的需求和团队技术栈的影响。</li><li>单体架构：所有的功能和模块都紧密耦合在一个应用中，可能需要选择一个同一的编程语言，通常是企业级语言，如Java或C#</li><li>事件驱动架构：强调系统通过事件进行通信和处理，语言的选择需要考虑事件流的高效处理。例如Node.js由于其事件驱动和非阻塞IO的特性，适合开发高并发的事件驱动系统。</li></ul><p><strong>架构的可扩展性与性能：</strong></p><ul><li>高并发和分布式系统：如GO和Erlang天生适合高并发和分布式系统，因为它们在并发处理、消息传递和容错方面具有内建的支持。</li><li>性能优化：对于需要极高性能的系统，如实时系统或需要低延迟的交易系统，选择像C++或Rust这样的语言，可以更好低控制内存和硬件资源，从而使得架构就具有更高的执行效率和更低的资源消耗</li></ul><p><strong>架构的可维护性和开发效率：</strong></p><ul><li>可维护性：面向对象编程语言提供了良好的模块化和封装特性，适合开发大型企业级应用。相比之下Python和Ruby提供了更简单的语法和更快的开发周期</li><li>开发效率：一些编程语言（如Python、Javascript）在开发速度和生态系统支持方面非常强大，适合快速构建和原型支持，通常用于敏捷开发方法中</li></ul><h2id="设计高可测试性和高容错性的系统">设计高可测试性和高容错性的系统</h2><p><strong>可测试性：</strong>使系统中的故障能够快速且轻松地暴露，以便在测试阶段能够检测并恢复故障</p><p><strong>容错性：</strong>使系统在运行时“隐藏”故障，通过机制如冗余、回退或恢复，确保系统在故障发生时仍能正常运行</p><p><strong>兼容可测试性和容错性的设计方法：</strong></p><ul><li>故障注入测试：通过在测试阶段主动引入故障，观察系统的响应能力，从而兼容容错性和可测试性的目标。例如：<ul><li>在分布式系统中模拟节点故障</li><li>注入网络延迟、数据损坏等问题以测试容错机制</li></ul></li><li>增强日志和可观测性：<ul><li>使用详细的日志记录和监控工具，暴露系统的内部状态</li><li>即使容错机制正在掩盖故障，日志和监控可以帮助开发者了解系统运行过程中的潜在问题</li></ul></li><li>测试模式与生产模式分离：<ul><li>测试模式：在测试环境，禁用部分容错机制，允许故障显现并方便调试</li><li>生产模式：启用完整的容错机制，确保系统的稳健运行</li></ul></li><li>优雅降级：<ul><li>设计容错机制时，使其在功能降级的同时保留部分信息暴露。比如当某个模块失效时，显示“降级模式”警告而非完全隐藏问题</li></ul></li><li>冗余机制双重用途：<ul><li>使用冗余组件不仅用于容错，还可以在测试阶段使用冗余组件来捕获隐藏的故障</li><li>例如在分布式系统中，通过比较多个副本的输出来检测潜在错误</li></ul></li></ul><h2id="为atm设计安全性场景并修改其设计以满足这些场景">为ATM设计安全性场景，并修改其设计以满足这些场景</h2><h3 id="安全性场景设计">安全性场景设计</h3><p><strong>防止未授权访问</strong></p><ul><li>场景描述：某用户尝试插入银行卡，但输入了三次错误的PIN码，系统应锁定该帐户并通知银行后台</li><li>安全需求：<ul><li>必须限制PIN码的尝试次数</li><li>系统需实时记录帐户锁定事件并发送通知</li></ul></li></ul><p><strong>防止数据泄露：</strong></p><ul><li>场景描述：ATM与银行服务器之间传输的数据被第三方拦截。需要确保敏感数据（如PIN码、帐户信息）不被窃取</li><li>安全需求：<ul><li>数据传输必须采用加密协议（如TLS）</li><li>PIN码等敏感信息在传输和存储时需加密</li></ul></li></ul><p><strong>防止内部攻击</strong></p><ul><li>场景描述：内部工作人员尝试通过直接访问ATM设备或后端系统窃取用户数据。</li><li>安全需求：<ul><li>系统需记录并监控所有管理员操作。</li><li>后端访问权限应采用最小权限原则，严格控制。</li></ul></li></ul><h3 id="修改atm设计以满足安全性场景">修改ATM设计以满足安全性场景</h3><p><strong>增加用户认证机制：</strong></p><ul><li>PIN码验证失败3次后，锁定账户并通知银行后台。</li><li>支持生物识别（如指纹或人脸识别）作为双重验证。</li></ul><p><strong>加强数据加密传输：</strong></p><ul><li>使用TLS加密协议对数据传输进行加密。</li><li>PIN码和账户信息在设备端进行加密，再传输至服务器。</li></ul><p><strong>后端访问控制：</strong></p><ul><li>对管理员和银行操作员的访问权限进行严格控制，所有操作需记录并可追溯。</li><li>定期审计后台操作记录，识别并防范内部攻击。</li></ul><h1 id="补充">补充</h1><h2 id="cap定理">CAP定理</h2><p><strong>概述：</strong>它指出在一个分布式系统中，Consistency-Availability-PartitionTolerance(分区容错性)三者不能同时完全满足。在实际应用中，为了保证高可用性和分区容错性，通常牺牲强一致性，提供最终一致性</p><h2 id="冗余设计">冗余设计</h2><p><strong>概述：</strong>是一种通过引入额外资源或组件来提升系统可用性和容错能力的策略。其核心思想是通过增加冗余的计算、存储或网络资源，使系统在遇到故障时能够继续运行，从而减少服务中断的概率</p><p><strong>主要形式：</strong></p><ul><li>硬件冗余：增加物理设备</li><li>软件冗余：在软件层面设计备用逻辑或服务</li><li>时间冗余：在系统中重复执行相同操作，以检测和修复偶发性错误</li><li>信息冗余：通过增加校验信息来检测和纠正数据错误</li><li>网络冗余：配置备用网络路径或路由器</li></ul><p><strong>实现方式：</strong></p><ul><li>主备切换(Active-Passive)：一个主节点工作，备用节点处于待机状态</li><li>双活设计(Active-Active)：多个节点同时处于活跃状态，共同分担负载</li><li>多重备份(N+1或N+M冗余)</li><li>数据复制(Data Repication)：将数据复制到多个存储节点中</li><li>故障检测与切换：使用心跳检测和健康检查机制，即使发现故障并切换执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>大学课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习——持久化技术</title>
    <link href="/2024/12/13/Redis%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2024/12/13/Redis%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="redis学习持久化技术">Redis学习——持久化技术</h1><p>简要介绍Redis的两种持久化技术——AOF和RDB快照</p><h2 id="rdb快照">RDB快照</h2><p><strong>概述：</strong> RedisDataBase通过创建内存快照的方式，将redis数据以二进制格式保存到磁盘中，形成一个时间点的备份</p><p><strong>实现机制：</strong></p><ul><li>在指定的时间间隔内检查是否满足触发条件，如果满足，则执行快照操作</li><li>快照操作会将数据存储到一个RDB文件中（默认名为<code>dump.rdb</code>），存储的内存是某个时间点的数据状态</li><li>触发方式：<ul><li>定时保存：通过配置文件中的save参数，指定触发条件（如“在多少s内有多少次写操作”）</li><li>手动触发：使用<code>save</code>或者是<code>bgsave</code>命令<ul><li><code>save</code>会阻塞主线程进行保存</li><li><code>bgsave</code>在创建异步子进程执行保存操作，主线程可以继续处理客户端请求</li></ul></li></ul></li><li>相关文件：<ul><li>默认保存文件：<code>dump.rdb</code></li><li>可以通过配置文件<code>redis.conf</code>修改保存文件名及路径</li></ul></li><li>优点：<ul><li>文件体积小，适合用于全量备份</li><li>恢复速度快，适合灾难恢复</li></ul></li><li>缺点：<ul><li>不能保存实时数据（数据可能因系统故障丢失）</li><li>生成快照时可能占用较多资源（如CPU和内存）</li></ul></li></ul><p><strong>写时复制技术(Copy-On-Write, COW)：</strong></p><p>在执行bgsave的过程中，redis仍然可以继续执行命令，也就是数据能够被修改。如果redis没有执行修改数据的操作，那bgsave执行的子进程和父进程用的是同一个物理内存<img src="/2024/12/13/Redis%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/image-20241212001020185.png" class=""></p><p>如果redis执行了修改数据的操作，子进程就会从原来的使用的内存数据复制一份出来继续进行rdb快照，因此，rdb快照保存的是<strong>原来的数据</strong>。在执行bgsave的过程中，redis修改的数据并不在bgsave保存的范围内，只能等待下一次bgsave。<img src="/2024/12/13/Redis%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%8C%96%E6%8A%80%E6%9C%AF/image-20241212001306225.png" class=""></p><h2 id="aof持久化">AOF持久化</h2><p><strong>概述：</strong> Append OnlyFile是通过记录每次写操作的日志，将这些操作按顺序写入日志文件，确保数据可以完整恢复</p><p><strong>实现机制：</strong></p><ul><li>Redis将每次<strong>写操作记录</strong>到AOF文件中（默认名为<code>appendonly.aof</code>）<ul><li>注意：是命令执行成功后才写入文件中</li></ul></li><li>AOF文件采用追加的方式，确保写操作是顺序的</li><li>日志格式是Redis的协议格式，便于解析和重放</li><li>AOF文件会定期通过重写来压缩日志文件，避免日志文件过大<ul><li>原理是根据某个键值对的最新状态，用一条命令去记录这个键值对</li><li>重写的时候先写入临时文件，成功后再覆盖原文件（防止失败污染原文件）</li><li>在后台进行重写，同样使用了COW技术，并将在重写期间执行的命令追加到<strong>AOF缓冲区</strong>(写入旧aof文件的)和<strong>AOF重写缓冲区</strong>(等会追加到重写aof文件的)，等待后台重写完毕，会通知主线程，然后主线程将AOF重写缓冲区中的所有内容追加到新的AOF文件中，保证新旧AOF文件所保存的数据库状态一致，然后新AOF覆盖旧AOF</li></ul></li><li>配置参数决定写入磁盘的同步策略：<ul><li>always：每次写入操作立即同步（立即执行fsync函数），性能最低但数据最安全</li><li>everysec：每秒同步一次默认值，性能与安全性的折中（创建一个异步任务来执行fsync函数）</li><li>no：完全依赖操作系统决定何时同步，性能最高但数据可能丢失（永不执行fsync函数）</li></ul></li></ul><p><strong>相关文件：</strong></p><ul><li>默认保存文件：<code>ppendonly.aof</code></li><li>可通过配置文件<code>redis.conf</code>修改保存文件名及路径</li></ul><p><strong>优点：</strong></p><ul><li>数据恢复更安全，可以记录每个写操作，最大限度减少数据丢失</li><li>追加写操作性能较好</li></ul><p><strong>缺点：</strong></p><ul><li>文件体积较大</li><li>恢复速度比RDB满</li><li>初始状态可能会占用更多的存储资源</li></ul><h2 id="rdb和aof混合持久化">RDB和AOF混合持久化</h2><p>在配置文件中开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">aof-use-rdb-preamble yes<br></code></pre></td></tr></table></figure><p>混合持久化工作在<strong>AOF日志重写过程</strong></p><p>在AOF重写日志时，fork出来的重写子线程会先将主线程共享的内存数据以RDB方式写入AOF文件，然后主线程处理的操作命令会被记录在重写缓冲区，以AOF方式写入到AOF文件，完成后主线程将含有RDB格式和AOF格式文件替换旧的AOF文件。</p><h2 id="大key对aof日志的影响">大Key对AOF日志的影响</h2><h3 id="对aof日志的影响">对AOF日志的影响</h3><p>只有always策略可能会阻塞主线程，所以如果写入的是一个大Key，阻塞的时间会比较久</p><h3 id="对aof重写和rdb的影响">对AOF重写和RDB的影响</h3><p>如果大Key可能会很快触发AOF重写机制</p><p>然后执行AOF重写机制和RDB快照都需要fork主线程，这时候fork出来的也变可能会很大，因此会很耗时阻塞主线程</p><p>同时，如果发生了写时复制，需要复制物理内存，这个过程也会耗时阻塞主线程</p><p><strong>建议：</strong></p><ul><li>如果redis只是当作缓存，可以关闭AOF和AOF重写以及RDB，不关心数据安全性问题，可以提升性能</li><li>linux的hugepage机制也会影响redis性能，hugepage支持2MB/1GB等大小的内存，在发生COW后，redis也需要拷贝相应hugepage大小的内存</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>O(1)和CFS调度算法简介</title>
    <link href="/2024/12/12/O1%E5%92%8CCFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/12/12/O1%E5%92%8CCFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="o1和cfs调度算法简介">O(1)和CFS调度算法简介</h1><p>简要介绍linux中的O(1)调度算法和CFS调度算法的雏形（发展及设计思想）</p><h2 id="o1调度算法">O(1)调度算法</h2><p><strong>概述：</strong> 是linux kernel2.6引入的一种调度算法，无论系统中有多少进程，调度器总能在恒定时间内完成操作，即时间复杂度为O(1)</p><p><strong>什么是调度？</strong></p><p>假设这样一个场景，只有一个CPU，然后有两个进程需要执行，可以让它们交替执行。为了实现切换，我们提供一个API函数，这些进程执行一会就主动调用一下这个API函数，实现进程的切换执行，这是一种主动配合式的调度</p><p><strong>进程切换的本质：</strong></p><p>把当前进程的上下文（也就是CPU的一堆寄存器值）保存到该进程的PCB（进程控制块），然后把另一个进程的上下文放到CPU寄存器中开始执行。</p><p><strong>中断抢占式调度：</strong></p><p>有些进程在CPU执行过程中可能死锁，这样另一个进程就永远没有执行的机会了。可以利用<strong>时钟中断</strong>（一旦有中断事件到CPU，CPU就得去执行中断处理程序），在时钟中断的中断处理程序加入调度入口，就能抢到CPU的执行权。可以让每个进程都执行一个时间片（比如100ms），然后每隔一个时间片就会有一个中断事件到来，切换进程的执行。</p><p><strong>就绪队列：</strong></p><p>准备被CPU执行的进程，会被存储在一个队列中，这个队列就叫就绪队列</p><p><strong>等待队列：</strong></p><p>当有进程等待锁、IO等待或者sleep的时候，让CPU时间白白浪费了，调度程序需要介入，将其移动到等待队列，等它没有上述情况后再移动到就绪队列</p><p><strong>优先级：</strong></p><p>当进程数逐渐多起来，这时候进程执行一次后，等下次执行可能需要等长时间，这是不合理（比如键盘输入等1、2s才响应）。需要给每个进程设置优先级，从0-139（这里假设数字越高优先级越大，实际上并不是这样，后面有结介绍）。这样调度就需要先遍历就绪队列，这样复杂度就是O(N)了。</p><p>可以按照优先级拆分成不同的队列，0-139一共140个队列，调度可以先从高优先级队列查起，可以通过一个位图(10001000....)，1表示该队列有等待调度的进程，0则无。</p><p><strong>active队列和expired队列：</strong></p><p>为了防止低优先级进程starvation（也就是一直没有被调度），多添加一个队列expired队列。调度器从active队列中选择最高优先级的进程运行，运行完时间片的进程被移动到expired队列，当active进程中所有进程都被移动到expired队列，直接交换两个队列（active和expired定义为指针，交换队列直接交换指针即可</p><p><strong>时间片机制：</strong></p><p>到上面这一步，好像跟一开始没啥区别了（也就是进程执行完一次，下一次执行需要经过很长时间，如果进程数量多的话）。故引入时间片机制，优先级越高的进程时间片越长（根据权重划分），需要设定一个最小值，不然进程数多的话有的进程时间片太小，这样调度切换多了，实际CPU执行时间就少了。</p><p>这样就是O(1)调度算法的一个雏形了</p><p><strong>优点：</strong></p><ul><li>时间复杂度为O(1)</li><li>优先级机制</li></ul><p><strong>缺点：</strong></p><ul><li>不够公平</li></ul><h2 id="完全公平调度算法">完全公平调度算法</h2><p><strong>概述：</strong> CFS(Completely FairScheduler)是Linux内核2.6.23引入的调度算法，旨在更加公平的调度</p><p><strong>虚拟运行时间(vruntime)：</strong></p><p>为了让优先级较小的进程能“追赶”到公平的水平，引入vruntime的概念，也就是低优先级的vruntime增长的更快，高优先级的进程vruntime增长较慢，可以把vruntime作为衡量任务实际消耗CPU时间的账本，所以为了公平调度，每次选择vruntime最小的进程运行（让它吃个饱</p><p>举个例子，假设有三个任务A,B，权重分别为2,1，三个任务刚进入系统，vruntime都是0，调度器先选择优先级高的A执行，运行10ms后，A的vruntime增加5（因为优先级高的进程vruntime增长慢），然后调度选择vrumtime目前最小的B运行10ms后，B的vruntime增加10（低优先级进程vruntime增长快），第三次调度器仍选择vruntime最小的A执行。</p><p>把CPU比作很多个蛋糕，任务的优先级比作拿到蛋糕的能力（A拿蛋糕速度快吃得也快，B拿蛋糕速度慢）。调度器通过监控每个任务拿的蛋糕数量（vruntime），优先让蛋糕少的人去拿，确保大家都能吃到蛋糕，同时让能力强的人吃得多一些。</p><p><strong>红黑树：</strong></p><p>那要怎么去取vruntime最小的进程效率最高呢？答案是红黑树，因为它是一棵<strong>近似平衡的二叉搜索树</strong>，也就是这颗树最左节点是vruntime最小的进程，也就是需要调度的进程</p><p><strong>AVL vs. 红黑树：</strong></p><p>红黑树的近似平衡规则：</p><ul><li>每个节点是红色或黑色（颜色用于控制树的平衡调整）</li><li>根节点始终是黑色的（确保树的整体平衡从根节点开始）</li><li>每个叶子节点（nil节点）是黑色（nil节点是所有空子树的占位符）</li><li>红色节点的子节点必须是黑色的</li><li>从任一节点到其叶子节点的每条路径必须包含相同数量的黑色节点（黑高）</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">   (<span class="hljs-number">10</span>B)<br>  /    \<br>(<span class="hljs-number">5</span>R)   (<span class="hljs-number">15</span>R)<br></code></pre></td></tr></table></figure><p>插入2：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">       (<span class="hljs-number">10</span>B)<br>      /    \<br>   (<span class="hljs-number">5</span>R)    (<span class="hljs-number">15</span>R)<br>  /<br>(<span class="hljs-number">2</span>R)<br></code></pre></td></tr></table></figure><p>将5改为黑色，右旋（以5为轴：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">    (<span class="hljs-number">5</span>B)<br>   /    \<br>(<span class="hljs-number">2</span>R)   (<span class="hljs-number">10</span>B)<br>          \<br>          (<span class="hljs-number">15</span>R)<br></code></pre></td></tr></table></figure><p>而AVL树是严格平衡的，也就是节点的左右子树高度差不超过1，而CFS更看重<strong>实时响应性</strong>，AVL树需要更加频繁地调整，且红黑树的实现较简单，旋转次数更少，<strong>较低的调度延迟</strong>。</p><p><strong>优点：</strong></p><ul><li>公平性</li><li>高效，红黑树操作时间复杂度是O(logN)</li><li>CFS支持调度公平性程序（如通过<code>sched_latenct</code>和<code>sched_min_granularity</code>参数）</li></ul><p><strong>缺点：</strong></p><ul><li>较高复杂度相比O(1)调度算法</li><li>对实时任务支持较弱</li></ul><h2 id="其他">其他</h2><p><strong>二者的对比：</strong></p><p>O(1)调度算法更适合实时系统和对复杂性要求较高的场景，CFS调度是现代通用linux系统的默认调度器，它在公平性和灵活性上显著优于O(1)调度</p><p><strong>调度的是线程：</strong></p><p>在现代linux内核中，参与调度的实体是线程而不是进程，linux将线程视为轻量级线程(LWP)。</p><p>相比于进程：</p><ul><li>线程的上下文切换开销更小，因为线程共享进程资源，不需要切换整个地址空间等信息</li><li>符合现代应用程序的并发需求，现代程序常常通过多线程模型来实现高性能并发</li><li>更好地支持多核架构，不同线程可以同时运行在多个CPU核心上，而且线程粒度更细</li></ul><p><strong>实时优先级和普通优先级：</strong></p><ul><li>0-99：实时优先级，用于实时任务，更高数字表示更高优先级</li><li>100-139：普通优先级，更低数字表示更高的优先级</li></ul><p><strong>nice值：</strong></p><p>进程通过一个nice值（对其他进程的友好度，nice越大越友好，越谦让，优先级越低）映射到优先级，nice越大优先级越低</p><p><strong>进程优先级是分动态和静态的</strong></p><p><strong>在多核模式下，为了防止加锁带来的性能损失，每个CPU核都有自己的调度队列</strong></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>进程</tag>
      
      <tag>调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu22安装docker并配置镜像</title>
    <link href="/2024/12/11/ubuntu22%E5%AE%89%E8%A3%85docker%E5%B9%B6%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F/"/>
    <url>/2024/12/11/ubuntu22%E5%AE%89%E8%A3%85docker%E5%B9%B6%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu22安装docker并配置镜像">ubuntu22安装docker并配置镜像</h1><h2 id="安装docker">安装docker</h2><p>更新现有软件包索引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure><p>安装必要的依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install apt-transport-https ca-certificates curl software-properties-common<br></code></pre></td></tr></table></figure><p>添加docker官方的GPG密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></figure><p>添加docker的apt仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><p>更新软件包索引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br></code></pre></td></tr></table></figure><p>安装docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>查看是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker --version<br></code></pre></td></tr></table></figure><p>启动并自启动docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start docker<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><h2 id="配置镜像源">配置镜像源</h2><p>修改<code>/etc/docker/daemon.json</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br><span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://docker.registry.cyou&quot;</span>,<br><span class="hljs-string">&quot;https://docker-cf.registry.cyou&quot;</span>,<br><span class="hljs-string">&quot;https://dockercf.jsdelivr.fyi&quot;</span>,<br><span class="hljs-string">&quot;https://docker.jsdelivr.fyi&quot;</span>,<br><span class="hljs-string">&quot;https://dockertest.jsdelivr.fyi&quot;</span>,<br><span class="hljs-string">&quot;https://mirror.aliyuncs.com&quot;</span>,<br><span class="hljs-string">&quot;https://dockerproxy.com&quot;</span>,<br><span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span>,<br><span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>,<br><span class="hljs-string">&quot;https://docker.nju.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://mirror.iscas.ac.cn&quot;</span>,<br><span class="hljs-string">&quot;https://docker.rainbond.cc&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>截至2024.12.11仍有效</p></blockquote><p>验证是否能正常拉取image：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> docker run hello-world<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust迭代器——drain</title>
    <link href="/2024/12/09/rust%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94drain/"/>
    <url>/2024/12/09/rust%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94drain/</url>
    
    <content type="html"><![CDATA[<p><strong>概述：</strong>通常用于集合类型（如Vec、HashMap等）来移除并返回集合中的元素。就是会在遍历过程中将这些元素从集合中移除，使用drain可以避免在移除元素时进行多次分配内存和拷贝的操作，从而提高性能。</p><p><strong>示例：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">drained_elements</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = vec.<span class="hljs-title function_ invoke__">drain</span>(..).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, drained_elements); <span class="hljs-comment">// 输出: [1, 2, 3, 4, 5]</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, vec); <span class="hljs-comment">// 输出: []</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust迭代器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的智能指针</title>
    <link href="/2024/12/09/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2024/12/09/C-%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="c中的智能指针">C++中的智能指针</h1><h2 id="简介">简介</h2><p>对裸指针的封装，初衷是让程序员无需手动释放内存，来避免内存泄露。需要包含头文件<code>memory</code></p><h2 id="常见的智能指针">常见的智能指针</h2><p><strong>auto_ptr：</strong>在C++11中就已经标为废弃了，取而代之的是unique_ptr。</p><p><strong>unique_ptr: </strong> 作用域指针，低开销，不能被复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        std::unique_ptr&lt;Entity&gt;<span class="hljs-built_in">entity</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Entity</span>());<br>        <span class="hljs-comment">// 这里不能这样std::unique_ptr&lt;Entity&gt;entity = new Entity()，因为unique_ptr定义中明确了显式构造</span><br>        <br>        <span class="hljs-comment">// 我们通常使用下面的语法定义unique_ptr，主要原因是出于异常安全，当构造函数抛出异常时，它会稍微安全一些</span><br>        std::unique_ptr&lt;Entity&gt;entity = std::<span class="hljs-built_in">make_unique</span>&lt;Entity&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>shared_ptr：</strong>有一点开销，能够被复制，因为它使用了引用计数，可以跟踪你的指针有多少个引用，一旦shared_ptr的引用计数为0，那它就会被删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Entity&gt;e0;<br>    &#123;<br>        <span class="hljs-comment">// 对于shared_ptr来说，不能用new来构造，因为shared_ptr需要分配另一块内存，叫作控制块，用来存储引用计数。</span><br>        std::shared_ptr&lt;Entity&gt;shared_entity = std::make_shared&lt;Entity&lt;();<br>        <br>        e0 = shared_enetity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>shared_ptr的内部维护了一个计数器，来跟踪有多少个shared_ptr对象指向了一个资源。当计数器减少到0时，shared_ptr会调用delete来释放资源。</p><p>何时增加：</p><ul><li>新建一个shared_ptr并指向了一个资源时</li><li>复制构造函数创建一个新的shared_ptr时</li><li>用复制运算符将一个shared_ptr给另一个shared_ptr对象赋值时</li></ul><p>何时减少：</p><ul><li>当一个shared_ptr对象被销毁时，比如局部变量离开作用域，或者类成员变量析构时</li><li>当一个shared_ptr对象不再指向一个资源时，例如通过reset方法或者赋值运算符指向另一个资源时</li></ul><p><strong>weak_ptr：</strong>可以与shared_ptr配合使用，它同样能复制指针，但是它不会增加引用计数，是用来防止shared_ptr可能导致的循环引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::weak_ptr&lt;Entity&gt;e0;<br>    &#123;<br>        std::shared_ptr&lt;Entity&gt;shared_entity = std::<span class="hljs-built_in">make_shared</span>&lt;Entity&gt;();<br>        <br>        e0 = shared_entity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环引用是如何发生的">循环引用是如何发生的</h2><p>两个或多个对象相互引用，可能会存在循环引用的问题，导致资源无法被释放掉。这时候需要使用weak_ptr来打破循环引用，比如说A强引用了B，B引用了A，这时候A和B的引用计数都为1，但是你要释放A就先必须释放B，因为B持有A的引用，要释放B就先必须释放A，造成循环引用。通过weak_ptr，A持有B的弱引用，B持有A的弱引用，这时候随便释放A和B，因为他们引用计数都是0</p><h2 id="shared_ptr是线程安全的吗">shared_ptr是线程安全的吗？</h2><p><strong>多线程代码操作同一个share_ptr对象是线程不安全的</strong></p><p>比如下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">(shared_ptr&lt;A&gt;&amp; sp)</span></span>&#123; <br>    sp = global_sp; <br>&#125;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    std::shared_ptr&lt;A&gt; sp1 = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;(); <br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(fn,sp1)</span></span>; <br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(fn,sp1)</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>fn函数传入的参数是引用，所以t1和t2使用的是同一个shared_ptr对象，shared_ptr在进行计数的增加和减少是原子操作，但是这里使用的同一个对象，原子操作已经没有意义了。</p><p>所以t1和t2线程的执行顺序有可能是交叉进行的。也就是线程1找到sp1指向的内存A后，内存A的引用计数从1减少到0，然后此时应该将sp1指向内存B的，但是线程2先执行了，所以sp1指向的内存A引用计数就从0减到-1了，产生了线程安全的问题。</p><p><strong>多线程代码操作不同的shared_ptr对象是线程安全的</strong></p><p>比如下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn</span><span class="hljs-params">(shared_ptr&lt;A&gt; sp)</span> </span>&#123;<br>    sp = global_sp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;A&gt; sp1 =std::<span class="hljs-built_in">make_shread</span>&lt;A&gt;();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(fn, sp1)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(fn, sp1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为shared_ptr引用计数的减少和增加是原子操作，所以一个shared_ptr对象在进行引用计数的增加或减少时，另一个shared_ptr对象是无法进行这个操作的，保证了线程的安全。</p><p>（虽然shared_ptr对象是两个，但是它们指向的内存是同一份）</p><h2 id="何时用shared_ptrweak_ptr">何时用shared_ptr/weak_ptr</h2><p><strong>何时用shared_ptr：</strong></p><p>当引用的资源需要在多线程之间共享的时候，通常会使用shared_ptr。</p><p><strong>何时用weak_ptr：</strong></p><ul><li>在使用shared_ptr时，需要解决循环引用的问题，需要用weak_ptr</li><li>当需要使用一个共享内存，但是从业务逻辑上讲，这个持有不应该对资源的生命周期有影响，这时我们应该使用weak_ptr<ul><li>缓存实现，假设有个缓存系统，某些对象是昂贵的资源，并且希望在缓存中缓存它们，但又不希望缓存的对象阻止它们的销毁，可以使用weak_ptr</li><li>避免不必要的内存占用，某些情况，你可能只需要观察一个对象的状态而不希望它的存在延长对象的生命周期，weak_ptr允许你持有一个对对象的观察性引用。</li></ul></li></ul><p><strong>针对上面第二点进行详细解释：</strong></p><ul><li>从性能上看，weak_ptr的性能开销通常比share_ptr低，因为它不会增加引用计数，只是提供了被管理对象的弱引用</li><li>从逻辑上看，如果我们业务逻辑本身就是对这个资源是一个观察者的角度来看的，那么我们确实也应该使用weak_ptr保证不影响资源的引用计数。</li></ul><h2 id="其他">其他</h2><h3id="引用计数的线程安全性是怎么实现的">引用计数的线程安全性是怎么实现的？</h3><p>对于引用计数，通常使用<code>std::atomic&lt;int&gt;</code>或<code>std::atomic&lt;std::size_t&gt;</code>来存储计数器，常见的操作包括原子增加(<code>fetch_add</code>)和原子减少(<code>fetch_sub</code>)，这些操作是原子的，可以保证线程安全。</p><h3id="有个场景需要用到shared_ptr般会怎么做">有⼀个场景需要用到shared_ptr，⼀般会怎么做？</h3><p><strong>使用std::shared_ptr本身：</strong></p><p>如果有多个线程共享同一个资源，可以直接使用shared_ptr确保引用计数的线程安全性。std::shared_ptr可以自动管理对象的生命周期，保证当所有线程不再使用对象时自动释放</p><p><strong>使用std::mutex包裹shared_ptr：</strong></p><p>如果你的场景不只是涉及引用计数的线程安全，还需要对<code>shared_ptr</code>的修改进行复杂操作（如重置、交换等），可以使用互斥锁来保护对shared_ptr的访问。这种方法会使访问资源的操作变得串行化，但是有时是必要的，尤其是当需要执行复杂的更新操作时。</p><p><strong>使用std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;：</strong></p><p>C++17引入了<code>std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;</code>，使得在多线程环境中对<code>shared_ptr</code>对象的交换、加载和存储等操作可以是原子性的。比如修改shared_ptr本身。</p><p><strong>使用std::weak_ptr和std::shared_ptr的配合：</strong></p><p>多个线程需要共享一个资源，但只有一个线程负责引用计数，其他线程只需要读取或监控该对象。</p><h3id="语言层面保证线程安全性都有哪些手段">语言层面，保证线程安全性都有哪些手段？</h3><p><strong>原子操作：</strong></p><p>大多数语言都提供了对原子操作的支持，确保共享数据的修改是原子的。</p><ul><li>C++：使用std::atomic提供原子操作，支持原子增加、原子减少、原子交换等操作</li><li>Rust：使用std::sync::atomic模块，提供原子操作如AtomicBool，AtomicIsize，AtomicUsize等</li></ul><p>优点是执行简单，开销小，但只适用于较简单的操作</p><p><strong>锁：</strong></p><p>是一种常见的同步机制，确保同一时刻只有一个线程可以访问某个共享资源。常见的锁有互斥锁、读写锁（适合读多于写的操作）、自旋锁等</p><ul><li>C++：使用std::mutex和和std::lock_guard(RAII风格)进行互斥操作</li><li>Rust：使用std::sync::Mutex，std::sync::RwLock提供互斥锁和读写锁的操作</li></ul><p>优点是可以保护复杂的数据结构，确保一致性；缺点是容易引发死锁和性能瓶颈，尤其是在高并发环境下，锁的争用可能会影响程序的性能</p><p><strong>条件变量：</strong></p><p>允许线程在某个条件成立时通知另一个线程进行操作，通常和锁结合使用。条件变量可以实现更细粒度的线程同步，常用于生产者-消费者问题等场景</p><ul><li>C++：std::condition_variable可以和std::mutex配合使用</li><li>Rust：std::sync::Condvar可以和std::sync::Mutex使用</li></ul><p>优点是可以灵活地处理线程间的通信和同步，缺点是使用不当时容易导致死锁或不必要的线程唤醒</p><p><strong>线程局部存储：</strong></p><p>允许每个线程拥有自己的数据副本，而不是共享同一资源，这对于避免线程间的冲突特别有用，尤其是当线程使用独立的状态时</p><ul><li>C++：使用thread_local关键字声明线程局部存储变量</li><li>Rust：使用std::thread::LocalKey进行线程局部存储</li></ul><p>优点是避免了线程间的同步需求，性能开销非常小。缺点是它仅适用于每个线程独立的数据，不能用于需要线程间共享的资源。</p><p><strong>无锁编程：</strong></p><p>通过算法和数据结构的涉及，避免了使用锁的情况，从而减少锁竞争和上下文切换的开销。通常依赖于原子操作，利用硬件原子指令来保证操作的原子性。</p><p>适用于性能要求极高的场景，但通常非常复杂，需要对原子操作和并发编程有深刻理解。</p><p><strong>事务内存：</strong></p><p>是一种通过将一组内存操作打包成一个原子事务来实现线程安全的技术。关键思想是如果多个线程同时对同一内存区域进行操作，系统可以回滚未完成的操作，类似于数据库事务的概念。</p><p>简化了并发编程的模型，缺点是它目前的支持较为有限，而且实际使用中可能会受到硬件和平台的限制。</p><h3 id="语言层面如何避免死锁">语言层面，如何避免死锁</h3><h4 id="避免死锁的原则和策略">避免死锁的原则和策略</h4><p><strong>避免循环依赖：</strong></p><ul><li>死锁通常发生在两个或多个线程相互持有对方需要的资源，形成一个循环等待。</li><li>策略：确保线程在获取锁时按照一定的顺序获取资源，避免出现循环等待。</li></ul><p><strong>使用超时机制：</strong></p><ul><li>如果线程请求锁时设置了超时，就可以避免线程在获取不到锁时进入死锁状态</li><li>策略：设置锁的等待潮湿，并在超时后进行处理（重试或退出），以避免程序在死锁时一直处于阻塞状态</li></ul><p><strong>避免持有锁的时间过长：</strong></p><ul><li>可以通过减小锁的持有时间，确保线程尽早释放锁，减少死锁的风险。</li><li>策略：尽量将需要加锁的代码块缩小，只在必要的地方加锁，避免长时间持有锁</li></ul><p><strong>避免锁嵌套：</strong></p><ul><li>避免线程在持有一个锁时再去请求其他锁，这样可以-能会导致死锁</li><li>策略：在设计时尽量避免复杂的锁嵌套</li></ul><h4 id="使用相关api避免死锁">使用相关API避免死锁</h4><p><strong>C++：</strong></p><ul><li><p>std::lock()：它能够同时锁定多个互斥量，并且避免死锁。它会确保多个锁能够按顺序获取，不会发生死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::mutex mtx1, mtx2;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    std::<span class="hljs-built_in">lock</span>(mtx1, mtx2); <span class="hljs-comment">// 保证两个互斥量以相同的顺序被锁定，避免死锁</span><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock1</span><span class="hljs-params">(mtx1, std::adopt_lock)</span></span>;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock2</span><span class="hljs-params">(mtx2, std::adopt_lock)</span></span>;<br>    <span class="hljs-comment">// 执行任务</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>std::try_lock()：尝试非阻塞地获取锁，如果无法获取锁，会立刻返回，这样可以避免因等待锁导致死锁。</p></li></ul><p><strong>Rust：</strong></p><ul><li>std::sync::Mutex和std::sync::RwLock通过lock方法保证某个时间只有一个线程能够访问数据。Rust的编译器和内存模型通过严格的所有权和借用规则，在一定程度上减少了死锁的风险。</li><li>try_lock()，它会尝试获取锁，而不会阻塞。如果锁无法获取，返回None。</li></ul><h3 id="shared_mutex">shared_mutex</h3><p><strong>概述：</strong>C++17后引入的，主要用于读写锁的场景，与传统的mutex不同，允许多个线程并发地读取共享资源，同时确保写操作时只有一个线程能够访问该资源。</p><p><strong>主要操作：</strong></p><ul><li>lock()：请求并获取独占写锁，阻塞其他线程的读锁和写锁</li><li>lock_shared()：请求并获取共享读锁，多个线程可以同时获得共享读锁</li><li>unlock()：释放当前的独占写锁</li><li>unlock_shared()：释放当前的共享读锁</li></ul><p><strong>与mutex的不同：</strong></p><ul><li>mutex：在一个时刻只能有一个线程持有锁，在读多写少的场景效率低</li><li>shared_mutex：允许多个线程并发地读取共享资源，只有写操作会阻塞其他线程</li></ul><p><strong>注意事项：</strong></p><ul><li>避免过度使用共享锁：虽然多个线程可以同时持有共享锁，但如果有太多线程竞争共享锁，可能会导致性能下降。如果读写平衡，还是使用mutex好</li><li>避免死锁</li></ul><h3 id="unique_ptr详解">unique_ptr详解</h3><p><strong>有哪两种类型：</strong></p><ul><li>管理单个对象(std::unique_ptr&lt;T&gt;)：*std::unique_ptr&lt;T&gt;会封装一个裸指针，并且在其析构时自动调用delete来释放该资源</li><li>管理数组(std::unique_ptr&lt;T[]&gt;)：跟std::unique_ptr&lt;T&gt;有点类似，但是它使用delete[]而不是delete，它不能被复制，只能移动，以保证数组的所有权只能被一个unique_ptr拥有</li></ul><p><strong>unique_ptr可以直接用于布尔语境，为什么？</strong></p><p>std::unique_ptr内部会重载operatorbool，让unique_ptr在布尔上下文中能够自动转换为true或false。如果unique_ptr指向一个有效的对象，则转换结果为true，如果是空指针，则转换结果为false</p><p><strong>vector的元素可以是unique_ptr吗？</strong></p><p>可以，它能够在vector的生命周期结束时正确地管理内存。</p><p><strong>unique_ptr可以实现虚派发吗？</strong></p><p>unique_ptr可以用来管理包含虚函数的对象，并且支持虚函数的派发，因为unique_ptr是一个模板类型，实际上可以管理任何类型的对象。</p><p>虚派发工作原理：虚函数的调度时通过对象的虚表实现的。只要对象是通过unique_ptr管理的，智能指针的析构和访问都能正确地进行虚函数调度</p><h3 id="shared_ptr详解">shared_ptr详解</h3><p><strong>内存布局：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> &#123;<br><span class="hljs-keyword">private</span>: <br>    T* ptr; <span class="hljs-comment">// 托管对象的指针</span><br>    control_block* ctrl_block: <span class="hljs-comment">// 控制块指针</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 控制块示例</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">control_block</span> &#123;<br>        std::atomic&lt;<span class="hljs-type">int</span>&gt; strong_count;<span class="hljs-comment">// 强引用计数</span><br>        std::atomic&lt;<span class="hljs-type">int</span>&gt; weak_count; <span class="hljs-comment">// 弱引用计数</span><br>        deleter_type deleter; <span class="hljs-comment">// 自定义删除器</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>std::make_shared和std::shared_ptr构造函数的区别：</strong></p><ul><li>基本区别：<ul><li>make_shared是一种通过内存池分配器一次性分配内存来创建shared_ptr和对象的方式。它在一个单独的内存块中分配了T对象以及一个控制块</li><li>构造函数通过先创建对象并返回裸指针，再将其传递给构造函数来创建，对象和控制块通常是分开分配的</li></ul></li><li>性能差异：<ul><li>make_shared会在一次内存分配中同时分配对象和控制块</li><li>构造函数需要先为对象分配内存，然后再为控制块分配内存</li></ul></li><li>内存布局：<ul><li>make_shared会将对象和控制块分配同一块内存中，避免内存碎片，提高缓存一致性</li><li>构造函数将对象和控制块分配在两块不同的内存区域，可能会导致更多的内存碎片</li></ul></li><li>异常安全：<ul><li>make_shared提供更好的异常按去啊逆行，因为内存分配只发生一次，如果抛出异常，内存泄露的风险更小。如果在创建过程中发生异常，内存可以在退出作用域时被统一释放</li><li>构造函数则存在一定的内存泄露风险，如果创建shared_ptr对象时抛出异常，可能会导致控制块被泄露</li></ul></li></ul><p><strong>如果构造函数传入同一个裸指针构造两个shared_ptr对象，会发生什么现象？</strong></p><p>会发生双重删除问题，shared_ptr会自动管理它所拥有对象的生命周期。当两个shared_ptr对象被创建并指向同一个裸指针时，它们会各自持有对同一个对象的所有权，且会尝试在它们被销毁时释放该对象。</p><p>如果直接使用裸指针来初始化多个shared_ptr对象，它们会认为自己是该对象的所有者，当两个对象被销毁时，会对同一块内存释放两次，导致程序崩溃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor\n&quot;</span>; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// 创建一个裸指针</span><br>    <br>    <span class="hljs-comment">// 创建两个 shared_ptr，指向同一个裸指针</span><br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(ptr)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(ptr)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>为什么shared_ptr都叫智能指针了，还是有上面的问题？</strong></p><ul><li>智能指针设计的假设：shared_ptr的设计假设了每个对象只有一个清晰的所有者，shared_ptr并不能知道这个裸指针是否被其他shared_ptr管理了。</li><li>裸指针不具备引用计数：裸指针只是内存地址，不会记录引用计数，shared_ptr无法知道裸指针是如何创建的</li></ul><h3 id="stdenable_shared_from_this">std::enable_shared_from_this</h3><p><strong>概述：</strong>主要目的是让一个对象能够在其成员函数内部安全地生成一个指向自身的shared_ptr，即在对象的内部拥有对其自身的智能指针</p><p><strong>如何使用：</strong></p><ol type="1"><li>继承std::enable_shread_from_this：要让类继承这个东西</li><li>调用shared_from_this：通过调用shared_from_this，可以获得一个指向当前对象的shared_ptr</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor\n&quot;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass print() called\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 shared_from_this 获取指向当前对象的 shared_ptr</span><br>        std::shared_ptr&lt;MyClass&gt; self = <span class="hljs-built_in">shared_from_this</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside doSomething, shared_ptr count: &quot;</span> &lt;&lt; self.<span class="hljs-built_in">use_count</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-comment">// do something with self</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 MyClass 对象并用 shared_ptr 管理</span><br>    std::shared_ptr&lt;MyClass&gt; ptr = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <br>    <span class="hljs-comment">// 在成员函数中使用 shared_from_this 来获取 shared_ptr</span><br>    ptr-&gt;<span class="hljs-built_in">doSomething</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>工作原理：</strong></p><ul><li>当一个对象被shared_ptr管理时，该对象的内存区域不仅包含对象的数据，还包括一个控制块</li><li>std::enable_shared_from_this通过继承和类型的绑定确保对象的控制块可访问</li><li>shared_from_this()通过调用shared_ptr的shared_ptr&lt;T&gt;::shared_from_this()来获取当前对象的控制块，并使用该控制块构造一个新的shared_ptr</li></ul><p><strong>限制：</strong></p><p>不能在构造函数和析构函数中调用shared_from_this()，因为在构造函数中，shared_ptr尚未完全建立，因此对象的控制块尚未分配。而在析构函数中，对象已经销毁</p><h2 id="手撕unique_ptr">手撕unique_ptr</h2><p>unique_ptr特点：唯一所有权</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUniquePtr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 原始指针</span><br>    T* ptr;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，接受原始指针</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyUniquePtr</span><span class="hljs-params">(T* p = <span class="hljs-literal">nullptr</span>)</span> : ptr(p) &#123;</span>&#125;<br><br>    <span class="hljs-comment">// 禁用拷贝构造函数（确保唯一所有权）</span><br>    <span class="hljs-comment">// = delete 可以显式地禁用一些函数或操作符</span><br>    <span class="hljs-built_in">MyUniquePtr</span>(<span class="hljs-type">const</span> MyUniquePtr&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// 禁用拷贝赋值操作符（确保唯一所有权）</span><br>    MyUniquePtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyUniquePtr&amp;) = <span class="hljs-keyword">delete</span>;<br> <br>    <span class="hljs-comment">// 移动构造函数，将所有权从另一个 MyUniquePtr 转移给当前对象</span><br>    <span class="hljs-built_in">MyUniquePtr</span>(MyUniquePtr&amp;&amp; other) : <span class="hljs-built_in">ptr</span>(other.ptr) &#123;<br>        other.ptr = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 将原始指针置为空，确保另一个对象不再拥有所有权</span><br>    &#125;<br>    <span class="hljs-comment">// 移动赋值操作符</span><br>    MyUniquePtr&amp; <span class="hljs-keyword">operator</span>=(MyUniquePtr&amp;&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-comment">// 释放当前资源</span><br>            <span class="hljs-keyword">delete</span> ptr;<br><br>            <span class="hljs-comment">// 转移所有权</span><br>            ptr = other.ptr;<br>            other.ptr = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyUniquePtr</span>() &#123;<br>        <span class="hljs-keyword">delete</span> ptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 解引用操作符，用于访问对象</span><br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> *ptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 指针访问操作符</span><br>    T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取原始指针</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-comment">// 重置指针为新对象</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T* p = <span class="hljs-literal">nullptr</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> ptr;<br>        ptr = p;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放当前指针的管理权，返回原始指针</span><br>    <span class="hljs-function">T* <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        T* temp = ptr;<br>        ptr = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Example constructor\n&quot;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Example destructor\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, I am Example!\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个MyUniquePtr对象，管理一个Example对象</span><br>    <span class="hljs-function">MyUniquePtr&lt;Example&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Example())</span></span>;<br>    ptr-&gt;<span class="hljs-built_in">hello</span>();<br><br>    <span class="hljs-comment">// 使用移动语义</span><br>    MyUniquePtr&lt;Example&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr);<br>    ptr2-&gt;<span class="hljs-built_in">hello</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手撕shared_ptr">手撕shared_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::atomic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is the constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Example</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is the destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySharedPtr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* ptr;<br>    atomic&lt;<span class="hljs-type">int</span>&gt;* refCount;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This is release func&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">if</span> (refCount &amp;&amp; refCount-&gt;<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">delete</span> ptr;<br>            <span class="hljs-keyword">delete</span> refCount;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">MySharedPtr</span>(T* p = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">ptr</span>(p), <span class="hljs-built_in">refCount</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">atomic</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>)) &#123;&#125;<br><br>    <span class="hljs-comment">// 复制构造函数</span><br>    <span class="hljs-built_in">MySharedPtr</span>(<span class="hljs-type">const</span> MySharedPtr&amp; other) : <span class="hljs-built_in">ptr</span>(other.ptr), <span class="hljs-built_in">refCount</span>(other.refCount) &#123;<br>        refCount-&gt;<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MySharedPtr</span>(MySharedPtr&amp;&amp; other) : <span class="hljs-built_in">ptr</span>(other.ptr), <span class="hljs-built_in">refCount</span>(other.refCount) &#123;<br>        other.ptr = <span class="hljs-literal">nullptr</span>;<br>        other.refCount = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 复制赋值操作符</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MySharedPtr&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">release</span>();<br><br>            ptr = other.ptr;<br>            refCount = other.refCount;<br>            refCount-&gt;<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值操作符</span><br>    MySharedPtr&amp; <span class="hljs-keyword">operator</span>=(MySharedPtr&amp;&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-built_in">release</span>();<br><br>            ptr = other.ptr;<br>            refCount = other.refCount;<br><br>            other.ptr = <span class="hljs-literal">nullptr</span>;<br>            other.refCount = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MySharedPtr</span>() &#123;<br>        <span class="hljs-built_in">release</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MySharedPtr&lt;Example&gt;<span class="hljs-built_in">mySharedPtr0</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Example</span>());<br>    &#123;<br>        MySharedPtr&lt;Example&gt;mySharedPtr1;<br>        mySharedPtr1 = mySharedPtr0;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手撕weak_ptr">手撕weak_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWeakPtr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* ptr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyWeakPtr</span>(T* p = <span class="hljs-literal">nullptr</span>) : <span class="hljs-built_in">ptr</span>(p) &#123;&#125;<br><br>    <span class="hljs-built_in">MyWeakPtr</span>(<span class="hljs-type">const</span> MyUniquePtr&amp; other) : <span class="hljs-built_in">ptr</span>(other.ptr) &#123;&#125;<br><br>    <span class="hljs-built_in">MyWeakPtr</span>(MyWeakPtr&amp;&amp; other) : <span class="hljs-built_in">ptr</span>(other.ptr) &#123;<br>        other.ptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Cgroup学习笔记</title>
    <link href="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="cgroupcontrol-group">Cgroup(Control Group)</h1><h2 id="引言">引言</h2><p><ahref="https://github.com/1037827920/tst-cgroup.git">tst-cgroup</a>是用来测试cgroupv1/v2大部分接口文件的测试套（用shell编写），共有118个测试用例，涵盖了CPU/内存/IO/网络/进程功能的接口文件测试，可以用来了解cgroupv1/v2大部分接口文件的基础用法。</p><p><strong>参考：</strong></p><ul><li><ahref="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/index.html">ControlGroups version 1 — The Linux Kernel documentation</a></li><li><ahref="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#">ControlGroup v2 — The Linux Kernel documentation</a></li><li><ahref="https://github.com/torvalds/linux/tree/master/tools/testing/selftests/cgroup">linux/tools/testing/selftests/cgroupat master · torvalds/linux</a></li><li><ahref="https://arthurchiao.art/blog/cgroupv2-zh/#hugetlb-interface-files">[译]Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）</a></li><li><ahref="https://docs.redhat.com/zh-cn/documentation/red_hat_enterprise_linux/6/html/resource_management_guide/ch-subsystems_and_tunable_parameters#ch-Subsystems_and_Tunable_Parameters">第3 章 子系统和可调参数 | Red Hat Product Documentation</a></li><li><ahref="https://ggaaooppeenngg.github.io/zh-CN/2017/05/19/cgroup-子系统之-net-cls-和-net-prio/">cgroup子系统之 net_cls 和 net_prio | ggaaooppeenngg</a></li></ul><h2 id="简介">简介</h2><p><strong>概述：</strong>Cgroups允许限制、优先处理、隔离和监控系统资源（如CPU、内存、磁盘I/O、网络带宽等）在进程或进程组之间的使用。这对于多租户环境、资源隔离和容器技术尤为重要，是linux内核自带的工具。</p><p><strong>cgroup v1/v2：</strong> cgroup有两个版本</p><ul><li><p>cgroup v1使用的是层级式结构，将子系统接口文件分开放在单独的目录，进程可能会在不同的子系统中参与不同的资源管理。<img src="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241205105844360-1733388768258.png" class=""></p></li><li><p>cgroup v2设计上更加简化和统一，所有的核心和控制器接口文件共享同一个目录<img src="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241205105542034.png" class=""></p></li></ul><p><strong>实例对比：</strong></p><ul><li><p>Cgroup V1示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建CPU和内存控制组</span><br><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/cpu/my_cgroup<br><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/memory/my_cgroup<br><br><span class="hljs-comment"># 设置CPU和内存限制</span><br><span class="hljs-built_in">echo</span> 50000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us<br><span class="hljs-built_in">echo</span> 100M &gt; /sys/fs/cgroup/memory/my_cgroup/memory.limit_in_bytes<br><br><span class="hljs-comment"># 将进程添加到控制组</span><br><span class="hljs-built_in">echo</span> &lt;PID&gt; &gt; /sys/fs/cgroup/cpu/my_cgroup/tasks<br><span class="hljs-built_in">echo</span> &lt;PID&gt; &gt; /sys/fs/cgroup/memory/my_cgroup/tasks<br><br></code></pre></td></tr></table></figure></li><li><p>Cgroup V2示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载Cgroup v2</span><br>mount -t cgroup2 none /sys/fs/cgroup/unified<br><br><span class="hljs-comment"># 创建控制组</span><br><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/unified/my_cgroup<br><br><span class="hljs-comment"># 设置CPU和内存限制</span><br><span class="hljs-built_in">echo</span> 50000 &gt; /sys/fs/cgroup/unified/my_cgroup/cpu.max<br><span class="hljs-built_in">echo</span> 100M &gt; /sys/fs/cgroup/unified/my_cgroup/memory.max<br><br><span class="hljs-comment"># 将进程添加到控制组</span><br><span class="hljs-built_in">echo</span> &lt;PID&gt; &gt; /sys/fs/cgroup/unified/my_cgroup/cgroup.procs<br></code></pre></td></tr></table></figure></li></ul><p>CgroupV2在设计上更加简洁和统一，提供了更一致的资源控制和监控接口。</p><p><strong>如何切换cgroup版本：</strong></p><ul><li>切换到cgroupv1，在<code>/etc/default/grub</code>的<code>GRUB_CMDLINE_LINUX</code>添加<code>systemd.unified_cgroup_hierarchy=0</code></li><li>切换到cgroupv1，在<code>/etc/default/grub</code>的<code>GRUB_CMDLINE_LINUX</code>添加<code>systemd.unified_cgroup_hierarchy=1</code></li></ul><p>然后更新配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> update-grab <span class="hljs-comment"># ubuntu22</span><br><span class="hljs-built_in">sudo</span> grub2-mkconfig -o /boot/grub2/grub.cfg <span class="hljs-comment"># opencloudos 8.8/9.2/Stream 23</span><br></code></pre></td></tr></table></figure><p>最后重启系统即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot<br></code></pre></td></tr></table></figure><h2 id="cgroup-v1">Cgroup v1</h2><h3 id="通用接口文件">通用接口文件</h3><p><strong>tasks：</strong></p><p>包含一系列在cgroup中运行的进程（由它们的PID表示）。PID列表不一定是有序的，也不一定是特有的。将PID写入一个cgroup的tasks文件，可将此进程移动至cgroup</p><p>跟下面的cgroup.procs功能一样，cgroupv2取消了这个接口文件，只保留了cgroup.procs</p><p><strong>cgroup.procs：</strong></p><p>包含在cgroup中运行的进程组列表（由它们的TGID表示）。TGID列表不一定有序的，也不一定是特有的。将TGID写入cgroup的cgroup.procs文件，可将此线程组群移至该cgroup</p><p><strong>cgroup.event_control：</strong></p><p>与cgroup的通知API一起，允许cgroup的变更状态通知被发送</p><p><strong>notify_on_release：</strong></p><p>包含Boolean值，1或者0，分别可以启动和禁用释放代理的指令。如果notify_on_release启用，当cgroup不再包含任何任务时（即cgroup的tasks文件包含PID，而PID被移除，致使文件变空），kernel会执行release_agent文件的内容。通向此空cgroup的路径会作为release_agent的参数被提供。notify_on_realease参数的默认值在rootcgroup中是0。所有非rootcgroup从其父cgroup处继承notify_on_realese的值</p><p><strong>release_agent（仅在root cgroup中出现）：</strong></p><p>当notify onrealeas被触发，它包含要执行的指令。一旦cgroup的所有进程被清空，并且notify_on_realease标记被启用，kernel会运行release_agent文件中的指令，并且提供通向被清空cgroup的相关路径（与rootcgroup相关）作为参数。（例如可以用来自动移除空cgroup）</p><p>自动移除空cgroup的例子：可将空cgroup从cpu cgroup中自动移除</p><ol type="1"><li><p>创建一个shell脚本用来移除空cpu cgroups,将其放入/usr/local/bin，并使其可运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /usr/local/bin/remove-empty-cpu-cgroup.sh<br>output:<br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-comment"># $1变量包含到达已清空cgroup的相对路径</span><br><span class="hljs-built_in">rmdir</span> /cgroup/cpu/<span class="hljs-variable">$1</span><br><span class="hljs-built_in">chmod</span> +x /usr/local/bin/remove-empty-cpu-cgroup.sh<br></code></pre></td></tr></table></figure></li><li><p>在cpu cgroup，启动notify_on_release标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> 1 &gt; notify_on_release<br></code></pre></td></tr></table></figure></li><li><p>在cpu cgroup中，指定一个可用的释放代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/local/bin/remove-empty-cpu-cgroup.sh&quot;</span> &gt; /cgroup/cpu/release_agent<br></code></pre></td></tr></table></figure></li><li><p>测试配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">cpu]# <span class="hljs-built_in">pwd</span>; <span class="hljs-built_in">ls</span><br>/cgroup/cpu<br>cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat  libvirt  notify_on_release  release_agent  tasks<br>cpu]# <span class="hljs-built_in">cat</span> notify_on_release <br>1<br>cpu]# <span class="hljs-built_in">cat</span> release_agent <br>/usr/local/bin/remove-empty-cpu-cgroup.sh<br>cpu]# <span class="hljs-built_in">mkdir</span> blue; <span class="hljs-built_in">ls</span><br>blue  cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat  libvirt  notify_on_release  release_agent  tasks<br>cpu]# <span class="hljs-built_in">cat</span> blue/notify_on_release <br>1<br>cpu]# cgexec -g cpu:blue <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/dev/null bs=1024k &amp;<br>[1] 8623<br>cpu]# <span class="hljs-built_in">cat</span> blue/tasks <br>8623<br>cpu]# <span class="hljs-built_in">kill</span> -9 8623<br>cpu]# <span class="hljs-built_in">ls</span><br>cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat  libvirt  notify_on_release  release_agent  tasks【可以看到blue cgroup已经被自动移除】<br></code></pre></td></tr></table></figure></li></ol><h3 id="blkio子系统">blkio子系统</h3><p><strong>概述：</strong>限制cgroup对IO的使用，两种控制策略，weight和throttling。</p><p><strong>需要开启的<a href="#%20内核配置">内核配置</a>：</strong></p><p>CONFIG_BLK_CGROUP：启用blkio子系统</p><p>CONFIG_IOSCHED_BFQ：支持weight控制策略</p><p>CONFIG_BLK_DEV_THROTTLING：支持throttling控制策略</p><p>CONFIG_BFQ_CGROUP_DEBUG：如果启用了这个选项，在cgroup中会显示一些额外的统计文件和控制文件（blkio.bfg.weight，blkio.bfg.weight_device)</p><p><strong>weight控制策略接口文件：</strong></p><ul><li><p>blkio.bfq.weight：读写文件。指定每个cgroup组的权重。这是组在所有设备上的默认权重，除非被blkio.bfq.weight_device覆盖。目前允许的范围是1到1000</p></li><li><p>blkio.bfq.weight_device:读写文件。指定每个cgroup中每个设备的权重，覆盖blkio.bfq.weight</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> dev_maj:dev_minor weight &gt; blkio.bfq.weight_device<br><span class="hljs-comment"># 设置权重</span><br><span class="hljs-built_in">echo</span> 8:16 300 &gt; blkio.bfq.weight_device <br><span class="hljs-comment"># 移除权重</span><br><span class="hljs-built_in">echo</span> 8:16 0 &gt; blkio.bfq.weight_device<br></code></pre></td></tr></table></figure></li><li><p>blkio.bfq.io_service_bytes：只读文件。cgroup传输到磁盘/从磁盘传输的字节数</p></li><li><p>blkio.bfq.io_serviced: 只读文件。cgroup向磁盘发出的IO（bio）数量。</p></li></ul><p><strong>throttling控制策略接口文件：</strong></p><p><strong>控制文件：</strong></p><ul><li><p>blkio.throttle.read_bps_device：读写文件。设置从设备读取速率的上限。单位是<code>byets/s</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;major&gt;:&lt;minor&gt; &lt;rate_bytes_per_second&quot;</span> blkio.throttle.read_bps_device<br></code></pre></td></tr></table></figure></li><li><p>blkio.throttle.write_bps_device：读写文件。设置对设备的写速率上限。单位是<code>byets/s</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;major&gt;:&lt;minor&gt;  &lt;rate_bytes_per_second&gt;&quot;</span> &gt; blkio.throttle.write_bps_device<br></code></pre></td></tr></table></figure></li><li><p>blkio.throttle.read_iops_device：读写文件。设置从设备读取速率的上限。单位是<code>IO/s</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;major&gt;:&lt;minor&gt;  &lt;rate_io_per_second&gt;&quot;</span> &gt; blkio.throttle.read_iops_device<br></code></pre></td></tr></table></figure></li><li><p>blkio.throttle.write_iops_device：读写文件。设置对设备的写速率上限。单位是<code>IO/s</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;major&gt;:&lt;minor&gt;  &lt;rate_io_per_second&gt;&quot;</span> &gt; blkio.throttle.write_iops_device<br></code></pre></td></tr></table></figure><ul><li>注意：如果为设备制定了BW和IOPS规则，那么IO将同时受到这两个约束</li></ul></li><li><p>blkio.throttle.io_serviced：只读文件。记录自从cgroup创建以来，对于每种操作的已完成的I/O操作数。按操作类型进一步划分——读或写，同步或异步。</p><ul><li>第一个字段：设备的主号</li><li>第二个字段：设备的副号</li><li>第三个字段：操作类型</li><li>第四个字段：IOs数量</li></ul></li><li><p>bklio.throttle.io_service_bytes：只读文件。记录自从cgroup创建以来，对于每种操作的已完成的向磁盘传输/从磁盘传输的字节数。按操作类型进一步划分——读或写，同步或异步。</p><ul><li>第一个字段：设备的主号</li><li>第二个字段：设备的副号</li><li>第三个字段：操作类型</li><li>第四个字段：字节数</li></ul></li></ul><p><strong>其他接口文件：</strong></p><ul><li><p>blkio.reset_stats：读写文件。向该文件写入int将导致重置该cgroup中的所有统计信息</p></li><li><p>blkio.time：读写文件。每个设备分配给cgroup的磁盘时间（以ms为单位），前两个字段指定设备的主号和副号，第三个字段指定分配给cgroup的磁盘时间</p></li><li><p>blkio.sectors：读写文件。组从磁盘传输或传输到磁盘的扇区数。前两个字段指定设备的主扇区号和副扇区号，第三个字段指定与设备之间传输的扇区数</p></li><li><p>blkio.io_service_time：只读文件。由该cgroup组完成的IOs的请求分派和请求完成之间的总时间。以ns为单位，对闪存设备也有意义。对于队列深度为1的设备，该时间表示实际服务时间。当队列深度大于1时，这种情况就不再成立，因为请求可能被乱序处理，这可能会导致给定的IO服务时间包括多个IO的服务时间，但服务无序时，这可能会导致总io_service_time大于实际经过的时间。这段时间根据操作类型进一步划分——读或写、同步或异步。前两个字段表示操作类型，第四个字段表示io_service_time，单位为ns</p></li><li><p>blkio.io_wait_time：只读文件。此cgroup组的IOs在调度程序队列中等待服务的总时间。这可能大于总时间，因为它是所有IOs的累积io_wait_time，不是cgroup等待总时间的度量，而是单个IOs的等待时间的度量。对于队列深度大于1的设备，这个指标不包括IO被分配到设备后等待服务的时间，而是直到它真正得到服务（这里可能有一个时间延迟，因为设备重新排序请求），以ns为单位。这对闪存设备也有意义，这段时间根据操作类型进一步划分——读或写、同步或异步吗。前两个字段指定设备的主、副编号，第三个字段指定设备的主、副编号</p></li><li><p>blkio.io_merged：只读文件。IOs请求合并到属于该cgroup的总数。进一步划分操作类型——读或写，同步或异步</p></li><li><p>blkio.io_queued：只读文件。在任何给定时刻为该cgroup排队的请求总数。进一步划分操作类型——读或写，同步或异步</p></li><li><p>blkio.avg_queue_size：只读文件。只有当CONFIG_BFQ_CGROUP_DEBUGE=y时，才启用调试辅助功能。该cgroup存在的整数时间内该cgroup的平均队列大小。每当此cgroup的一个队列获得一个时间片时，就会获取队列大小样本</p></li><li><p>blkio.group_wait_time：只读文件。CONFIG_BFQ_CGROUP_DEBUGE=y时，才启用调试辅助功能。这是cgroup从忙起（即从0到1个排队请求）为它的一个队列获取时间片需要等待的时间。这与io_wait_time不同，io_wait_time是该cgroup中每个IO在调度程序队列中等待所花费的时间的累计总和。单位是ns，如果在cgroup处理等待状态时读取该值，则stat将只报告直到最后一次获取时间片为止累积的group_wait_time，而不包括当前增量</p></li><li><p>blkio.empty_time：只读文件。CONFIG_BFQ_CGROUP_DEBUGE=y时，才启用调试辅助功能。这是一个cgroup在没有被服务的情况下没有任何挂起的请求的时间，也就是说，它不包括cgroup的某个队列的空闲时间。单位是ns，如果在cgroup处于空状态时读取该值，则stat将只报告截至上次有待处理请求为止累积的empty_time，而不包括当前增量</p></li><li><p>blkio.idle_time：只读文件。CONFIG_BFQ_CGROUP_DEBUGE=y时，才启用调试辅助功能。这是IO调度器为给定的cgroup等待一个比其他队列/cgroup的现有请求更好的请求所花费的时间。单位时ns，如果在cgroup处于空闲状态读取此值，则stat将只报告截至最后一个空闲时间段累积的idle_time，而不包括当前增量</p></li><li><p>blkio.dequeue：只读文件。CONFIG_BFQ_CGROUP_DEBUGE=y时，才启用调试辅助功能。这提供了关于一个cgroup从设备的服务树中退出队列的次数的统计信息。前两个字段指定设备的主号和副号，第三个字段指定cgroup从特定设备退出队列的次数</p></li><li><p>blkio.*_recursive：只读文件，各种统计的递归版本，这些文件显示的信息与他们的非递归对应项相同，但包括来自所有子cgroups的统计信息</p></li></ul><h3 id="cpu子系统">cpu子系统</h3><p><strong>概述：</strong>主要是限制cgroup对CPU的使用，三种控制策略，权重比例设置、周期使用时间上限和RT调度策略。</p><p><strong>按权重比例设定CPU的分配：</strong></p><ul><li>cpu.shares：读写文件。CPU比重分配，通过一个整数的数值调节cgroup所占用的CPU时间。例如，有两个cgroup（C1和C2），其中C1的cpu.shares设定为100，另一个设定为200，那么C2所使用的cpu时间将是C1所用时间的2倍</li></ul><p><strong>设定CPU使用周期使用时间上限：</strong></p><ul><li>cpu.cfs_period_us：读写文件。规定CPU的时间周期（微秒），最大值是1s，最小值是1000微妙。例如，如果在一个单CPU的系统内，要保证一个cgroup内的任务在1s的CPU周期内占用0.2s的CPU时间，可以通过设置cpu.cfs_quota_us为200000和cpu.cfs_period_us为1000000</li><li>cpu.cfs_quota_us：读写文件。在单位时间内（即cpu.cfs_period_us设定值）可用的CPU最大时间（单位是微秒）。cpu.cfs_quota_us值可以大于cpu.cfs_period_us的值，例如在一个双CPU的系统内，想要一个cgroup内的进程充分地利用2个CPU，可以设定cpu.cfs_quota_us为200000及cpu.cfs_period_us为100000</li><li>cpu.stat：只读文件。统计信息包含：<ul><li>nr_periods：经历了几个cfs_period_us周期</li><li>nr_throttled：task被限制的次数</li><li>throtled_time：表示task被限制的总时长</li></ul></li></ul><p><strong>RT调度策略下的配置：</strong>实时调度策略与公平调度策略中的按周期分配时间的方法类似，也是在周期内分配一个固定的运行时间</p><ul><li>cpu.rt_period_us：以微妙为单位在某个时间段中cgroup对CPU资源访问重新分配的频率。如果某个cgroup中的任务应该每5s有4s可访问CPU资源，则请将rt_runtime_us设定4000000，并将rt_period_us设定为5000000</li><li>cpu.rt_runtime_us：以微妙为单位指定某个时间段中cgroup中的任务对CPU资源的最长连续访问时间，建立这个限制是为了防止一个cgroup中的任务独占CPU时间。注意：父cgroup中的rt_runtime_us一定要大于等于子cgroup中的rt_runtime_us，不让会报参数错误的错误信息。</li></ul><h3 id="cpuacct子系统">cpuacct子系统</h3><p><strong>概述：</strong>显示cgroup中任务所使用的CPU资源，其中包括子群组任务，报告有两大类：</p><ul><li>usage：统计cgroup中进程使用CPU的时间，单位为纳秒</li><li>stat：统计cgroup中进程使用CPU的时间，单位为USER_HZ</li></ul><p><strong>需要开启的内核配置:</strong></p><ul><li>CONFIG_CGROUP_CPUACCT</li></ul><p><strong>接口文件：</strong></p><ul><li>cpuacct.usage：只读文件。记录该cgroup中所有进程的CPU使用总时间，以纳秒为单位</li><li>cpuacct.usage_percpu：只读文件。记录该cgroup中所有进程在每个CPU上的使用时间，以纳秒为单位</li><li>cpuacct.usage_user：只读文件。报告一个cgroup中所有任务使用用户态CPU的总时间，以纳秒为单位</li><li>cpuacct.usage_percpu_user：只读文件。报告一个cgroup中所有任务在每个CPU上使用用户态CPU的时间，以纳秒为单位</li><li>cpuacct.usage_sys：只读文件。报告一个cgroup中所有任务在CPU上使用内核态CPU的时间，以纳秒为单位</li><li>cpuacct.usage_percpu_sys：只读文件。报告一个cgroup中所有任务在每个CPU上使用内核态CPU的时间</li><li>cpuacct.usage_all：只读文件。详细输出文件cpuacct.usage_percpu_user和cpuacct.usage_percpu_sys的内容</li><li>cpuacct.stat：只读文件。报告cgroup的所有任务使用的用户和内核CPU时间，单位为USER_HZ</li></ul><h3 id="cpuset子系统">cpuset子系统</h3><p><strong>概述：</strong> 为一组进程分配指定的CPU和<ahref="#%20NUMA架构">NUAM节点</a></p><p><strong>以下规则适用每个cgroup：</strong></p><ul><li>它的 CPU 和<ahref="#%20NUMA架构">NUAM节点</a>必须是其父级的子集。</li><li>除非其父级被标记为exclusive，否则它不能被标记为exclusive。</li><li>如果其 CPU 或内存是独占的，则它们可能不会与任何兄弟cgroup重叠</li><li>必须指定当前cgroup的cpuset.mems和cpuset.cpus，才能将进程移入当前cgroup</li></ul><p><strong>CPU相关的接口文件：</strong></p><ul><li>cpuset.cpus: 读写文件。允许cgroup中的进程使用的CPU列表。如0-2,16代表0，1，2，16这4个CPU</li><li>cpuset.effective_cpus:只读文件。显示了当前cgroup中实际可用于分配给进程的CPU核心列表，它考虑了上级cgroup的限制和当前cgroup的cpuset.cpus配置，从而提供了一个最终的、实际可用的CPU核心集合</li><li>cpuset.cpu_exclusive:读写文件。cgroup是否独占cpuset.cpus中分配的cpu。默认值为0，表示共享；1表示独占。如果设置为1，其他cgroup内的cpuset.cpus值不能包含有该cpuset.cpus内的值</li><li>cpuset.sched_load_balance:读写文件。cgroup的cpu压力是否会被平均到cpuset中的多个cpu上。默认值1，启用负载均衡；0表示禁用。注意：如果任意上级cgroup中启用负载均衡，则在cgroup中设定这个标签没有任何效果，因为已经在较高一级cgroup中处理了负载均衡。因此，要在cgroup中禁用负载平衡，还要在每个上级cgroup中禁用负载平衡。</li><li>cpuset.sched_relax_domain_level：包含-1到小正数间的整数，它代表内核应该尝试平衡负载的CPU宽度范围，如果禁用了cpuset.sched_load_balance，则该值毫无意义。</li></ul><p>cpuset.sched_relax_domain_level值：</p><table><thead><tr><th>值</th><th>效果</th></tr></thead><tbody><tr><td>-1</td><td>为负载平衡使用系统默认值</td></tr><tr><td>0</td><td>不执行直接负载平衡；负载平衡只是阶段性的</td></tr><tr><td>1</td><td>在同一核中的跨线程直接负载平衡</td></tr><tr><td>2</td><td>在同一软件包中的跨线程直接负载平衡</td></tr><tr><td>3</td><td>在同一节点或刀片中的跨线程直接负载平衡</td></tr><tr><td>4</td><td>在不使用NUMA架构中跨多个CPU的直接负载平衡</td></tr><tr><td>5</td><td>在使用NUMA架构中跨多个CPU的直接负载平衡</td></tr></tbody></table><p><strong>Memory相关的接口文件：</strong></p><ul><li><p>cpuset.mems:读写文件。允许cgroup中的进程使用的内存节点列表。如0-2,16代表0,1,2,16这4个可用节点。</p></li><li><p>cpuset.effective_mems:只读文件。显示当前cgroup中实际可用于分配给进程的内存节点列表，同样考虑了上级cgroup的限制和当前cgrouop的cpuset.mems配置</p></li><li><p>cpuset.mem_exclusive:读写文件。是否独占memory。默认值0表示共享，1表示独占。如果设置为1，其他cgroup内的cpuset.mems值不能包含有该cpuset.mems内的值</p></li><li><p>cpuset.memory_migrate:读写文件。用来指定当cpuset.mems中的值更改时是否应该将内存中的页迁移到新节点。默认情况下是0表示禁止内存迁移，且页就保留在原来分配的节点中，即使在cpuset.mems中现已不再指定这个节点。如果设置为1，则该系统会将页迁移到由cpuset.mems指定的新参数中的内存节点中。</p></li><li><p>cpuset.memory_spread_page:读写文件。如果被设置了，将该cpuset中进程上下文是申请的pagecache平均分布到cpuset中的各个节点中。默认值是0表示不启用。设置为1表示启用</p></li><li><p>cpuset.mem_hardwall：主要用于控制内存分配的行为，开启该选项后，内存只能从指定的节点中分配，而不能从其他节点获取。默认情况下为0，即不启用</p></li><li><p>cpuset.memory_pressure_enabled：包含指定系统是否应该计算这个cgroup中进程所生成的内存压力的标签（0或1）。计算出的值输出到cpuset.memory_pressure，且代表进程试图释放使用中内存的比例，报告为尝试每秒再生内存的整数值再乘1000【这个文件只在cpuset根目录中出现，cpuset下的cgroup组中是没有这个文件的】【这个内存压力是回收内存的速度，也就是在进程用完内存之后，回收进程内存的速度】</p></li><li><p>cpuset.memory_spread_page：如果被设置了，将该cpuset中进程上下文是申请的pagecache平均分布到cpuset中的各个节点中（I/O磁盘读写会用到pagecache）</p></li><li><p>cpuset.memory_spread_slab：如果被设置了，将该cpuset中进程上下文申请的slab对象平均分配到cpuset的各个节点中（缓存文件I/O，也就是目录和inode会用到slab）【经过测试，这个标识符好像被弃用了】</p></li><li><p>cpuset.memory_pressure：包含运行在这个cpuset中产生的平均内存压力的只读文件。启用cpuset.memory_perssure_enabled时，这个伪文件中的值会自动更新，否则伪文件包含的值为0</p></li></ul><h3 id="devices子系统">devices子系统</h3><p><strong>概述：</strong>来跟踪和执行对设备文件的打开和关闭限制。设备cgroup为每个cgroup关联一个设备接入白名单，白名单有四个字段：</p><ul><li>type：a(all), c(char), b(block)</li><li>主设备号</li><li>副设备号</li><li>访问权限(r ,w, m(mknod))</li></ul><p><strong>需要开启的内核配置：</strong></p><ul><li>CONFIG_CGROUP_DEVICE</li></ul><p><strong>层次结构：</strong>设备组通过确保子cgroup永远不会拥有比其父cgroup更多的访问权限来维护层次结构。每次将条目写入cgroup的devices.deny文件时，它的所有子cgroup都会从白名单中删除该条目，并且所有本地设置的白名单条目都会被重新评估。如果某个本地设置的白名单条目提供了比父cgroup更多的访问权限，它将从白名单中删除</p><p><strong>接口文件：</strong></p><ul><li>devices.allow：允许访问的设备。文件包含4个字段：type（设备类型），major（主设备号），minor（次设备号），access（访问方式）<ul><li>type：a——适用所有设备，包括字符设备和块设备；b——块设备；c——字符设备</li><li>major/minor：9:* *:* 8:1</li><li>access：r——读，w——写，m——创建不存在的设备</li></ul></li><li>devices.deny：禁止访问的设备，格式如devices.allow</li><li>devices.list：显示目前允许被访问的设备列表</li></ul><p><strong>示例1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"> A<br>/ \<br>   B<br></code></pre></td></tr></table></figure><table><thead><tr><th>group</th><th>whitelist</th><th>denied devices</th></tr></thead><tbody><tr><td>A</td><td>all the rest</td><td>"b 8:* rwm", "c 116:1 rw"</td></tr><tr><td>B</td><td>"c 1:3 rwm", "c 116:2 rwm", "b 3:* rwm"</td><td>all the rest</td></tr></tbody></table><p>将c 116:* r写入A组的禁用设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;c 116:* r&quot;</span> &gt; A/devices.deny<br></code></pre></td></tr></table></figure><p>它将向下传播，在重新验证B的条目后，白名单条目"c 116:2rwm"将被删除</p><table><thead><tr><th>group</th><th>whitelist</th><th>denied devices</th></tr></thead><tbody><tr><td>A</td><td>all the rest</td><td>"b 8:* rwm", "c 116:* rw"</td></tr><tr><td>B</td><td>"c 1:3 rwm", "b 3:* rwm"</td><td>all the rest</td></tr></tbody></table><p>如果父cgroup不允许访问某设备，那子cgroup也没有权限访问</p><p><strong>示例2：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"> A<br>/ \<br>   B<br></code></pre></td></tr></table></figure><table><thead><tr><th>group</th><th>whitelist</th><th>denied devices</th></tr></thead><tbody><tr><td>A</td><td>"c *:3 rwm", "c 1:5 r"</td><td>all the rest</td></tr><tr><td>B</td><td>"c 1:3 rwm", "c 1:5 r"</td><td>all the rest</td></tr></tbody></table><p>可以在B中添加新的条目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;c 2:3 rwm&quot;</span> &gt;B/devices.allow<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;c 50:3 r&quot;</span> &gt;B/devices.allow<br></code></pre></td></tr></table></figure><h3 id="freezer子系统">freezer子系统</h3><p><strong>概述：</strong> 可以启动和停止cgroup中的进程</p><p><strong>需要开启的内核配置：</strong></p><ul><li>CONFIG_CGROUP_FREEZER</li></ul><p><strong>接口文件：</strong></p><ul><li>freezer.state: 读写文件<ul><li>cgroup的三种状态<ul><li>FROZEN：挂起该cgroup中的任务</li><li>FREEZING：该系统正在挂起该cgroup中的任务</li><li>THAWED：已经恢复该cgroup中的任务</li></ul></li><li>当被读取时，返回该group的有效状态（也就是上面三种状态）。这是自己和父cgroup状态的结合。如果有FREEZING，则cgroup的状态为FREEZING</li><li>当属于cgroup及其子cgroup所有任务被冻结时，cgroup转换为FROZEN。注意，当一个新任务被添加到cgroup或它的子cgroup中，cgroup会从FROZEN状态恢复到FREZING状态，直到新任务被冻结</li><li>写入时，设置cgroup的self-state。允许两个值：FROZEN和THAWED。如果写了FROZEN，则cgroup和它的所有子cgroup一起进入FROZEN状态</li><li>如果写入THAWED，则cgroup的self-state更改为THAWED。注意，如果父cgroup状态仍处于FROZEN，则有效状态可能不会被更改为THAWED。如果cgroup的有效状态变为THAWED，则由于cgroup而冻结的所有子cgroup将离开FROZEN状态</li></ul></li><li>freezer.self_freezing:只读文件。显示self-state。如果是0，则为THAWED状态；否则为1。如果最后一次写入了FORZEN，这个值为1</li><li>freezer.parent_freezing:只读文件。显示parent-state。如果cgroup的父cgroup不是FROZEN，则为0；否则为1</li></ul><p><strong>注意事项：</strong></p><ul><li>挂起进程时，会连同子进程一同挂起</li><li>不能将进程移动到处于FROZEN状态的cgroup中</li><li>只有FROZEN状态和THAWED状态可以被写进freezer.state中，FREEZING状态则不能，只能读取它</li><li>root cgroup是不可冻结的</li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/freezer<br>mount -t cgroup -ofreezer freezer /sys/fs/cgroup/freezer<br><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/freezer/0<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$some_pid</span> &gt; /sys/fs/cgroup/freezer/0/tasks<br></code></pre></td></tr></table></figure><p>获取子系统的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /sys/fs/cgroup/freezer/0/freezer.state<br>output: THAWED<br></code></pre></td></tr></table></figure><p>冻结子系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> FROZEN &gt; /sys/fs/cgroup/freezer/0/freezer.state<br><span class="hljs-built_in">cat</span> /sys/fs/cgroup/freezer/0/freezer.state<br>output: FREEZING<br><span class="hljs-built_in">cat</span> /sys/fs/cgroup/freezer/0/freezer.state<br>output: FROZEN<br></code></pre></td></tr></table></figure><p>解冻子系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> THAWED &gt; /sys/fs/cgroup/freezer/0/freezer.state<br><span class="hljs-built_in">cat</span> /sys/fs/cgroup/freezer/0/freezer.state<br>output: THAWED<br></code></pre></td></tr></table></figure><p><strong>linux kernel文档原文：</strong></p><ul><li><p>对于批处理作业管理系统来说，cgroupfreeze是非常有用的，它可以启动和停止任务集，以便根据系统管理员的需要调度机器的资源。这种类型的程序通常用于HPC集群，以调度对整个集群的访问。cgroupfreezer使用cgroups来描述处理作业管理系统要启动/停止的任务集。它还提供了启动和停止组成作业的任务的方法。</p></li><li><p>freezer对于检查点运行中的任务组也很有用。freezer允许检查点代码通过尝试强制cgroup中的任务进入静止状态来获得任务的一致映像。一旦任务处于静止状态，另一个任务就可以walk/proc或调用内核接口来收集关于静止状态的任务的信息。如果发生可恢复的错误，可以稍后重新启动检查点任务。这还允许通过将收集到的信息复制到另一个节点并重新启动任务，在集群中的节点之间迁移检查点任务。</p></li><li><p>SIGSTOP和SIGCONT序列并不总是足以停止和恢复用户空间中的任务，这两个信号都可以从我们希望冻结的任务中观察到，虽然SIGSTOP不能被捕获、阻塞或忽略，但可以通过等待或跟踪父任务来查看它。SIGCONT尤其不合适，因为它可能被任务捕获。任何旨在监视SIGSTOP和SIGCONT的程序都可能被试图使用SIGSTOP和SIGCONT来停止和恢复任务而破坏。我们可以用嵌套的bashshell来演示这个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> $$<br>16644<br>$ bash<br>$ <span class="hljs-built_in">echo</span> $$<br>16690<br><br>From a second, unrelated bash shell:<br>$ <span class="hljs-built_in">kill</span> -SIGSTOP 16690<br>$ <span class="hljs-built_in">kill</span> -SIGCONT 16690<br><br>&lt;at this point 16690 exits and causes 16644 to <span class="hljs-built_in">exit</span> too&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="hugetlb子系统">hugetlb子系统</h3><p><strong>概述：</strong>允许限制cgroup的hugepage使用量和hugepage预留。</p><p><strong>需要的内核配置：</strong></p><ul><li>CONFIG_CGROUP_HUGETLB</li><li>CONFIG_HUGETLB_PAGE</li><li>CONFIG_HUGETLBFS</li></ul><p><strong>hugepage使用量接口文件：</strong></p><ul><li>hugetlb.2MB.limit_in_bytes:读写文件。设置hugepage大小为2MB的hugepage使用量限制</li><li>hugetlb.1GB.limit_in_bytes:读写文件。设置hugepage大小为1GB的hugepage使用量限制</li><li>hugetlb.2MB.max_usage_in_bytes:只读文件。显示hugepage大小为2MB最大hugepages使用记录</li><li>hugetlb.1GB.max_usage_in_bytes:只读文件。显示hugepage大小为1GB最大hugepages使用记录</li><li>hugetlb.2MB.usage_in_bytes:只读文件。显示hugepages大小为2MB的hugepage的当前使用量</li><li>hugetlb.1GB.usage_in_bytes:只读文件。显示hugepages大小为1GB的hugepage的当前使用量</li><li>hugetlb.2MB.failcnt:只读文件。显示hugepage大小为2MB由于hugepage使用限制导致的分配失败</li><li>hugetlb.1GB.failcnt:只读文件。显示hugepage大小为1GB由于hugepage使用限制导致的分配失败</li></ul><p><strong>hugepage预留接口文件：</strong></p><p><strong>接口文件:</strong></p><ul><li>hugetlb.2MB.rsvd.limit_in_bytes:读写文件。设置hugepage大小为2MB的hugepage预留限制</li><li>hugetlb.1GB.rsvd.limit_in_bytes:读写文件。设置hugepage大小为1GB的hugepage预留限制</li><li>hugetlb.2MB.rsvd.max_usage_in_bytes:只读文件。显示hugepage大小为2MB最大hugepages预留记录</li><li>hugetlb.1GB.rsvd.max_usage_in_bytes:只读文件。显示hugepage大小为1GB最大hugepages预留记录</li><li>hugetlb.2MB.rsvd.usage_in_bytes:只读文件。显示hugepages大小为2MB的hugepage的当前预留量</li><li>hugetlb.1GB.rsvd.usage_in_bytes:只读文件。显示hugepages大小为1GB的hugepage的当前预留量</li><li>hugetlb.2MB.rsvd.failcnt:只读文件。显示hugepage大小为2MB由于hugepage预留限制导致的分配失败</li><li>hugetlb.1GB.rsvd.failcnt:只读文件。显示hugepage大小为1GB由于hugepage预留限制导致的分配失败</li></ul><p><strong>查看hugepage使用情况：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/meminfo | grep Huge<br></code></pre></td></tr></table></figure><p><strong>修改系统中hugepage大小：</strong></p><p>在<code>/etc/default/grub</code>中增加<code>default_hugepagesz=1G hugepagesz=1G</code>配置，然后更新grub配置</p><p>然后更新配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> update-grab <span class="hljs-comment"># ubuntu22</span><br><span class="hljs-built_in">sudo</span> grub2-mkconfig -o /boot/grub2/grub.cfg <span class="hljs-comment"># opencloudos 8.8/9.2/Stream 23</span><br></code></pre></td></tr></table></figure><p>最后重启系统即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reboot<br></code></pre></td></tr></table></figure><h3 id="memory子系统">memory子系统</h3><p><strong>概述：</strong> 限制cgroup所能使用的内存上限</p><p><strong>需要的内核配置：</strong></p><ul><li>CONFIG_MEMCG</li><li>CONFIG_SWAP</li></ul><p><strong>接口文件：</strong></p><ul><li><p>memory.usage_in_bytes:只读文件。显示当前内存使用情况，单位为字节</p></li><li><p>memory.memsw.usage_in_bytes:只读文件。显示当前内存+交换的使用情况，单位为字节</p></li><li><p>memory.max_uasge_in_bytes:只读文件。显示记录的最大内存使用量，单位为字节</p></li><li><p>memory.memsw.max_usage_in_bytes:只读文件。显示记录的最大内存+交换使用量，单位为字节</p></li><li><p>memory.failcnt:只读文件。显示内存达到memory.limit_in_bytes设定的限制值的次数</p></li><li><p>memory.memsw.failcnt:只读文件。显示内存+swap空间限制达到在memory.memsw.limit_in_bytes设定的值的次数</p></li><li><p>memory.limit_in_bytes:读写文件。设定最大的内存使用量（包括文件缓存），可以加单位(k/K, m/M,g/G)不加单位默认为bytes。不能限制rootcgroup。写入-1删除现有的限制</p></li><li><p>memory.soft_limit_in_bytes:读写文件。和memory.limit_in_bytes的差异是，这个限制并不会阻止进程使用超过限额的内存，只是在系统内存不足时，会优先回收超过限额的进程占用的内存，使之向限定值靠拢。该值应小于memory.limit_in_bytes设定值【在有CONFIG_PREEMPT_RT系统中不可用】</p></li><li><p>memory.memsw.limit_in_bytes:读写文件。设定最大的内存+swap的用量之和。可以加单位(k/K, m/M,g/G)不加单位默认为bytes。不能限制根cgroup。写入-1删除现有的限制</p></li><li><p>memory.force_empty:只写文件。当写入0时，清空该group的所有内存页。该选项只有在当前group没有tasks才可以使用。删除cgroup前请使用memory.force_empty以避免将不再使用的页面缓存移动到它的上级cgroup中</p></li><li><p>memory.swappiness:读写文件。将内核倾向设定为换出这个cgroup中任务所使用的进程内存，而不是从页缓冲中再生页面。这也是在/proc/sys/vm/swappiness中设定的使用同一方法为整个系统设定的内核倾向。默认值为60，低于这个值会降低内核换出进程内存的倾向，将其设定为0则完成不会为cgroup中的任务换出进程内存。高于这个值将提高内核换出进程内存的倾向，等于100时内核将开始换出作为这个cgroup中进程的地址空间的一部分页面。不能更改以下群组的swappniess：根cgroup，它使用在/proc/sys/vm/swappiness中设定的swappiness。</p></li><li><p>cgroup.event_control:只写文件。event_fd()的接口【在有CONFIG_PREEMPT_RT系统中不可用】</p></li><li><p>memory.pressure_level:读写文件。设置内存压力通知。压力级别通知用于监控内存分配成本；基于压力，应用程序可以实现不同的内存资源管理策略。</p><ul><li><p>压力等级定义：</p><ul><li>lowlevel：意味着系统正在为新的分配回收内存。监视此回收活动可能有助于维护缓存级别。收到通知后，程序（通常是"ActivityManger"）可能会分析vmstat并提前采取行动</li><li>mediumlevel：意味着系统正经历中等内存压力，系统可能正在进行交换、分页出活动文件缓存等。在此事件发生后，应用程序可能决定进一步分析vmstat/zoneinfo/memcg或内部内存使用统计数据，并释放任何可以轻松重构或从磁盘重新读取的资源</li><li>criticallevel：意味着系统处于主动抖动状态，即将内存不足(OOM)，甚至内核内的OOMkiller即将触发。应用程序应该尽其所能帮助系统。咨询vmstat或其他统计信息可能为时已晚，因此建议立即采取行动</li></ul></li><li><p>三种事件传播方式：</p><ul><li>default：事件向上传播，直到事件被处理。比如有A-&gt;B-&gt;C，现在C承受一些压力，在ABC上设置了事件监听器，则只有C会收到通知。如果只在AB上设置了事件监听器，则只有B会受到通知</li><li>hierarchy：事件总是向上传播到根节点。类似default模式，但是这个模式无论每个级别是否有事件监听器，传播都会继续进行，直到到达根节点</li><li>local：事件只在注册通知的memcg中遇到内存压力时接收通知。在上面的例子中，如果C组注册了本地通知，则该组将受到通知，并且改组经历内存压力。但是，如果B注册了本地通知，则无论C组是否有事件监听器，B组都将不会受到通知</li></ul></li><li><p>级别和事件通知模式由逗号分隔的字符串指定。例如："low,hierarchy"</p></li><li><p>要注册通知，应用程序必须：</p><ul><li>使用eventfd(2)创建一个eventfd</li><li>打开memory.pressure_level</li><li>将字符串写入cgroup.event_control，字符串格式如"<event_fd> &lt;fd ofmemory.pressure_level&gt; &lt;level[, mode]&gt;"</li></ul></li><li><p>当内存压力达到特定级别或更高时，将通过eventfd通知应用程序。并不能直接读写memory.pressure</p></li><li><p>测试示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory/<br><span class="hljs-built_in">mkdir</span> foo<br><span class="hljs-built_in">cd</span> foo<br>cgroup_event_listener memory.pressure_level critical,hierarchy &amp;<br><span class="hljs-built_in">echo</span> 50M &gt; memory.limit_in_bytes<br><span class="hljs-built_in">echo</span> 50M &gt; memory.memsw.limit_in_bytes<br><span class="hljs-built_in">echo</span> $$ &gt; tasks<br>stress-ng --vm 1 --vm-bytes 51M --vm-keep -t 1s<br></code></pre></td></tr></table></figure><p>cgroup_event_listener是一个工具，完成了上面说的应用程序必须要进行的步骤，源码地址：<ahref="https://github.com/torvalds/linux/blob/master/samples/cgroup/cgroup_event_listener.c">linux/samples/cgroup/cgroup_event_listener.cat master · torvalds/linux(github.com)</a>。参数1是memory.pressure路径，参数2是压力级别和事件通知模式。上面的测试预期输出：memory.pressure_levelcritical,hierarchy:crossed，表示该cgroup内存压力达到或超过指定的critical级别，意味着内存压力测试成功触发了memory.pressure_level事件。</p></li></ul></li><li><p>memory.oom_control: 读写文件。当进程出现Out ofMemory时，是否进行kill操作。默认值0，表示kill；设置为1时，进程将进入睡眠状态，等待内存充足时被唤醒</p><ul><li>oom_kill_disable：当设置为0时，表示在这个cgroup内存不足时，OOMkiller是启用的，可以杀死大量占用内存的进程来释放内存；当值为1时，表示禁用OOMkiller，即使内存不足也不会自动杀死进程</li><li>under_oom：当值为0时，表示当前没有OOM条件发生在这个cgroup中；当值为1时，表示这个cgroup目前正处于oom状态，即系统已经检测到内存不足的情况，并可能正在尝试杀死一些进程来释放内存</li><li>oom_kill：这个字段显示了由于OOM条件而被杀死的进程数量。每次OOMkiller杀死cgroup中的一个进程时，这个计数器就会增加</li></ul></li><li><p>memory.stat：报告大范围内存统计，如下表所述</p><table><thead><tr><th>统计</th><th>描述</th></tr></thead><tbody><tr><td>cache</td><td>页缓存，包括tmpfs，单位为字节</td></tr><tr><td>rss</td><td>匿名和swap缓存，不包括tmpfs，单位为字节</td></tr><tr><td>mapped_file</td><td>memory-mapped映射的文件大小，包括tmpfs，单位为字节</td></tr><tr><td>pgpgin</td><td>存入内存中的页数</td></tr><tr><td>pgpgout</td><td>从内存中读出的页数</td></tr><tr><td>swap</td><td>swap用量， 单位为字节</td></tr><tr><td>active_anon</td><td>在活跃的最近最少使用(LRU)列表中的匿名和swap缓存，包括tmpfs，单位为字节</td></tr><tr><td>inactive_anon</td><td>不活跃的LRU列表和swap缓存，包括tmpfs，单位为字节</td></tr><tr><td>active_file</td><td>活跃的LRU列表中的file-backed内存，以字节为单位</td></tr><tr><td>inactive_file</td><td>不活跃LRU列表中的file-backed内存，以字节为单位</td></tr><tr><td>unevictable</td><td>无法再生的内存，以字节为单位</td></tr><tr><td>hierarchical_memory_limit</td><td>包含memory cgroup的层级的内存限制，单位为字节</td></tr><tr><td>hierarchical_memsw_limit</td><td>包含memory cgroup的层级的内存加swap限制，单位为字节</td></tr></tbody></table><ul><li>另外：除了hierarchical_memory_limit和hierarchical_memsw_limit，其他都有一个对应的total前缀，表示该cgroup及其所有子cgroup的全部统计</li><li>各个统计数据之间的关系：<ul><li>active_anon + inactive_anon = 匿名内存 + tmpfs文件缓存 +swap缓存，因此active_anon + inactive_anon不等于rss，因为rss不包含tmpfs</li><li>active_file + inactive_file = 缓存 - tmpfs大小</li></ul></li></ul></li><li><p>memory.numa_stat：显示每个numa节点的内存使用数量</p></li><li><p>memory.kmem.usage_in_bytes：显示当前内核内存分配</p></li><li><p>memory.kmem.max_usage_in_bytes：显示记录的最大内核内存使用情况</p></li><li><p>memory.kmem.failcnt：限制内核内存使用达到限制的次数</p></li><li><p>memory.kmem.tcp.limit_in_bytes：设置TCP硬限制</p></li><li><p>memory.kmem.tcp.usage_in_bytes：显示当前的TCP但内存分配</p></li><li><p>memory.kmem.tcp.failcnt：显示TCP的数量，但内存使用达到限制</p></li><li><p>memory.kmem.tcp.max_usage_in_bytes：显示记录的最大TCP但内存使用情况</p></li></ul><h3 id="net_cls子系统">net_cls子系统</h3><p><strong>概述：</strong>使用等级标识符(classid)标记网络数据包，可允许linux流量控制程序(trafficcontroller,tc)识别从具体cgroup中生成的数据包，为来自不同cgroup的报文分配不同的优先级</p><p><strong>需要开启的内核配置：</strong></p><ul><li>CONFIG_CGROUP_NET_CLASSID</li></ul><p><strong>接口文件：</strong></p><ul><li><p>net_cls.classid:读写文件。包含一个说明流量控制句柄的十六进制的值，初始值为0。。这些句柄的格式为0xAAAABBBB，其中AAAA是十六进制主设备号，BBBB是十六进制副设备号。</p></li><li><p>net_pero.ifpriomap：配置网卡的优先级映射</p></li><li><p>net_prio.priodx：显示当前cgroup的优先级索引</p></li></ul><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/net_cls<br>mount -t cgroup -onet_cls net_cls /sys/fs/cgroup/net_cls<br><span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/net_cls/0<br><span class="hljs-comment"># 设置10:1的句柄</span><br><span class="hljs-built_in">echo</span> 0x100001 &gt; net_cls.classid<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> net_cls.classid<br>output: 1048577<br></code></pre></td></tr></table></figure><p>配置tc：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tc qdisc add dev lo root handle 10: htb<br><span class="hljs-comment"># 创建新</span><br>tc class add dev lo parent 10: classid 10:1 htb rate 5mbit<br></code></pre></td></tr></table></figure><p>创建过滤器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tc filter add dev lo parent 10: protocol ip prio 10 handle 1: cgroup<br></code></pre></td></tr></table></figure><p>删除规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tc qdisc del dev lo root<br></code></pre></td></tr></table></figure><p>查看类具体情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tc -s class show dev ens33<br></code></pre></td></tr></table></figure><h3 id="net_prio子系统">net_prio子系统</h3><p><strong>概述：</strong>允许设置各种应用程序产生的网络流量的优先级</p><p><strong>接口文件：</strong></p><ul><li><p>net_prio.ifpriomap:读写文件。该文件包含分配给来自该组进程的流量的优先级映射。这些流量从不同的接口流出系统。它包含一个形式为&lt;ifnamepriority&gt;的元组列表。可以通过使用相同的元组格式将字符串回显到文件中来修改文件内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eth0 5&quot;</span> &gt; /sys/fs/cgroups/net_prio/iscsi/net_prio.ifpriomap<br></code></pre></td></tr></table></figure><ul><li>该命令将强制从属于iscsi net_priogroup的进程发出，从eth0接口出接口的任何流量将所述流量的优先级设置为5。父cgroup也会有一个可写的net_prio.ifpriomap文件，用于设置系统默认优先级</li><li>优先级是在将帧排队到qdisc之前设置的</li><li>net_prio的一种用法是与mqprioqdisc一起使用，允许将应用程序流量引导到基于硬件/驱动程序的流量类。然后可以由管理员或其他网络协议管理这些映射</li></ul></li><li><p>net_prio.proidx：只读文件。它包含一个唯一的整数值，内核使用它作为cgroup的内部表示</p></li></ul><h3 id="perf_event子系统">perf_event子系统</h3><p><strong>概述：</strong>该层级中的所有cgroup可以使用perf工具对这些进程和线程监控，没有可供调节的参数</p><h3 id="pids子系统">pids子系统</h3><p><strong>概述：</strong>允许cgroup在达到一定限制后阻止任何新任务被fork()或clone()</p><p><strong>需要开启的内核配置：</strong></p><ul><li>CONFIG_CGROUP_PIDS</li></ul><p><strong>接口文件:</strong></p><ul><li>pids.max: 读写文件。设置最大任务数，不能在rootcgroup中使用。默认值是max</li><li>pids.current:只读文件。目前cgroup运行的任务数，pids.current有可鞥大于pids.max，通过设置pids.max小于pids.current实现，但是不可能通过fork和clone实现</li><li>pids.events: 只读文件。包含事件计数器：<ul><li>max: 由于自身或父cgroup达到限制，cgroup 中 fork 失败的次数</li></ul></li></ul><h3 id="misc子系统">misc子系统</h3><p><strong>概述：</strong> misc控制器提供了资源限制和跟踪机制</p><p><strong>需要开启的内核配置：</strong></p><p>CONFIG_CGROUP_MISC</p><p><strong>接口文件：</strong></p><ul><li><p>misc.capacity：只读文件。显示了平台上可用的各种标量资源及其数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> misc.capacity<br>output: <br>res_a 50<br>res_b 10<br></code></pre></td></tr></table></figure></li><li><p>misc.current：只读文件。显示了cgroup及其子cgroup中资源的当前使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> misc.current<br>res_a 3<br>res_b 0<br></code></pre></td></tr></table></figure></li><li><p>misc.max：读写文件。非根cgroup存在；允许最大限度地使用cgroup及其子cgroup中的资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> misc.max<br>output:<br>res_a max<br>res_b 4<br></code></pre></td></tr></table></figure><p>Limit can be set by</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> res_a 1 &gt; misc.max<br><span class="hljs-built_in">echo</span> res_a max &gt; misc.max<br></code></pre></td></tr></table></figure></li><li><p>misc.event：只读文件。定义了以下条目。除非另有指定，否则此文件中的值更改将生成文件修改事件，该文件中的所有字段都是分层的</p><ul><li>max：cgroup的资源使用超过最大边界的次数</li></ul></li></ul><p><strong>迁移和所有权：</strong>一个杂项的标量资源被分配给第一个使用它的cgroup，并一直分配给该cgroup，直到该资源被释放。将进程迁移到不同的cgroup不会将费用迁移到进程已移动的目标cgroup</p><h2 id="cgroup-v2">Cgroup V2</h2><h3 id="基础操作">基础操作</h3><h4 id="组织进程和线程">组织进程和线程</h4><p><strong>进程：</strong></p><p>最初，只存在所有进程所属的根cgroup。子cgroup可以通过创建子目录来创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$CGROUP_NAME</span><br></code></pre></td></tr></table></figure><p>一个给定的cgroup可以有多个子cgroup形成树形结构。每个cgroup都有一个可读写的接口文件"cgroup.procs"。读取时，它每行列出属于cgroup的所有进程的PID。PID不是有序的，如果进程被移动到另一个cgroup，然后返回，或者PID在读取时被回收，同一个PID可能会出现不止一次</p><p>通过将进程的PID写入目标cgroup的cgroup.procs，可以将进程迁移到cgroup中。一个write(2)掉哦那个只能迁移一个进程，如果一个进程由多个线程组成，写入任何线程的PID偶会迁移该进程的所有线程</p><p>当一个进程派生一个子进程时，新进程在操作时出生在该分支进程所属的cgroup中。退出后，进程与退出时所属的cgroup保持关联，直到它被回收。但是，cgroup.procs不会出现僵尸进程，因此不能移动到另一个cgroup</p><p>没有任何子进程或活动进程的cgroup可以通过删除目录来销毁。请注意，没有任何子进程且只与僵尸进程相关联的cgroup被认为是空的，可以删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> <span class="hljs-variable">$CGROUP_NAME</span><br></code></pre></td></tr></table></figure><p>/proc/$PID/cgroup列出了进程的cgroup成员。如果系统中使用的是cgroupv1，则该文件可能包含多行，每个层次一个。cgroup v2的条目格式是"$PATH"</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/<span class="hljs-variable">$PID</span>/cgroup<br>output:<br>0::/test-cgroup/test-cgroup-nested<br></code></pre></td></tr></table></figure><p>如果进程变成僵尸进程，并且它所关联的cgroup随后被删除。“(deleted)”被附加到路径中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/<span class="hljs-variable">$PID</span>/cgroup<br>output:<br>0::/test-cgroup/test-cgroup-nested(deletd)<br></code></pre></td></tr></table></figure><p><strong>线程：</strong></p><p>cgroupv2支持控制器子集的线程粒度，以支持需要在进程线程之间进行分配资源分配的用例。默认情况下，进程的所有线程都属于同一个cgroup，该cgroup还充当资源域，用于承载不特定于进程或线程的资源小号。线程模式允许线程分布在子树中，同时仍为它们维护公共资源域</p><p>支持线程模式的控制器被称为线程控制器，不支持线程模式的控制器被称为域控制器</p><p>将cgroup标记为线程化会使其作为线程化cgroup加入其父级的资源域。父级可能是另一个线程化cgroup，其资源域在层次结构上更靠上。线程化子树的根，即最近的非线程化祖先，可互换地称为线程域或线程根，并充当整个子树的资源域</p><p>在线程子树内部，进程的线程可以放在不同的cgroup中，并且不受内部进程约束——无论非叶cgroup中是否是有线程，都可以在非叶cgroup上启用线程控制器</p><p>由于线程域cgroup承载子树的所有域资源消耗，因此无论其中是否有进程，它都被视为具有内部资源消耗，并且不能包含未线程化的已填充子cgroup。由于根cgroup不受任何内部进程约束，因此它既可以充当线程域，也可以充当域cgroup的父级</p><p>cgroup当前的运行模式或类型在cgroup.type中显示，该文件表明该cgroup是普通域、作为线程子树的域的域还是线程cgroup</p><p>在创建时，cgroup始终是域cgroup，可以通过将"threaded"写入cgroup.type文件来实现线程化，操作是单向的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> threaded &gt; cgroup.types<br></code></pre></td></tr></table></figure><p>一旦线程化，cgroup就不能再次称为域。要启用线程模式，必须满足以下条件：</p><ul><li>因为cgroup将加入父级的资源域。父级必须是有效(线程)域或线程cgroup</li><li>当父域为非线程域时，它不得启用任何域控制器或填充任何子域。根域不受此要求限制</li></ul><p>从拓扑角度来看，cgroup可能处于无效状态，请考虑以下拓扑：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">A (threaded domain) - B (threaded) - C (domain, just created)<br></code></pre></td></tr></table></figure><p>C创建为域，但未连接到可托管子域的父域。C无法使用直到它变成线程cgroup。在这些情况下，cgroup.type文件将报告"domain(invalid)"。由于拓扑无效而失败的操作使用EOPNOTSUPP作为errno</p><p>当域cgroup的某个子cgroup变成线程化或"cgroup.subtree_control"文件中启用线程控制器且cgroup中有进程时，域cgroup将变成线程化域。当条件清除时，线程化域变为普通域</p><p>读取时，"cgroup.threads"包含cgroup中所有线程的线程ID列表。除了操作是针对每个线程而不是每个进程之外，"cgroup.threads"具有相同的格式，并且行为方式与"cgroup.procs"相同。虽然可以在任何cgroup中写入"cgroup.threads"，因为它只能在同一个线程域内移动线程，但其操作仅限于每个线程子树内</p><p>线程域cgroup充当整个子树的资源域，虽然线程可以分散在子树，但所有进程都被视为位于线程域cgroup中，线程域cgroup中的cgroup.procs包含子树所有进程的PID，在子树中无法读取。但是，cgroup.procs可以从子树中的任何位置写入，以将匹配进程的所有线程迁移到cgroup</p><p>线程子树中只能启动线程控制器。在线程子树中启用线程控制器时，它仅考虑和控制与cgroup及其后代中的线程相关的资源消耗。所有不与特定线程绑定的消耗都属于线程域cgroup</p><p>由于线程子树不受任何内部进程约束的约束，线程控制器必须处理非叶cgroup及其子cgroup中的线程之间的竞争，每个线程控制器都定义了如何处理此类竞争</p><p>目前，以下控制器是线程化的，可以在线程cgroup中启用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">- cpu<br>- cpuset<br>- perf_event<br>- pids<br></code></pre></td></tr></table></figure><h4 id="populated-通知">populated 通知</h4><p>每个非根cgroup都有一个cgroup.events文件，其中包含polutated，指示cgroup的子层次结构中是否有活动进程。如果cgroup及其后代中没有活动进程，则其值为0；否则为1。当值更改时，会触发poll和notify事件。例如，这可用于在给定子层次结构的所有进程退出启动清理操作。populated状态更新和通知是递归的。考虑以下子层次结构，其中括号中的数字表示每个cgroup中的进程数：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">A(4) - B(0) - C(1)<br>            \ D(0)<br></code></pre></td></tr></table></figure><p>A、B和C的populated字段将为1，而D为0。在C中的一个进程退出后，B和C的populated字段将翻转为0，并且两个cgroups的cgroup.events文件上都会生成文件修改事件</p><h4 id="cgroup.controllers">cgroup.controllers</h4><p><strong>启用和禁用：</strong></p><p>每个cgroup都有一个cgroup.controllers文件，其中列出了该cgroup可以启用的所有控制器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> cgroup.controllers<br></code></pre></td></tr></table></figure><p>默认情况下不启用任何控制器，可以通过写入"cgroup.subtree_control"文件来启用和禁用控制器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;+cpu +memory -io&quot;</span> &gt; cgroup.subtree_control<br></code></pre></td></tr></table></figure><p>仅可启用"cgroup.controllers"中列出的控制器，当指定多个上述操作时，它们要么全部成功，要么全部失败。如果对同一个控制器指定了多个操作，则最后一个操作有效</p><p>在cgroup中启用控制器表示将控制目标资源在其直属子级之间的分布。请考虑以下子层次结构，已启用的控制器在括号中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">A(cpu,memory) - B(memory) - C()<br>  \ D()<br></code></pre></td></tr></table></figure><p>由于A启用了cpu和memory，A将控制向其子进程（本例为B）分配CPU周期和内存。由于B启用了memory但未启用CPU，C和D可以自由竞争CPU周期，但对B可用内存的分配将受到控制</p><p>由于控制器负责调节目标资源向cgroup子节点的分配，因此启用它会在子cgroup中创建控制器的接口文件。在上面的例子中，在B上启用cpu会在C和D中创建以"cpu."为前缀的控制器接口文件。同样，在B上禁用memory会从C和D中删除以"memory."为前缀的控制器接口文件。这意味着控制器接口文件（任何不以cgroup.开头的文件）都归父节点所有，而不是cgroup本身</p><p><strong>自上而下的约束：</strong></p><p>资源自上而下分配，并且只有当资源已从父级分配给cgroup时，cgroup才能进一步分配资源。这意味着所有非根"cgroup.subtree_control"文件只能包含在父级"cgroup.subtree_control"文件中启用的控制器。</p><p><strong>无内部进程约束：</strong></p><p>非根cgroup只有在没有自己的进程时才能将域资源分配给其子cgroup，换句话说，只有不包含任何进程的域cgroup才能在其"cgroup.subtree_control"文件中启用域控制器</p><p>这可以保证当域控制器查看已启用它的层次结构部分时，进程始终只位于叶子上。这排除了子cgroup与父cgroup的内部进程竞争的情况</p><p>根cgroup不受此限制。根包含进程和匿名资源消耗，这些资源消耗不能与任何其他cgroup关联，并且需要大多数控制器的特殊处理。如何管理根cgroup中的资源消耗取决于每个控制器</p><p>注意：如果cgroup的cgroup.subtree_control中没有启用控制器，则限制不会起作用。这很重要，否则就无法创建已polutatedcgroup的子项。要控制cgroup的资源分配，cgroup必须创建子项并将其所有基础南横转移到子项，然后才能在其"cgroup.subtree_control"文件中启用控制器</p><h3 id="委派">委派</h3><p><strong>委派模型：</strong></p><p>cgroup可以通过两种方式委派。首先，通过向用户授予目录及其cgroup.procs，cgroup.threads和cgroup.subtree_control文件的写入权限，委派给权限较低的用户。其次，如果设置了nsdelegate挂载选项，则在创建命名空间时自动委派给cgroup命名空间</p><p>由于给定目录中的资源控制接口文件控制父级资源的分配，因此不应允许委托人写入这些文件。对于第一种方法，这是通过不授予对这些文件的访问权限来实现的。对于第二种方法，内核拒绝从命名空间内部写入命名空间根目录上除cgroup.procs和cgroup.subtree_control之外的所有文件</p><p>两种委派类型的最终结果是相同的。一旦委派，用户可以在目录下建立子层次结构，根据需要组织其中的进程，并进一步分配从父级获得的资源。所有资源控制器的控制和其他设置都是分层的，无论委派的子层次结构中发生上面，都无法逃脱父级施加的资源限制。</p><p>目前，cgrou对委派子层次结构中的cgroup数量或嵌套深度没有任何限制。但是，将来可能会明确限制</p><p><strong>委派控制：</strong></p><p>委派子层次结构被包含在某种意义上，则被委派者不能将进程移入或移出子层次结构</p><p>对于授权给较低权限用户的委派，这是通过要求具有非rooteuid的进程满足以下条件来将目标进程迁移到cgroup中，方法是将其PID写入cgroup.procs文件</p><ul><li>写入者必须具有cgroup.procs文件的写权限</li><li>写入者必须对源和目标cgroups的共同祖先的cgroup.procs文件具有写入权限</li></ul><p>上述两个约束确保了虽然被委派者可以在委派的子层次结构中自由迁移流程，但不能从子层次结构外部拉入或推出。</p><p>举例来说，假设cgroupC0和C1已委派给用户U0，该用户在C0下创建了C00、C01，在C1下创建了C10，如下所示，且C0和C1下的所有进程都属于U0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">~~~~~~~~~~~~~ - C0 - C00<br>~ cgroup    ~      \ C01<br>~ hierarchy ~<br>~~~~~~~~~~~~~ - C1 - C10<br></code></pre></td></tr></table></figure><p>假设U0想要将当前位于C10中的进程的PID写入C00/cgroup.procs。U0具有该文件的写入访问权限；但是源cgroupC10 和目标cgroupC00的共同祖先位于委派点之上，U0不具有其cgroup.procs的文件写访问权限，因此将使用-EACCESS拒绝该写入</p><p>对于命名空间的委托，遏制是通过要求源cgroup和目标cgroup都可从尝试迁移的进程的命名空间的访问来实现的。如果其中一个不可访问，则迁移将被拒绝并返回-ENOENT</p><h3 id="指南">指南</h3><p><strong>组织一次并控制：</strong></p><p>跨cgroup迁移进程是一项相对昂贵的操作，并且内存等有状态资源不会随进程一起移动。这是一个明确的设计决策，因为在同步成本方面，迁移和各种热路径之间通常存在固有的权衡</p><p>因此，不建议频繁地跨cgroup迁移进程以应用不同的资源限制。启动时应根据系统的逻辑和资源结构将工作负载分配给cgroup，可以通过接口文件更改控制器配置来动态调整资源分配</p><p><strong>避免名称冲突：</strong></p><p>cgroup及其子cgroup的接口文件占用同一目录，因此可能会创建与接口文件冲突的子cgroup</p><p>所有cgroup的核心接口文件都以"cgroup."作为前缀，每个控制器的接口文件都以控制器名称和点作为前缀。控制器的名称由小写字母和"_"组成，但从不以"_"开头，因此可以将其作为前缀字符以比避免冲突。此外，接口文件名不会以通常用于对工作负载进行分类的术语（例如作业、服务、切片、单元或工作负载）开头或结尾</p><h3 id="资源分配模型">资源分配模型</h3><p><strong>权重：</strong></p><p>父母的资源分配方式是将所有活跃子女的权重相加，并为每个子女分配与其权重与总和之比相匹配的分数。由于只有当前可以使用资源的子女参与分配，因此这是节省工作的。由于其动态特性，此模型通常用于无状态资源</p><p>所有权重都在[1,10000]范围内，默认值为100。这允许在足够细的粒度下在两个方向上进行对称乘性偏差，同时保持在直观范围内。</p><p>值要权重在范围内，所有配置组合都是有效的，没有理由拒绝配置更改或流程迁移</p><p>cpu.weight按比例将CPU周期分配给活跃子进程，就是这种类型的一个例子</p><p><strong>限制：</strong></p><p>子进程最多只能消耗配置的资源量。限制可能会过大——子进程的总限制可能会超过父进程的资源量</p><p>限制在范围[0 max]内，默认为max</p><p>由于限制可能被过度承诺，所有配置组合都是有效的，没有理由拒绝配置更改或流程迁移</p><p>io.max限制cgroup在IO设备上可以消耗的最大BPS或IOPS，是此类型的一个示例</p><p><strong>保护措施：</strong></p><p>只要cgroup的所有祖先的使用量都低于其保护级别，则cgroup受到的保护量最高可达配置的资源量。保护可以硬性保证，也可以是尽力而为的软性边界。保护也可以过度承诺，在这种情况下，只有父级可用的资源在子级中受到保护</p><p>保护范围是[0, max]，默认为0，即无操作</p><p>由于保护措施可能被过度承诺，所有配置组合都是有效的，没有理由拒绝配置更改或流程迁移</p><p>memory.low实现尽力内存保护</p><p><strong>分配：</strong></p><p>一个cgroup被专门分配一定数量的有效资源，分配不能过度承诺——子组的分配总和不能超过父组的可用资源量</p><p>分配范围是[0, max]，默认为0，表示没有资源</p><p>由于分配不能过度承诺，因此某些配置组合无效，应予以拒绝。此外，如果资源对于流程的执行是必需的，则流程迁移可能会被拒绝</p><p>cpu.rt.max硬分配实时切片就是此类型的一个例子</p><h3 id="约定">约定</h3><ul><li><p>单个功能的设置应包含在单个文件中</p></li><li><p>根cgroup应免于资源控制，因此不应该具有资源控制接口文件</p></li><li><p>默认时间单位是微妙。如果使用其他单位，则必须提供明确的单位后缀</p></li><li><p>每单位数量的零件应使用百分比小数，且小数部分至少为两位数</p></li><li><p>如果控制器实现基于权重的资源分配，其接口文件应命名为权重，范围为[1,10000]，默认值为100，选择这些值是为了在两个方向上允许足够且对称的偏差，同时保持直观性</p></li><li><p>如果控制器实现了绝对资源保证或限制，则接口文件应分别命名为min和max。如果控制器实现了尽力资源保证或限制，则接口文件应分别命名为low和high。在上述四个文件的，应使用特殊标记max来表示读写向上无穷大</p></li><li><p>如果设置具有可配置的默认值和键入的特定覆盖，则默认条目应以default键入，并作为文件中的第一个条目出现。可以通过写入"defaul&amp;VAL" 或"$VAL"来更新默认值。当写入以更新特定覆盖时，可以使用"defaul"值来指示删除覆盖。读取时，不得出现以"default"作为值的覆盖条目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> cgroup-example-interface-file<br>output:<br>default 150<br>8:0 300<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;default 125&quot;</span> &gt; cgroup-example-interface-file<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;8:16 170&quot;</span> &gt; cgroup-example-interface-file<br><span class="hljs-built_in">cat</span> cgroup-example-interface-file<br>output:<br>default 125<br>8:16 170<br></code></pre></td></tr></table></figure></li><li><p>对于频率不是很高的事件，应创建一个接口文件events，列出事件键值对。每当发生可通知的事件时，应在文件上生成文件修改事件</p></li></ul><h3 id="已弃用的-v1-核心功能">已弃用的 v1 核心功能</h3><ul><li>不支持包括命名层次在内的多重层次。</li><li>不支持所有 v1 挂载选项。</li><li>“tasks”文件被删除，并且“cgroup.procs”未排序。</li><li>“cgroup.clone_children” 已被删除。</li><li>/proc/cgroups 对于 v2来说毫无意义。请改用根目录中的“cgroup.controllers”文件。</li></ul><h3 id="核心接口文件">核心接口文件</h3><p>所有cgroup核心接口文件都以"cgroup"为前缀</p><h4 id="cgroup.type">cgroup.type</h4><p>存在于非root cgroup上的读写单值文件</p><p>读取时，表示该cgroup当前的类型，可以是下列值之一：</p><ul><li>domain：正常有效的域cgroup</li><li>domain threaded：作为线程子树根的线程域cgroup</li><li>domaininvalid：处于无效状态的cgroup，无法填充或启用控制器，可能允许其成为线程cgroup</li><li>threaded：线程cgroup，是线程子树的成员</li></ul><p>通过将threaded写入此文件，可以将cgroup转变为线程cgroup</p><h4 id="cgroup.procs">cgroup.procs</h4><p>所有cgroup上都存在的读写换行分隔值文件</p><p>读取时，它会列出属于该cgroup的所有进程的PID，每行一个。PID不是按顺序排序的，如果进程被移动到另一个cgroup后又移回来，或者读取时PID被回收，则同一个PID可能会出现多次</p><p>可以写入PID，以将与PID关联的进程迁移到cgroup。写入者应满足以下所有条件：</p><ul><li>它必须对cgroup.procs文件具有写权限</li><li>它必须对源和目标cgroups的共同祖先的cgroup.procs文件具有写访问权限</li></ul><p>当委派子层次结构时，应与包含目录一起授予对此文件的写访问权限</p><p>在线程cgroup中的，由于所有进程都属于线程根，因此读取此文件失败并出现EOPNOTSUPP。支持写入并将进程的每个线程移至cgroup</p><h4 id="cgroup.threads">cgroup.threads</h4><p>所有cgroup上都存在的读写换行分隔值文件</p><p>读取时，它会以每行一个的方式列出属于该cgroup的所有线程的TID。TID是无序的，如果线程被移动到另一个cgroup然后又移回，或者读取时TID被回收，则同一个TID可能回出现多次</p><p>可以写入TID，以将与TID关联的线程迁移到cgroup，写入者应满足以下所有条件：</p><ul><li>它必须对cgroup.threads文件具有写权限</li><li>线程当前所在的cgroup必须与目标cgroup位于同一资源域中</li><li>它必须对源和目标cgroups共同祖先的cgroup.procs文件具有写访问权限</li></ul><h4 id="cgroup.controllers-1">cgroup.controllers</h4><p>所有cgroup上都存在的只读空格分隔值文件</p><p>它显示了cgroup可用的所有控制器的空格分隔值列表。控制器没有排序</p><h4 id="cgroup.subtree_control">cgroup.subtree_control</h4><p>所有cgroup上都存在的可读写空格分隔值文件。初始为空</p><p>读取时，它会显示以空格分割的控制器列表，这些控制器被启用来控制从cgroup到其子组的资源分配</p><p>可以写入以空格分隔的带有+或-前缀的控制器列表来启用或禁用控制器。带有+前缀的控制器名称将启用该控制器，带有-前缀的控制器名称将禁用该控制器。如果控制器在列表中出现多次，则最后一个有效。当指定多个启用和禁用操作时，要么全部成功，要么全部失败</p><h4 id="cgroup.event">cgroup.event</h4><p>存在于非rootcgroup上的只读平键文件。定义了以下条目。除非另有说明，否则此文件中的值更改会生成文件修改事件</p><ul><li>populated：如果cgroup或其他后代包含任何活动进程，则为1；否则为0</li><li>frozen：如果cgroup被冻结，则为1；否则为0</li></ul><h4 id="cgroup.max.descendants">cgroup.max.descendants</h4><p>读写单值文件。默认值为"max"</p><p>允许的最大后代cgroup数量。如果实际后代数量相等或更大，则在层次结构中创建新cgroup的尝试将失败</p><h4 id="cgroup.max.deep">cgroup.max.deep</h4><p>读写单值文件。默认值为max</p><p>当前cgroup下允许的最大下降深度。如果实际下降深度等于或大于该值，则尝试创建新的子cgroup将失败</p><h4 id="cgroup.stat">cgroup.stat</h4><p>具有以下条目的只读平键文件：</p><ul><li>nr_descendants：可见后代cgroup的总数</li><li>nr_dying_descendants：濒临消亡的后代cgroup总数。cgroup在被用户删除后将处于濒临消亡状态。cgroup将在一段未定义的时间内（可能取决于系统负载）保持濒临消亡状态，然后才会被彻底销毁。任何情况下，进程都不能进入正在垂死的cgroup，正在垂死的cgroup也无法复活。正在消亡的cgroup所消耗的系统资源不得超过其删除cgroup时所允许的限制</li></ul><h4 id="cgroup.freeze">cgroup.freeze</h4><p>存在于非root cgroup中的读写单值文件。允许的值为0和1。默认值为0</p><p>将1写入文件会导致cgroup及其所有后代cgroup被冻结。这意味着所有附属进程都将停止，直到cgroup明确解冻后才会运行。cgroup的冻结可能需要一些时间；此操作完成后，cgroup.events控制文件中的frozen值将更新为1，并发出相应的通知</p><p>cgroup可以通过其自身设置或任何祖先cgroup的设置进行解冻。如果任何祖先cgroup被解冻，则cgroup将保持冻结状态</p><p>冻结cgroup中的进程可以通过致命信号终止。它们还可以进入和离开冻结cgroup；要么通过用户的明确移动，要么冻结cgroup与fork()竞争。如果将进程移动到冻结cgroup，它将停止，如果将进程移出冻结cgroup，它将变为运行状态</p><p>cgroup的冻结状态不会影响任何cgroup树操作；可以删除冻结的cgroup，也可以创建新的子cgroup</p><h4 id="cgroup.kill">cgroup.kill</h4><p>存在于非root cgroup中的只写单值文件。唯一允许的值是1</p><p>将1写入文件会导致cgroup及其所有后代cgroup被终止。这意味着受影响的cgroup树种的所有进程都将通过SIGKILL终止</p><p>终止cgroup树将适当地处理并发分叉并防止迁移</p><p>在线程cgroup中，由于终止cgroup是一个进程定向操作，即，它会影响整个线程组，因此写入此文件会因EOPNOTSUPP而失败</p><h4 id="cgroup.pressure">cgroup.pressure</h4><p>允许值为0和1的读写单值文件。默认值为1</p><p>向文件写入0将禁用cgroup PSI记。向文件写入1将重新启用cgroup PSI。</p><p>此控制属性不是分层的，因此在cgroup中禁用或启用PSI不会影响后代中的PSI，并且不需要通过来自rootcgroup传递启用</p><h4 id="irq.pressure">irq.pressure</h4><p>读写嵌套键文件</p><p>显示IRQ/SOFTIRQ的压力失速信息。有关详细信息，请参阅：https://www.kernel.org/doc/html/latest/accounting/psi.html#psi</p><h3 id="控制器接口文件">控制器接口文件</h3><h4 id="cpu">CPU</h4><p><strong>警告：</strong>cgroup2尚不支持实时进程的控制。对于启用了CONFIG_RT_GROUP_SCHED选项以对实时进程进行组调度的内核，只有当所有RT进程都在根cgroup中时，才能启用cpu控制器。如果禁用了CONFIG_RT_GROUP_SCHED，则此限制不适用。请注意，系统管理软件可能已在系统启动过程中将RT进程放入非rootcgroup，并且可能需要将这些进程移动到rootcgroup，然后才能使用启用了CONFIG_RT_GROUP_SCHED的内核启用cpu控制器</p><p><strong>注意：</strong> 所有时间长度均以微妙为单位</p><p><strong>cpu.stat：</strong></p><p>只读平键文件。无论控制器是否启用，此文件都存在</p><p>它始终报告以下三个统计数据：</p><ul><li>usage_usec：CPU使用时间</li><li>user_usec：CPU用户态时间</li><li>system_usec：CPU内核态时间</li></ul><p>当控制器启用时，还有以下五个统计数据：</p><ul><li>nr_periods：调度周期的总数</li><li>nr_throttled：进程被限制(throttled)的次数</li><li>throttled_usec：进程被限制的总时间</li><li>nr_bursts：发生的burst事件的次数。burst事件是指在短时间内CPU使用率突然增加的情况</li><li>burst_usec：burst事件的总时间</li></ul><p><strong>cpu.weight：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为100</p><p>对于非空闲组(cpu.idle = 0)，权重在范围内[1, 10000]</p><p>如果cgroup已配置为SCHED_IDLE(cpu.idle = 1)，则权重将显示为0</p><p><strong>cpu.weight.nice：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为0</p><p>nice值的范围是[-20, 19]</p><p>此接口文件是cpu.weight的替代接口，允许使用nice(2)使用的相同值读取和设置权重。由于nice值的范围较小，粒度较粗，因此读取的值是当前权重的最接近近似值</p><p>nice(2)是一个系统调用，用于设置进程的优先级，优先级决定了进程在系统资源（特别是CPU时间）分配中的优先顺序。nice值的范围通常是从-20到19，值越小表示越高优先级</p><p><strong>cpu.max：</strong></p><p>存在于非root cgroup上的读写双值文件。默认值为" max 100000"</p><p>最大带宽限制。其格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$MAX</span> <span class="hljs-variable">$PERIOD</span><br></code></pre></td></tr></table></figure><p>表示该组在每个$PERIOD期间最多可以消费$MAX。$MAX中的max表示没有限制，如果只写一个数字，则更新$MAX</p><p><strong>cpu.max.burst：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为0</p><p>burst范围在[0, $MAX]内</p><p><strong>cpu.pressure：</strong></p><p>读写嵌套键文件</p><p>显示CPU的压力失速信息。有关详细信息，请参阅：https://www.kernel.org/doc/html/latest/accounting/psi.html#psi</p><p><strong>cpu.uclamp.min：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为0，即不提高利用率</p><p>所请求的最低利用率（保护）以百分比的有理数表示，例如12,34表示12.34%</p><p>此接口允许读取和设置类似于sched_setattr(2)的最小利用率限制值。此最小利用率值用于限制特定任务的最小利用率限制</p><p>请求的最小利用率(保护)始终受最大利用率(限制)的当前值限制，即cpu.uclamp.max</p><p><strong>cpu.uclamp.max：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为max</p><p>请求的最大利用率（限制）以百分比有理数表示，例如98.76表示98.76%</p><p>此接口允许读取和设置类似于sched_setatrt(2)的最大利用率限制值，此最大利用率值用于限制特定任务的最大利用率限制</p><p><strong>cpu.idle：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为0</p><p>这是cgroup中每个任务的SCHD_IDLE调度策略的模拟。将此值设置为1将使cgroup的调度策略成为SCHED_IDLE。cgroup中的线程将保留其自己的相对优先级，但cgroup本身将被视为相对于其他同类而言优先级非常低</p><h4 id="memory">memory</h4><p>memory控制器调节内存的分配。内存是有效状态的，并实现限制和保护模型。由于内存使用和回收压力相互交织，以及内存的状态特性，分配模型相对复杂</p><p>虽然并非完全无懈可击，但特定cgroup的所有主要内存使用情况都会得到跟踪，以便可以合理地计算和控制总内存消耗。目前，会跟踪以下类型的内存使用情况：</p><ul><li>Userland memory：页面缓存和匿名内存</li><li>Kernel data structures：dentry和inode</li><li>TCP套接字缓存区</li></ul><p>为了覆盖范围更广，上述列表将来可能会扩大</p><p>所有内存量均以字节为单位。如果写入的值为与PAGE_SIZE对齐，则读回该值可能会向上舍入为最接近的PAGE_SIZE倍数</p><p><strong>memory.current：</strong></p><p>存在于非root cgroup上的只读单值文件</p><p>该cgroup及其后代当前正在使用的内存总量</p><p><strong>memory.min：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为0</p><p>硬内存保护。如果cgroup的内存使用量在其有效最小边界内，则在任何情况下都不会回收该cgroup的内存。如果没有可用的不受保护的可回收内存，则会调用OOM终止程序。如果超过出有效最小边界(或有效低边界，如果有效低边界更高)，则会按超额比例回收页面，从而减少超额较小的回收压力</p><p>有效最小边界受到所有祖先cgroup的memory.min值限制。如果存在memory,min过量使用（子cgroup或cgroup需要的受保护内存多于父cgroup允许的内存），则每个子cgroup将获得父cgroup的保护部分，该部分保护与其实际内存使用量低于memory.min的比例成正比</p><p>不鼓励在此保护下放置超过通常可用的内存，并且可能会导致持续的OOM</p><p>如果memory cgroup中没有进程， 则会忽略其memory.min</p><p><strong>memory.low：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为"0"</p><p>尽力保护内存，如果cgroup的内存使用量在其有效低边界内，则除非未受保护的cgroup中没有可回收内存，否则不会回收该cgroup的内存。如果超出有效低边界（或有效最小边界，如果有效最小边界更高），则会根据超额部分按比例回收页面，从而减少超额部分的回收压力</p><p>有效低边界受所有祖先cgroup的memory.low值限制。如果存在memory.low过度使用（字cgroup或cgorup需要的受保护内存多于父cgroup允许的内存），则每个子cgroup将获得与其实际内存使用量（低于memory.low）成比例的父cgroup保护部分</p><p>不鼓励在此保护下放置超过通常可用的内存</p><p><strong>memory.high：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为max</p><p>内存使用限制，如果cgroup的使用量超出上限，则cgroup的进程将受到限制，并承受巨大的回收压力</p><p>超过上限不会调用OOM终止程序，在极端情况下可能会突破限制。在外部进程监控受限cgroup以缓解沉重的回收压力的情况下，应使用上限</p><p><strong>memory.max：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为max</p><p>内存使用硬限制。这是限制cgroup内存使用的主要机制。如果cgroup的内存使用量达到此限制且无法降低，则会在cgroup中调用OOMkiller。在某些情况下， 使用量可能会暂时超过限制</p><p>在默认配置下，常规0阶分配总是会成功。调用者可以以不同的方式重试它们，以-ENOMEM的形式返回到用户空间，或者在磁盘预读等情况下默默忽略</p><p><strong>memory.reclaim：</strong></p><p>所有cgroup都存在的只写嵌套键文件</p><p>这是一个在目标cgroup中触发内存回收的简单接口</p><p>此文件接受单个键，即要回收的字节数，目前不支持嵌套键</p><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1G&quot;</span> &gt; memory.reclaim<br></code></pre></td></tr></table></figure><p>稍后可以使用嵌套键扩展接口以配置回收行为。例如，指定要回收的内存类型（匿名、文件等）</p><p>注意：内核可能会从目标cgroup中过度或不足地回收。如果回收的字节数少于指定的数量，则返回-EAGAIN</p><p>注意：主动回收（由此接口触发）并不意味着指示内存cgroup上的内存压力。因此，在这种i情况下，通常不会执行由内存回收触发的套接字内存平衡。这意味着网络层不会根据由memory.reclaim引起的回收进行调整</p><p><strong>memory.peak：</strong></p><p>存在于非root cgroup上的只读单值文件</p><p>自cgroup创建以来，记录的cgroup及其后代的最大内存使用量</p><p><strong>memory.oom.group：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为0</p><p>确定OOM终止程序是否应将cgroup视为不可分割的工作负载。如果设置，则属于该cgroup或其后代（如果内存cgroup不是叶cgroup）的所有任务都会一起终止或根本不终止。这可用于避免部分终止以保证工作负载的完整性</p><p>具有OOM保护（oom_score_adj设置为-1000）的任务被视为异常，并且永远不会被终止</p><p>如果在cgroup中调用OOM终止程序，它将不会终止该cgroup之外的任何任务，无论祖先cgroup的memory.oom,group值如何</p><p><strong>memory.events：</strong></p><p>存在于非rootcgroup上的只读平键文件。定义了以下条目。除非另有说明，否则此文件中的值更改会生成文件修改事件。</p><p>注意：此文件中的所有字段都是分层的，文件修改事件可能由于层次结构下方的事件而生成。有关cgroup级别的本地事件，请参阅memory.events.local</p><ul><li>low：尽管cgroup的使用率低于低限，但由于内存压力过大而被回收的次数。这通常表示低限已过度使用</li><li>high：由于超出高内存边界，cgroup的进程被限制并路由以执行直接内存回收的次数。对于内存使用量受高限（而非全局内存压力）限制的cgroup，此事件的发生是意料之中的</li><li>max：cgroup的内存使用量即将超过最大边界的次数。如果直接回收无法降低内存使用量，则cgroup会进入oom状态</li><li>oom：cgroup内存使用量达到限制且分配即将失败的次数。如果不将oomkiller视为一个选项（例如高阶分配失败或要求调用者不要重试），则不会引发此事件。</li><li>oom_kill：属于此cgroup的被任何类型的OOM终止程序终止的进程数（记录的是==尝试杀死==的进程数量，而不是实际被杀死的进程数量）</li><li>oom_group_kill：发生组oom的次数</li></ul><p><strong>memory.events.local：</strong></p><p>与memory.events类似，但文件中的字段是cgroup本地的，即不是分层的。在此文件上生成的文件修改仅反映本地事件</p><p><strong>memory.stat：</strong></p><p>存在于非root cgroup上的只读平键文件</p><p>这将cgroup的内存占用分解为不同类型的内存、特定于类型的详细信息以及有关内存管理系统的状态和过去事件的其他信息</p><p>所有内存量均以字节为单位</p><p>条目按顺序排列，便于阅读，新条目可以显示在中间。不要依赖保持在固定位置的项目，使用键来查找特定值</p><p>如果条目没有每个节点的计数器（或者没有显示在memory.numa_stat中）。使用npn(non-per-node)作为标记，表示它不会显示在memory.numa_stat中</p><ul><li>anon：匿名映射（如brk()、sbrk()和mmap(MAP_ANONYMOUS)）中使用的内存量</li><li>file：用于缓存文件系统数据的内存量，包括tmpfs和共享内存</li><li>kernel(npn)：内核总内存总量，包括(kernel_stack、pagatables、percpu、vmalloc、slab)以及其他内核内存用例</li><li>kernerl_stack：分配给内核栈的内存量</li><li>pagetables：为页表分配的内存量</li><li>sec_pagetables：为辅助页表分配的内存量，目前包括x86和arm64的KVM页表分配以及IOMMU页表</li><li>percpu(npn)：用于存储每个cpu内核数据结构的内存量</li><li>sock(npn)：网络传播缓冲区使用的内存量</li><li>vmalloc(npn)：用于vmap支持内存的内存量</li><li>shmem：由交换支持的缓存文件系统数据量，例如tmpfs、shm段、共享匿名mmap()</li><li>zswap：zswap压缩后端消耗的内存量</li><li>zswapped：换出zswap的应用程序内存量</li><li>file_mapped：使用mmap()映射的缓存文件系统数据量</li><li>file_dirty：已修改但尚未写回磁盘的缓存文件系统数据量</li><li>file_writeback：已修改且当前正在写回磁盘的缓存文件系统数据量</li><li>swapcached：内存中缓存的交换空间量，交换缓存会考虑内存和交换空间的使用情况</li><li>anon_thp：透明hugepage支持的匿名映射中的内存量</li><li>file_thp：透明hugepage支持的缓存文件系统数据量</li><li>shmem_thp：透明hugepage支持吃的shm、tmpgs和共享匿名mmap()的数量</li><li>inactive_anon，active_anon，inactive_file，active_file，unevictable：页面回收算法使用的内部内存管理列表上的内存量（交换支持和文件系统支持）。由于这些代表内部列表状态（例如，shmem页面位于匿名内存管理列表上），inactive_foo+active_foo可能不等于foo计数器的值，因为foo计数器是基于类型的，不是基于列表的</li><li>slab_reclaimable：可能被回收的slab的一部分，例如dentry和inode</li><li>slab_unreclaimable：由于内存压力，部分slab无法被回收</li><li>slab(npn)：用于存储内核数据结构的内存量</li><li>workingset_refault_anon：先前驱动的匿名页面的错误数</li><li>workingset_refault_file：先前逐出的文件页面的错误数</li><li>workingset_activate_anon：立即激活的匿名页面的数量</li><li>workingset_activate_file：立即激活的默认文件页面数</li><li>workingset_restore_anon：在回收之前被检测为活动工作集的已恢复匿名页面的数量</li><li>workingset_restore_file：在回收之前被检测为活动工作集的已还原文件页面的数量</li><li>wokingset_noderecalim：影子节点被回收的次数</li><li>pgscan(npn)：扫描页面的数量（在非活动LRU列表中）</li><li>pgsteal(npn)：回收页面数量</li><li>pgscan_kswapd(npn)：按kswapd扫描的页面数量（在非活动LRU列表中）</li><li>pgscan_direct(npn)：直接扫描的页面数量（在非活动LRU列表中）</li><li>pgscan_khugepaged(npn)：按khugepage扫描的页面数量（在非活动LRU列表中）</li><li>pgsteal_kswapd(npn)：按kswapd计算的回收页面数量</li><li>pgsteal_direct(npn)：直接回收的页面数量</li><li>pgsteal_khugepaged(npn)：按khugepage计算的回收页面数量</li><li>pgfault(npn)：发生的页面错误总数</li><li>pgmajfault(npn)：发生的主要页面错误的数量</li><li>pgrefill(npn)：扫描页面的数量（在非活动LRU列表中）</li><li>pgactivate(npn)：移动到活动LRU列表的页面数量</li><li>pgdeactivate(npn)：移动到非活动LRU列表的页面数量</li><li>pglazyfree(npn)：在内存压力下延迟释放的页面数量</li><li>pglazyfreed(npn)：回收无惰性页面的数量</li><li>zswpin：从zswap移动到内存中的页面数</li><li>zswpout：从内存移动到zswap的页面数</li><li>zswpwb：从zswap写入到swap的页面数</li><li>thp_fault_alloc(npn)：为满足页面错误而分配的透明hugepage数。当CONFIG_TRANSPARENT_HUGEPAGE未设置时，此计数器不存在</li><li>thp_collapse_alloc(npn)：为允许折叠现有页面范围而分配的透明hugepage数。当CONFIG_TRANSPARENT_HUGEPAGE未设置时，此计数器不存在</li><li>thp_swpout (npn)：透明hugepage的数量，在一块交换而不分裂</li><li>thp_swpout_fallback(npn)：在交换之前被分割的透明hugepage的数量。通常是一因为没有巨大的页面分配一些连续的交换空间</li></ul><p><strong>memory.numa_stat：</strong></p><p>存在于非root cgroup上的只读嵌套键文件</p><p>这会将cgroup的内存占用分解未不同类型的内存、特定于类型的详细信息以及有关内存管理系统状态的每个节点的其他信息</p><p>这对于提供memcg中的NUMA位置信息的可见性非常有用，因为允许从任何物理节点分配页面。其中一个用例是通过将这些信息与应用程序的CPU分配相结合来评估应用程序性能</p><p>所有内存量均以字节为单位</p><p>memory.numa_stat的输出格式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">type N0=&lt;bytes in node 0&gt; N1=&lt;bytes in node 1&gt; ...<br></code></pre></td></tr></table></figure><p><strong>memory.swap.current：</strong></p><p>存在于非root cgroup上的只读单值文件</p><p>该cgroup及其后代当前正在使用的交换总量</p><p><strong>memory.swap.high：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为max</p><p>交换使用限制，如果cgroup的交换使用量超出此限制。则其所有进一步的分配都将受到限制，以允许用户空间实施自定义的内存不足程序</p><p>此限制标志着cgroup的不可逆转点。它并非设置用于管理工作负载在正常运行期间进行的交换量。与memory.swap.max相比，后者进制交换量超过设定值，但只要其他内存可以回收，cgroup就可以不受阻碍地继续运行</p><p><strong>memory.swap.peak：</strong></p><p>存在于非root cgroup上的只读单值文件</p><p>自cgroup创建以来，记录的cgroup及其后代的最大交换使用情况</p><p><strong>memory.swap.max：</strong></p><p>存在于非root cgroup上的读写单值文件，默认值为max</p><p>交换使用硬限制。如果cgroup的交换使用量达到此限制，则不会将cgroup的匿名内存换出</p><p><strong>memory.swap.events：</strong></p><p>存在于非rootcgroup上的只读平键文件。定义了以下条目。除非另有说明，否则此文件中的值更改会生成文件修改事件</p><ul><li>high：cgroup的交换使用量超出高阈值的次数</li><li>max：cgroup的交换使用量即将超出最大边界且交换分配失败的次数</li><li>fail：由于系统范围内的交换空间用尽或最大限制而导致交换分配失败的次数</li></ul><p>当在当前使用率下减少时，现有的交换条目将逐渐被回收，并且交换使用率可能在较长时间内保持高于限制，着减少了对工作负载和内存管理的影响</p><p><strong>memory.zswap.current：</strong></p><p>存在于非root cgroup上只读单值文件</p><p>zswap压缩后端消耗的内存总量</p><p><strong>memory.zswap.max：</strong></p><p>存在于非root cgroup上的读写单值文件。默认值为max</p><p>zswap使用硬限制。如果cgroup的zswap池达到此限制，它将拒绝在现有条目故障恢复或写入磁盘之前接受任何存储</p><p><strong>memory.zswap.writeback：</strong></p><p>可读写的单值文件。默认值为1。rootcgroup的初始值为1，当创建新的cgroup时，它会继承其父级的当前值。</p><p>当设置为0时，所有交换设备的尝试都被禁用。这包括zswap写回和由于zswap存储失败而进行的交换。如果zswap存储失败重复曾发生（例如，如果页面不可压缩），用户可以在禁用写回后观察到回收效率低下（因为相同的页面可能会一次又一次被拒绝）</p><p>注意：这与设置memory.swap.max为0有细微的差别，因为它仍然允许页面写入zswap池</p><p><strong>memory.pressure：</strong></p><p>只读的嵌套键文件</p><p>显示内存的压力失速信息。详情看：https://www.kernel.org/doc/html/latest/accounting/psi.html#psi</p><p><strong>使用指南：</strong></p><p>memory.high是控制内存使用的主要机制。在上限上过度承诺（上限总和 &gt;可用内存）并让全局内存压力根据使用情况分配内存是一种可行的策略</p><p>由于违反高限制不会触发OOMkiller但会限制有问题的cgroup，因此管理代理有充足的机会监控并采取适当的措施，例如授予更多的内存或终止工作负载</p><p>确定cgroup是否有足够的内存并非易事，因为内存使用情况并不能表明工作负载是否可以从更多内存中受益。例如，将从网络接收的数据写入文件的工作负载可以使用所有可用内存，但也可以使用少量内存运行。内存压力的衡量标准（由于内存不足、工作负载受到的影响有多大）对于确定工作负载是否需要更多内存是必要的；不幸的是，内存压力监控机制尚未实现</p><p><strong>内存所有权：</strong></p><p>内存区域由实例化它的 cgroup 占用，并保持由该 cgroup占用的状态，直到该区域被释放。将进程迁移到其他 cgroup 不会将其在前一个cgroup 中实例化的内存使用量移动到新 cgroup。</p><p>一个内存区域可能被属于不同 cgroup 的进程使用。该区域将归属于哪个cgroup尚不确定；但是，随着时间的推移，该内存区域很可能会归属于具有足够内存余量的cgroup，以避免高回收压力。</p><p>如果一个 cgroup 清除了大量的内存，而这些内存预计会被其他 cgroup重复访问，那么使用 POSIX_FADV_DONTNEED放弃受影响文件的内存区域的所有权以确保正确的内存所有权可能是有意义的。</p><h4 id="io">IO</h4><p>io控制器控制io资源的分配。此控制器可实现基于权重和绝对带宽或IOPS限制的分配；但是，只有使用cfq-iosched时才可以使用基于权重的分配，并且这两种方案都不适用于blk-mq设备</p><p><strong>io.stat：</strong></p><p>只读的嵌套键文件</p><p>行由$MAJ:$MIN设备编号键控，且无序。定义了以下嵌套键：</p><table><thead><tr><th>rbytes</th><th>读取的字节数</th></tr></thead><tbody><tr><td>wbytes</td><td>写入的字节数</td></tr><tr><td>rios</td><td>读取IO数量</td></tr><tr><td>wios</td><td>写IO次数</td></tr><tr><td>dbytes</td><td>丢弃的字节数</td></tr><tr><td>dios</td><td>丢弃IO数</td></tr></tbody></table><p><strong>io.cost.qos：</strong></p><p>仅存在于root cgroup上的读写嵌套键文件</p><p>此文件配置基于IO成本模型的控制器(CONFIG_BLK_CGROUP_IOCOST)的服务质量，该控制器当前实施"io.weight"比例控制。行由$MAX:$MIN设备编号键控，且无序。给定设备的行在io.cost.qos或io.cost.model上首次写入设备时填充。定义了以下嵌套键：</p><table><thead><tr><th>enable</th><th>是否开启blk-iocost控制器</th></tr></thead><tbody><tr><td>ctrl</td><td>"auto"或"user"</td></tr><tr><td>rpct</td><td>读取延迟百分位数[0, 100]</td></tr><tr><td>rlat</td><td>读取延迟阈值</td></tr><tr><td>wpct</td><td>写入延迟百分位数[0, 100]</td></tr><tr><td>wlat</td><td>写入延迟阈值</td></tr><tr><td>min</td><td>最小速率调整比例[1, 10000]</td></tr><tr><td>max</td><td>最大缩放百=[1, 10000]</td></tr></tbody></table><p>该控制器默认是禁用的，可以通过enable设置为1来启用它。"rcpt"和"wpct"参数默认是0，控制器使用内部设备饱和状态在max和min之间调整整体IO速率</p><p>当需要更好地控制质量时，可以配置延迟QoS参数。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">8:16 enable=1 ctrl=auto rpct=95.00 rlat=75000 wpct=95.00 wlat=150000 min=50.00 max=150.0<br></code></pre></td></tr></table></figure><p>显示在sdb上，控制器已启用，如果读取完成延迟的第95个百分位数高于75毫秒或写入150毫秒，则将认为设备已饱和，并相应地将整体IO发出率调整为50%到150%之间</p><p>饱和点越低，延迟QoS越好，但代价是总带宽。max和min之间允许的调整范围越窄，IO行为越符合成本模型。注意：IO发出基本速率可能远离100%，盲目设置min和max可能会导致设备容量或控制质量的显著损失。min和max对于调节表现出广泛临时行为变化的设备很有用——例如，ssd以线路速度接受写入一段时间，然后完全停止数秒</p><p>当“ctrl”为“auto”时，参数由内核控制，可能会自动更改。将“ctrl”设置为“user”或设置任何百分位数和延迟参数都会将其置于“user”模式并禁用自动更改。可以通过将“ctrl”设置为“auto”来恢复自动模式。</p><p><strong>io.cost.model：</strong></p><p>仅存在于root cgroup 上的读写嵌套键文件。</p><p>此文件配置基于 IO 成本模型的控制器 (CONFIG_BLK_CGROUP_IOCOST)的成本模型，该控制器当前实施“io.weight”比例控制。行由 $MAJ:$MIN设备编号作为键，且无序。给定设备的行在“io.cost.qos”或“io.cost.model”上首次写入设备时填充。定义了以下嵌套键：</p><table><thead><tr><th>ctrl</th><th>“auto” or “user”</th></tr></thead><tbody><tr><td>model</td><td>使用的成本模型 - “linear”</td></tr></tbody></table><p>当“ctrl”为“auto”时，内核可以动态更改所有参数。当“ctrl”设置为“user”或写入任何其他参数时，“ctrl”变为“user”，自动更改将被禁用。</p><p>当“模型”为“线性”时，定义以下模型参数：</p><table><thead><tr><th>[r|w]bps</th><th>最大连续 IO 吞吐量</th></tr></thead><tbody><tr><td>[r|w]seqiops</td><td>每秒最大 4k 顺序 IO</td></tr><tr><td>[r|w]randiops</td><td>每秒最大 4k 随机 IO</td></tr></tbody></table><p>从上文可以看出，内置线性模型确定了顺序和随机 IO 的基本成本以及 IO大小的成本系数。虽然简单，但该模型可以令人满意地覆盖大多数常见设备类别。</p><p>IO 成本模型不一定绝对准确，并且会根据设备行为动态缩放。</p><p>如果需要，可以使用 tools/cgroup/iocost_coef_gen.py来生成特定于设备的系数。</p><p><strong>io.weight：</strong></p><p>存在于非 root cgroup 上的读写平键文件。默认值为“default 100”。</p><p>第一行是应用于设备的默认权重，没有特定的覆盖。其余的覆盖由 $MAJ:$MIN设备编号键入且无序。权重在 [1, 10000] 范围内，指定 cgroup相对于其同级可以使用的相对 IO 时间量。</p><p>可以通过写入“default$WEIGHT”或简单的“​$WEIGHT”来更新默认权重。可以通过写入“$MAJ:$MIN​$WEIGHT”来设置覆盖，并通过写入“​$MAJ:$MIN default”来取消设置。</p><p>注意：需要先在rootcgroup启用特定设备的io.cost.qos，才能将设备填充到io.weight，例如：</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ehco <span class="hljs-string">&quot;8:0 enabled=1 ctrl=auto&quot;</span> &gt; io.cost.qos<br></code></pre></td></tr></table></figure></p><p><strong>io.max：</strong></p><p>存在于非 root cgroup 上的读写嵌套键文件。</p><p>基于 BPS 和 IOPS 的 IO 限制。行由 $MAJ:$MIN设备编号键控且无序。定义了以下嵌套键:</p><table><thead><tr><th>rbps</th><th>每秒最大读取字节数</th></tr></thead><tbody><tr><td>wbps</td><td>每秒最大写入字节数</td></tr><tr><td>riops</td><td>每秒最大读取 IO 操作数</td></tr><tr><td>wiops</td><td>每秒最大写入 IO 操作数</td></tr></tbody></table><p>写入时，可以以任意顺序指定任意数量的嵌套键值对。可以指定“max”作为值来删除特定限制。如果多次指定相同的键，则结果不确定。</p><p>在每个 IO 方向上测量 BPS 和 IOPS，如果达到限制，IO会延迟。允许临时突发。</p><p>将读取限制设置为 2M BPS，并将写入限制设置为 120 IOPS，设备为8:16：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;8:16 rbps=2097152 wiops=120&quot;</span> &gt; io.max<br></code></pre></td></tr></table></figure><p>可以通过写入以下内容来消除写入 IOPS 限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;8:16 wiops=max&quot;</span> &gt; io.max<br></code></pre></td></tr></table></figure><p><strong>io.pressure：</strong></p><p>只读的嵌套键文件。</p><p>显示 IO 的压力失速信息。有关详细信息，请参阅 <ahref="https://www.kernel.org/doc/html/latest/accounting/psi.html#psi">Documentation/accounting/psi.rst</a>。</p><p><strong>写回：</strong></p><p>页面缓存通过缓冲写入和共享 mmap被弄脏，并通过写回机制异步写入到后备文件系统。写回位于内存和 IO域之间，通过平衡弄脏和写入 IO 来调节脏内存的比例。</p><p>io 控制器与内存控制器一起实现对页面缓存写回 IO的控制。内存控制器定义计算和维护脏内存比率的内存域，io控制器定义写出内存域脏页的 io 域。系统范围和每个 cgroup的脏内存状态都会被检查，并强制执行两者中限制性更强的那个。</p><p>cgroup 写回需要底层文件系统的明确支持。目前，cgroup 写回已在ext2、ext4、btrfs、f2fs 和 xfs 上实现。在其他文件系统上，所有写回 IO都归属于根 cgroup。</p><p>内存和写回管理存在固有差异，这会影响跟踪 cgroup所有权的方式。内存按页跟踪，而写回按 inode 跟踪。为了进行写回，将 inode分配给 cgroup，并且从 inode 写入脏页的所有 IO 请求都归属于该cgroup。</p><p>由于内存的 cgroup 所有权是按页跟踪的，因此可能存在与 inode 所关联的cgroup不同的页面。这些页面称为外部页面。写回会不断跟踪外部页面，如果某个外部cgroup 在一段时间内成为多数，则会将 inode 的所有权切换为该 cgroup。</p><p>虽然此模型足以满足大多数用例，即即使主写入 cgroup随时间发生变化，给定的 inode 也主要被单个 cgroup 弄脏，但多个 cgroup同时写入单个 inode 的用例无法得到很好的支持。在这种情况下，很大一部分 IO可能会被错误地归因。由于内存控制器在第一次使用时分配页面所有权，并且在页面释放之前不会更新它，即使写回严格遵循页面所有权，多个cgroup 弄脏重叠区域也不会按预期工作。建议避免这种使用模式。</p><p>影响写回行为的 sysctl 旋钮应用于 cgroup 写回，如下所示：</p><ul><li>vm.dirty_background_ratio，vm.dirty_ratio：这些比率同样适用于 cgroup写回，其中可用内存量受内存控制器和系统范围的干净内存所施加的限制。</li><li>vm.dirty_background_bytes，vm.dirty_bytes：对于 cgroup写回，这是根据总可用内存的比例计算的，并且以与vm.dirty[_background]_ratio相同的方式应用。</li></ul><p><strong>IO延迟：</strong></p><p>这是用于 IO 工作负载保护的 cgroup v2控制器。您为组提供一个延迟目标，如果平均延迟超过该目标，控制器将限制任何延迟目标低于受保护工作负载的对等体。</p><p>这些限制仅适用于层次结构中的同级级别。这意味着在下图中，只有组 A、B和 C 会相互影响，组 D 和 F 会相互影响。组 G 不会影响任何人：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">          [root]<br>  /          |            \<br>  A          B            C<br> /  \        |<br>D    F       G<br></code></pre></td></tr></table></figure><p>因此，配置此设置的理想方法是在 A、B 和 C 组中设置io.latency。通常，您不希望设置低于设备支持的延迟的值。通过实验找到最适合您的工作负载的值。从高于设备预期延迟开始，观察io.stat 中工作负载组的 avg_lat 值，以了解正常运行期间看到的延迟。使用avg_lat 值作为实际设置的基础，设置为比 io.stat 中的值高 10-15%。</p><p><strong>IO延迟节流如何工作：</strong></p><p>io.latency是节省工作量的；因此，只要每个人都达到其延迟目标，控制器就不会做任何事情。一旦某个组开始未达到其目标，它就会开始限制任何目标比其更高的对等组。这种限制有两种形式：</p><ul><li>Queue depth throttling：这是允许一个组拥有的未完成 IO数量。我们将相对较快地进行限制，从无限制开始，一直到每次 1 个 IO。</li><li>Artificial delay induction：某些类型的 IO无法节流，否则可能会对更高优先级的组产生不利影响。这包括交换和元数据IO。这些类型的 IO可以正常发生，但它们会被“收取”到原始组的费用。如果原始组受到节流，您将看到io.stat 中的 use_delay 和 delay字段增加。延迟值是添加到此组中运行的任何进程的微秒数。由于如果发生大量交换或元数据IO，这个数字可能会变得非常大，因此我们将单个延迟事件限制为每次 1秒。</li></ul><p>一旦受害组再次开始满足其延迟目标，它将开始解除之前被限制的任何对等组的限制。如果受害组只是停止执行IO，全局计数器将适当解除限制。</p><p><strong>IO延迟接口文件：</strong></p><ul><li>io.latency：这采用与其他控制器类似的格式。“MAJOR:MINORtarget=&lt;目标时间（微秒）&gt;”</li><li>io.stat：如果启用了控制器，除了正常的统计数据之外，您还将在 io.stat中看到额外的统计数据。<ul><li>depth：这是该组的当前队列深度。</li><li>avg_lat：这是一个指数移动平均数，衰减率为1/exp，受采样间隔限制。衰减率间隔可以通过将 io.stat 中的 win 值乘以基于win 值的相应采样数来计算。</li><li>win：采样窗口大小（以毫秒为单位）。这是评估事件之间的最短持续时间。窗口只会随着IO 活动而流逝。空闲期会延长最近的窗口。</li></ul></li></ul><p><strong>IO优先级：</strong></p><p>单个属性控制 I/O 优先级 cgroup 策略的行为，即 io.prio.class属性。该属性接受以下值：</p><ul><li>no-change：请勿修改 I/O 优先级类。</li><li>promote-to-rt：对于具有非 RT I/O 优先级类的请求，将其更改为RT。同时将这些请求的优先级更改为 4。不要修改优先级类为 RT 的请求的 I/O优先级。</li><li>restrict-to-be：对于没有 I/O 优先级类别或 I/O 优先级类别为 RT的请求，将其更改为 BE。同时将这些请求的优先级更改为0。不要修改优先级类别为 IDLE 的请求的 I/O 优先级类别。</li><li>idle：将所有请求的 I/O 优先级类别更改为最低的 I/O 优先级类别IDLE。</li><li>none-to-rt：已弃用。只是promote-to-rt的别名</li></ul><p>以下数值与 I/O 优先级策略相关：</p><table><thead><tr><th style="text-align: left;">no-change</th><th>0</th></tr></thead><tbody><tr><td style="text-align: left;">promote-to-rt</td><td>1</td></tr><tr><td style="text-align: left;">restrict-to-be</td><td>2</td></tr><tr><td style="text-align: left;">idle</td><td>3</td></tr></tbody></table><p>每个 I/O 优先级对应的数值如下：</p><table><thead><tr><th>IOPRIO_CLASS_NONE</th><th>0</th></tr></thead><tbody><tr><td>IOPRIO_CLASS_RT（实时）</td><td>1</td></tr><tr><td>IOPRIO_CLASS_BE（尽力而为）</td><td>2</td></tr><tr><td>IOPRIO_CLASS_IDLE</td><td>3</td></tr></tbody></table><p>设置请求的 I/O 优先级的算法如下：</p><ul><li>若I/O优先级类别策略为promote-to-rt，则将请求I/O优先级类别更改为IOPRIO_CLASS_RT，并将请求I/O优先级更改为4。</li><li>如果 I/O 优先级类别策略不是promote-to-rt，则将 I/O优先级类别策略转换为数字，然后将请求 I/O 优先级类别更改为 I/O优先级类别策略编号和数值 I/O 优先级类别中的最大值。</li></ul><h4 id="pid">PID</h4><p>进程号控制器用于允许 cgroup 在达到指定的限制后停止对任何新任务进行fork() 或 clone()。</p><p>cgroup中的任务数量可能会以其他控制器无法阻止的方式耗尽，因此需要自己的控制器。例如，fork炸弹很可能在达到内存限制之前耗尽任务数量。</p><p>请注意，此控制器中使用的 PID 指的是内核使用的 TID（进程 ID）。</p><p><strong>pids.max：</strong></p><p>存在于非 root cgroup上的读写单值文件。默认值为“max”。进程数量的硬性限制。</p><p><strong>pids.current：</strong></p><p>存在于非 root cgroup 上的只读单值文件。cgroup及其后代中当前的进程数。</p><p><strong>pids.peak：</strong></p><p>存在于非 root cgroup 上的只读单值文件。该 cgroup及其后代进程数曾达到的最大值。</p><p><strong>pids.events：</strong></p><p>存在于非 root cgroup上的只读平键文件。除非另有说明，否则此文件中的值更改会生成文件修改事件。定义了以下条目：</p><ul><li>max：cgroup 的总进程数达到 pids.max 限制的次数（另请参阅pids_localevents）。</li></ul><p><strong>pids.events.local：</strong></p><p>与 pids.events 类似，但文件中的字段是 cgroup本地的，即不是分层的。在此文件上生成的文件修改事件仅反映本地事件。</p><p>组织操作不受 cgroup 策略的阻止，因此 pids.current &gt; pids.max是可能的。这可以通过将限制设置为小于 pids.current 或将足够多的进程附加到cgroup 以使 pids.current 大于 pids.max 来实现。但是，不可能通过 fork()或 clone() 违反 cgroup PID 策略。如果创建新进程会导致违反 cgroup策略，则这些将返回 -EAGAIN。</p><h4 id="cpuset">cpuset</h4><p>“cpuset”控制器提供了一种机制，用于将任务的 CPU和内存节点放置限制为仅任务当前 cgroup 中的 cpuset接口文件中指定的资源。这在大型 NUMA系统中尤其有用，在这些系统中，将作业放置在适当大小的系统子集上，并仔细放置处理器和内存以减少跨节点内存访问和争用，可以提高整体系统性能。</p><p>“cpuset” 控制器是分层的。这意味着控制器不能使用其父级中不允许的 CPU或内存节点。</p><p><strong>cpuset.cpus：</strong></p><p>存在于非 root cpuset 启用的 cgroup 上的读写多值文件。</p><p>它列出了此 cgroup 内的任务所请求的 CPU。但实际授予的 CPU列表受其父级施加的限制，可能与请求的 CPU 不同。</p><p>CPU 编号是用逗号分隔的数字或范围。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> cpuset.cpus<br>output: 0-4,6,8-10<br></code></pre></td></tr></table></figure><p>空值表示 cgroup 使用与具有非空“cpuset.cpus”的最近的 cgroup祖先相同的设置，如果未找到任何可用 CPU，则使用所有可用的 CPU。</p><p>“cpuset.cpus” 的值保持不变直到下次更新，不会受到任何 CPU热插拔事件的影响。</p><p><strong>cpuset.cpus.effective：</strong></p><p>所有启用 cpuset 的 cgroup 上都存在的只读多值文件。</p><p>它列出了此 cgroup 的父级实际授予其的在线 CPU。这些 CPU 允许由当前cgroup 中的任务使用。</p><p>如果“cpuset.cpus”为空，“cpuset.cpus.effective”文件将显示父 cgroup中可供此 cgroup 使用的所有CPU。否则，它应该是“cpuset.cpus”的子集，除非“cpuset.cpus”中列出的 CPU均无法授予。在这种情况下，它将被视为空的“cpuset.cpus”。</p><p>其值会受到CPU热插拔事件的影响。</p><p><strong>cpuset.mems：</strong></p><p>存在于非 root cpuset 启用的 cgroup 上的读写多值文件。</p><p>它列出了此 cgroup内的任务所请求的内存节点。但实际授予的内存节点列表受其父级施加的限制，可能与请求的内存节点不同。</p><p>内存节点号是用逗号分隔的数字或范围。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> cpuset.mems<br>output: <br>0-1,3<br></code></pre></td></tr></table></figure><p>空值表示 cgroup 使用与最近的 cgroup祖先相同的设置，并且具有非空的“cpuset.mems”或所有可用的内存节点（如果未找到任何内存节点）。</p><p>“cpuset.mems”的值保持不变直到下次更新，不会受到任何内存节点热插拔事件的影响。</p><p>如果“cpuset.mems”当前正在使用指定节点之外的内存，则将 cgroup内的任务的内存迁移到指定节点。</p><p>这种内存迁移是有代价的。迁移可能不完整，可能会遗留一些内存页。因此，建议在将新任务生成到cpuset之前正确设置“cpuset.mems”。即使需要使用活动任务更改“cpuset.mems”，也不应该频繁进行。</p><p><strong>cpuset.mems.effective：</strong></p><p>所有启用 cpuset 的 cgroup 上都存在的只读多值文件。</p><p>它列出了此 cgroup的父级实际授予其的在线内存节点。这些内存节点允许由当前 cgroup内的任务使用。</p><p>如果“cpuset.mems”为空，则显示父 cgroup 中可供此 cgroup使用的所有内存节点。否则，它应该是“cpuset.mems”的子集，除非“cpuset.mems”中列出的任何内存节点都无法授予。在这种情况下，它将被视为空的“cpuset.mems”。</p><p>其值会受到内存节点热插拔事件的影响。</p><p><strong>cpuset.cpus.exclusive：</strong></p><p>存在于非 root cpuset 启用的 cgroup 上的读写多值文件。</p><p>它列出了允许用于创建新 cpuset 分区的所有独占 CPU。除非 cgroup成为有效的分区根，否则不会使用它的值。有关 cpuset分区的描述，请参阅下面的“cpuset.cpus.partition”部分。</p><p>当 cgroup 成为分区根时，分配给该分区的实际独占 CPU列在“cpuset.cpus.exclusive.effective”中，它可能与“cpuset.cpus.exclusive”不同。如果之前已设置“cpuset.cpus.exclusive”，则“cpuset.cpus.exclusive.effective”始终是其子集。</p><p>用户可以手动将其设置为不同于“cpuset.cpus”的值。设置时的一个限制是，CPU列表必须相对于其同级 cgroup的“cpuset.cpus.exclusive”具有排他性。如果未设置同级 cgroup的“cpuset.cpus.exclusive”，则其“cpuset.cpus”值（如果已设置）不能是其子集，以便在独占CPU 被拿走时至少留有一个 CPU 可用。</p><p>对于父 cgroup，其任何一个独占 CPU 只能分配给最多一个子cgroup。不允许两个或多个子 cgroup 中出现独占CPU（独占性规则）。违反独占性规则的值将被拒绝并出现写入错误。</p><p>根 cgroup 是分区根，其所有可用 CPU 都位于其独有的 CPU 集中。</p><p><strong>cpuset.cpus.exclusive.effective：</strong></p><p>所有启用非 root cpuset 的 cgroup 上都存在的只读多值文件。</p><p>此文件显示可用于创建分区根的有效独占 CPU 集。如果其父级不是根cgroup，则此文件的内容将始终是其父级的“cpuset.cpus.exclusive.effective”的子集。如果已设置，它也将是“cpuset.cpus.exclusive”的子集。如果未设置“cpuset.cpus.exclusive”，则在形成本地分区时，它将被视为具有“cpuset.cpus”的隐式值。</p><p><strong>cpuset.cpus.isolated：</strong></p><p>一个只读且仅有 root cgroup 的多个值文件。</p><p>该文件显示现有隔离分区中使用的所有隔离 CPU的集合。如果未创建隔离分区，则该文件为空。</p><p><strong>cpuset.cpus.partition：</strong></p><p>文档说明：</p><p>存在于启用非 root cpuset 的 cgroup 上的读写单值文件。此标志归父cgroup 所有，不可委托。</p><p>写入时它仅接受以下输入值：</p><table><thead><tr><th>member</th><th>分区的非根成员</th></tr></thead><tbody><tr><td>root</td><td>分区根</td></tr><tr><td>isolated</td><td>无负载平衡的分区根</td></tr></tbody></table><p>cpuset 分区是启用了 cpuset 的 cgroup的集合，其中分区根位于层次结构的顶部，其后代（除了那些本身就是独立分区根的cgroup 及其后代）位于层次结构的顶部。分区对分配给它的一组独占 CPU具有独占访问权限。该分区之外的其他 cgroup 不能使用该组中的任何 CPU。</p><p>有两种类型的分区 - 本地分区和远程分区。本地分区的父 cgroup也是有效的分区根。远程分区的父 cgroup本身不是有效的分区根。对于创建本地分区，写入“cpuset.cpus.exclusive”是可选的，因为其“cpuset.cpus.exclusive”文件将假定一个隐式值，如果未设置，则该值与“cpuset.cpus”相同。对于创建远程分区，必须在目标分区根之前将正确的“cpuset.cpus.exclusive”值写入cgroup 层次结构。</p><p>目前不支持在本地分区下创建远程分区，远程分区根的所有祖先（根 cgroup除外）均不能成为分区根。</p><p>根 cgroup 始终是分区根，其状态无法更改。所有其他非根 cgroup都以“成员”身份开始。</p><p>当设置为“root”时，当前 cgroup 是新分区或调度域的根。独占 CPU集由其“cpuset.cpus.exclusive.effective”的值决定。</p><p>当设置为“isolated”时，该分区中的 CPU将处于隔离状态，不会从调度程序进行任何负载平衡，也不会被排除在未绑定的工作队列之外。放置在具有多个CPU 的此类分区中的任务应谨慎分配并绑定到每个单独的CPU，以实现最佳性能。</p><p>分区根（“根”或“隔离”）可能处于两种状态之一 -有效或无效。无效分区根处于降级状态，其中可能保留一些状态信息，但行为更像“成员”。</p><p>允许“成员”、“根”和“隔离”之间的所有可能的状态转换。</p><p>读取时，“cpuset.cpus.partition”文件可以显示以下值：</p><table><thead><tr><th>member</th><th>分区的非根成员</th></tr></thead><tbody><tr><td>root</td><td>分区根</td></tr><tr><td>isolated</td><td>无负载平衡的分区根</td></tr><tr><td>root invalid (<reason>)</td><td>分区根目录无效</td></tr><tr><td>isolated invalid (<reason>)</td><td>隔离分区根无效</td></tr></tbody></table><p>如果分区根无效，则会在括号内包含有关分区无效原因的描述性字符串。</p><p>为了使本地分区根有效，必须满足以下条件。</p><ol type="1"><li>父 cgroup 是有效的分区根。</li><li>“cpuset.cpus.exclusive.effective”文件不能为空，尽管它可能包含离线CPU。</li><li>除非没有与此分区关联的任务，“cpuset.cpus.effective”不能为空。</li></ol><p>为了使远程分区根有效，必须满足除第一个条件之外的所有上述条件。</p><p>热插拔等外部事件或“cpuset.cpus”或“cpuset.cpus.exclusive”的更改可能会导致有效分区根变为无效，反之亦然。请注意，无法将任务移动到“cpuset.cpus.effective”为空的cgroup。</p><p>有效的非根父分区可以在没有关联任务的情况下将其所有 CPU分配给其子本地分区。</p><p>将有效分区根更改为“成员”时必须小心谨慎，因为其所有子本地分区（如果存在）都将变为无效，从而导致在这些子分区中运行的任务中断。如果将其父分区切换回具有“cpuset.cpus”或“cpuset.cpus.exclusive”中正确值的分区根，则可以恢复这些停用的分区。</p><p>每当“cpuset.cpus.partition”的状态发生变化时，就会触发 poll 和 inotify事件。这包括写入“cpuset.cpus.partition”、CPU热插拔或修改分区有效性状态的其他更改所导致的更改。这将允许用户空间代理监视“cpuset.cpus.partition”的意外更改，而无需进行连续轮询。</p><p>用户可以使用“isolcpus”内核启动命令行选项，在启动时将某些 CPU预先配置为隔离状态，并禁用负载平衡。如果要将这些 CPU放入分区，则必须在隔离分区中使用它们。</p><p>具体解释：</p><p>这个文件可以被设置为root或member，主要功能是用来设置当前的cgroup是不是作为一个独立的schedulingdomain进行调度。这个功能其实就是可以理解为，在root模式下，所有分配给当前cgroup的cpu都是独占这些cpu的，而member模式则可以在多个cgroup之间共享这些cpu。设置为root将使当前cgroup使用的cpu从上级cgroup的cpuset.cpus.effective列表中拿走。（即上一级不能使用这个被独占的CPU了）。设置为root后，如果这个cgroup有下一级的cgroup，这个cgroup也将不能再切换回member状态。在这种模式下，上一级的cgroup不可以把自己所有的cpu都分配给其下一级的cgroup，其自身至少给自己留一个cpu</p><p>设置为root需要当前cgroup符合以下条件：</p><ul><li>cpuset.cpus中设置不为空且设置的cpulist中的cpu都是独立的。就是说这些cpu不会共享给其他平级cgroup</li><li>上一级cgroup是partion root配置</li><li>当前cgroup的cpuset.cpus作为集合是上一级cgroup的cpuset.cpus.effective集合的子集</li><li>下一级cgroup没有启用cpuset资源隔离</li></ul><h4 id="device">device</h4><p>设备控制器管理对设备文件的访问。它包括创建新设备文件（使用mknod）以及访问现有设备文件。</p><p>Cgroup v2 设备控制器没有接口文件，是在 cgroup BPF之上实现的。为了控制对设备文件的访问，用户可以创建BPF_PROG_TYPE_CGROUP_DEVICE 类型的 bpf 程序，并使用 BPF_CGROUP_DEVICE标志将它们附加到 cgroup。在尝试访问设备文件时，将执行相应的 BPF程序，并且根据返回值，尝试将成功或失败并显示 -EPERM。</p><p>BPF_PROG_TYPE_CGROUP_DEVICE 程序接受指向 bpf_cgroup_dev_ctx结构的指针，该结构描述了设备访问尝试：访问类型（mknod/read/write）和设备（类型、主编号和次编号）。如果程序返回0，则尝试失败并出现 -EPERM，否则尝试成功。</p><p>可以在内核源代码树中的 tools/testing/selftests/bpf/progs/dev_cgroup.c中找到 BPF_PROG_TYPE_CGROUP_DEVICE 程序的示例。</p><p>“rdma”控制器调节RDMA资源的分配和核算。</p><p><strong>rdma.max</strong></p><p>除 root 之外的所有 cgroup 中都存在的读写嵌套键文件，用于描述 RDMA/IB设备当前配置的资源限制。</p><p>行按设备名称键入且无序。每行包含空格分隔的资源名称及其可分配的配置限制。</p><p>定义了以下嵌套键：</p><table><thead><tr><th>hca_handle</th><th>最大 HCA 句柄数</th></tr></thead><tbody><tr><td>hca_object</td><td>HCA 对象的最大数量</td></tr></tbody></table><p>以下是 mlx4 和 ocrdma 设备的示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">mlx4_0 hca_handle=2 hca_object=2000<br>ocrdma1 hca_handle=3 hca_object=max<br></code></pre></td></tr></table></figure><p><strong>rdma.current：</strong></p><p>描述当前资源使用情况的只读文件。除 root 外，所有 cgroup均有此文件。</p><p>以下是 mlx4 和 ocrdma 设备的示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">mlx4_0 hca_handle=1 hca_object=20<br>ocrdma1 hca_handle=1 hca_object=23<br></code></pre></td></tr></table></figure><h4 id="hugetlb">hugetlb</h4><p>HugeTLB 控制器允许限制每个控制组的 HugeTLB使用情况，并在页面错误期间强制执行控制器限制。</p><p><strong>hugetlb.2MB.max: </strong></p><p>读写文件。设置hugepage大小为2MB的hugepage使用量限制</p><p><strong>hugetlb.1GB.max: </strong></p><p>读写文件。设置hugepage大小为1GB的hugepage使用量限制</p><p><strong>hugetlb.2MB.current: </strong></p><p>只读文件。显示hugepages大小为2MB的hugepage的当前使用量</p><p><strong>hugetlb.1GB.current: </strong></p><p>只读文件。显示hugepages大小为1GB的hugepage的当前使用量</p><p><strong>hugetlb.2MB.rsvd.max: </strong></p><p>读写文件。设置hugepage大小为2MB的hugepage预留限制</p><p><strong>hugetlb.1GB.rsvd.max: </strong></p><p>读写文件。设置hugepage大小为1GB的hugepage预留限制</p><p><strong>hugetlb.2MB.rsvd.current: </strong></p><p>只读文件。显示hugepages大小为2MB的hugepage的当前预留量</p><p><strong>hugetlb.1GB.rsvd.current: </strong></p><p>只读文件。显示hugepages大小为1GB的hugepage的当前预留量</p><p><strong>hugetlb..2MB.events: </strong></p><p>存在于非 root cgroup 上的只读平键文件，包含以下字段：</p><ul><li>max：由于 HugeTLB 限制导致分配失败的次数</li></ul><p><strong>hugetlb.1GB.events: </strong></p><p>存在于非 root cgroup 上的只读平键文件，包含以下字段：</p><ul><li>max：由于 HugeTLB 限制导致分配失败的次数</li></ul><p><strong>hugetlb.<巨大页面大小>.events.local：</strong></p><p>与 hugetlb.&lt;hugepagesize&gt;.events 类似，但文件中的字段是 cgroup本地的，即不是分层的。在此文件上生成的文件修改事件仅反映本地事件。</p><p><strong>hugetlb.<巨大页面大小>.numa_stat：</strong></p><p>与memory.numa_stat类似，它显示此cgroup中&lt;hugepagesize&gt;的hugetlb页面的numa信息。仅包含正在使用的hugetlb页面。每个节点的值以字节为单位。</p><h4 id="misc">MISC</h4><p>杂项 cgroup 为无法像其他 cgroup资源一样抽象的标量资源提供资源限制和跟踪机制。控制器由CONFIG_CGROUP_MISC 配置选项启用。</p><p>可以通过 include/linux/misc_cgroup.h 文件中的 enum misc_res_type{}将资源添加到控制器，并通过 kernel/cgroup/misc.c 文件中的 misc_res_name[]将相应名称添加到控制器。资源提供者必须在使用资源之前通过调用misc_cg_set_capacity() 设置其容量。</p><p>一旦设置了容量，就可以使用charge和uncharge API 来更新资源使用情况。与misc 控制器交互的所有 API 都位于 include/linux/misc_cgroup.h 中。</p><p><strong>misc.capacity：</strong></p><p>仅在根 cgroup中显示的只读平键文件。它显示平台上可用的各种标量资源及其数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> misc.capacity<br>output:<br>res_a 50<br>res_b 10<br></code></pre></td></tr></table></figure><p><strong>misc.current：</strong></p><p>所有 cgroup 中显示的只读平面键控文件。它显示 cgroup及其子组中资源的当前使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> misc.current<br>output: <br>res_a 3<br>res_b 0<br></code></pre></td></tr></table></figure><p><strong>misc.max：</strong></p><p>所有 cgroup 中显示的只读平面键控文件。它显示 cgroup及其子组中资源的历史最大使用量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> misc.max<br>output: <br>res_a max<br>res_b 4<br></code></pre></td></tr></table></figure><p>可以通过以下方式设置限制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> res_a 1 &gt; misc.max<br></code></pre></td></tr></table></figure><p>可以通过以下方式将限制设置为最大值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> res_a max &gt; misc.max<br></code></pre></td></tr></table></figure><p>可以将限制设置得高于 misc.capacity 文件中的容量值。</p><p><strong>misc.events：</strong></p><p>存在于非 root cgroup上的只读平键文件。定义了以下条目。除非另有说明，否则此文件中的值更改会生成文件修改事件。此文件中的所有字段都是分层的。</p><ul><li>max：cgroup 的资源使用量即将超出最大边界的次数</li></ul><p><strong>misc.events.local：</strong></p><p>与 misc.events 类似，但文件中的字段是 cgroup本地的，即非层次化的。在此文件上生成的文件修改事件仅反映本地事件。</p><p>杂项标量资源将由最先使用该资源的 cgroup 负责，并且会一直由该 cgroup负责，直到该资源被释放。将进程迁移到其他 cgroup不会将资源转移到进程移动的目标 cgroup。</p><h1 id="术语">术语</h1><h2 id="cpu-1">CPU</h2><h3 id="numa架构">NUMA架构</h3><p><strong>概述：</strong>NUMA这是一种内存设计架构，全称是非一致性内存访问(Non-Uniform MemoryAccess)。与传统的一致性访问内存（UMA）不同，在NUMA中，每个处理器都有自己专属的本地内存，也可以访问其他处理器的内存，但是访问本地内存比访问其他处理器的内存快。</p><p><strong>核心概念：</strong></p><ul><li><p>NUMA节点：每个处理器都有直接连接本地内存节点；一个或多个处理器和它们的本地内存节点可以构成一个NUMA节点；NUMA节点间通过高速互通（如QPI、InfinityFabric等）相连 <img src="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241204222738678.png" class=""></p></li><li><p>内存亲和性：处理器对内存访问的倾向性，尽量使用本地内存，以减少访问延迟；处理器访问本地内存和远程内存（其他NUMA节点的内存）的延迟不同，这就是非一致性内存访问架构</p></li></ul><p><strong>优点：</strong></p><ul><li>性能优化：<ul><li>处理器访问本地内存的速度更快</li><li>减少了内存访问的瓶颈，特别是在内存密集型应用中</li></ul></li><li>扩展性：NUMA架构允许系统通过增加更多的NUMA节点来扩展，适合大型多处理器系统。</li></ul><h2 id="内存">内存</h2><h3 id="page-cache">Page Cache</h3><p><strong>概述：</strong> pagecaches是操作系统上用于缓存磁盘数据的内存区域，这样后续访问相同数据时可以直接从内存读取，而不必再次进行磁盘IO，从而提高系统性能。</p><p><strong>工作原理：</strong></p><ul><li>缓存读取操作：从磁盘读取数据时，会缓存到pagecache，如果下次访问相同数据块直接从内存读取。</li><li>延迟写入操作：<ul><li>首先将数据写入page cache，并标记为dirtypage，表示这些page需要同步到磁盘</li><li>OS会在适当的时候将这些dirtypages写回磁盘（比如系统闲置时或者内存压力较大时）</li></ul></li><li>内存管理：<ul><li>内存不足时，OS会释放掉部分page cache（maybe LRU算法）</li><li>在重新被需要时，这些page会被加载到page cache中</li></ul></li></ul><p><strong>如何查看page cache(linux系统)：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">free -h<br></code></pre></td></tr></table></figure><img src="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241204224644047.png" class=""><p><code>buff/cache</code>就是page cache</p><h3 id="slab">Slab</h3><p><strong>概述：</strong>是一种内存管理机制，主要用于在内核中高效地管理小块内存的分配和释放。Slab分配器的设计目标是通过减少内存碎片，加速内存分配和释放的过程，以及缓存对象来提高系统性能。</p><p><strong>核心概念：</strong></p><ul><li>cache：是slab分配器的核心结构，cache中包含了特定类型object的多个slab</li><li>slab：是由多个连续内存页组成的内存块，每个slab包含了多个相同类型object的内存空间；slab的状态可以是full、partial、free</li><li>object：是分配给内核的内存单位，slab分配器的目标是高效地分配和释放这些object<img src="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241204231838014.png" class=""></li></ul><p><strong>工作流程：</strong></p><ol type="1"><li>初始化cache：系统启动时或需要某种类型的object时，内核会初始化一个对应类型的cache</li><li>分配object：当内核需要分配一个object时，slab分配器会从对应类型的cache的partialslab中找到一个空闲的object；如果没有，就去freeslab找；如果还是没有，slab分配器就会给该cache分配一个新的slab</li><li>释放object：当内核释放一个object时，slab分配器会将这个object标记为free，并将其所在的slab的状态更新。</li></ol><p><strong>优点：</strong></p><ul><li>减少内存碎片：slab分配器在分配和释放相同大小对象时，会尽量重用内存，减少了内存碎片</li><li>提高分配效率：slab分配器在分配和释放内存时使用预分配的slab，速度非常快</li><li>对象初始化：object可以在cache中保持初始化状态，使得后续分配更加高效</li></ul><h3 id="swap">swap</h3><p><strong>概述：</strong>swap是一种扩展内存容量的机制。它允许OS将内存中不活跃的页面（内存中的数据块）移动到预先设置的swap空间中，这个空间可以是硬盘上的一个特定分区或一个文件。swap是处理内存不足的一种有用方法，但由于硬盘的访问速度远低于RAM，使用swap会降低系统性能</p><p><strong>特点：</strong></p><ul><li>内存管理：当RAM使用接近上限时，swap可以提供额外的虚拟内存，帮助管理内存压力</li><li>灵活性：可以动态调整swap空间大小</li><li>性能影响：访问速度低于RAM，过度依赖会降低系统性能</li></ul><p><strong>使用场景：</strong></p><ul><li>内存不足时的缓冲</li><li>休眠：在休眠模式下，OS会将当前内存保存到swap空间，然后关闭电源，当OS唤醒时，再从swap空间恢复数据。</li></ul><p><strong>启动或关闭系统上的交换空间：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">swapoff -a <span class="hljs-comment"># 关闭</span><br>swapon -a <span class="hljs-comment"># 开启 一开一关就可以清空缓存</span><br><span class="hljs-built_in">cat</span> /proc/swaps <span class="hljs-comment"># 查看系统是否开启了交换空间</span><br>swapon --show <span class="hljs-comment"># 查看系统是否开启了交换空间</span><br></code></pre></td></tr></table></figure><h2 id="内存回收">内存回收</h2><p><strong>概述：</strong>一个在系统内存变得紧张时释放内存的过程，涉及多个组件和策略。</p><p><strong>页面回收机制：</strong>linux使用分页内存管理，当系统需要更多内存时，页面回收机制会尝试回收未使用或最少使用的页面。</p><ul><li>活跃/非活跃列表：linux将内存页面分为活跃和非活跃两个列表，经常访问的页面被认为是活跃的，而不常访问的页面会被移动到非活跃列表</li><li>页面回收：当内存紧张时，系统首先回收非活跃列表中的页面，这些页面可能被直接回收，或者写回磁盘，然后回收</li></ul><p><strong>OOMKiller：</strong>当linux系统极度缺乏内存，无法通过常规页面回收机制获得足够内存时，OOMKiller会被出发。OOM Killer会选择并终止占用大量内存的进程来释放内存</p><p><strong>cgroup内存限制：</strong>可以为cgroup设置内存限制，当进程组尝试使用超过限制的内存时，它们的一些进程可能会被终止，以保持内存使用在限制之下</p><h2 id="磁盘">磁盘</h2><h3 id="scsi硬盘设备">SCSI硬盘设备</h3><p><strong>概述：</strong> SCSI(Small Computer SystemInterface)是一种用于计算机硬盘和其他设备的接口标准。SCSI接口支持硬盘，扫描仪，打印机等多种类型的外围设备。（通常<code>sda</code>是linux上第一个SCSI硬盘设备）</p><p><strong>特点：</strong></p><ul><li>高性能：高数据传输速率和低CPU占用率</li><li>多设备支持：通过一个SCSI接口可以连接多个设备</li><li>灵活性和可扩展性：SCSI系统支持宽广设备类型和大量设备的连接</li><li>兼容性：支持多种类型和大小的设备</li></ul><h3 id="块设备">块设备</h3><p><strong>常见的块设备：</strong></p><ul><li>sda：是第一个SCSI硬盘设备，在现代linux系统中，SATA和USB存储设备也被视为SCSI设备，因此它们的设备名以sda、sdb等开头</li><li>sr0：这通常代表第一个SCSI光驱设备，比如CD-ROM或DVD-ROM驱动器</li><li>dm-0，dm-1：这些是设备映射设备，常用于LVM（逻辑卷管理）、加密磁盘或提供软件RAID功能</li><li>loop0, loop1,...：这些是循环设备，用于将文件映射为块设备，这在挂载ISO文件，创建虚拟文件系统等场景中非常有用</li><li>nbd0, nbd1,...这些是网络块设备，允许系统通过网络访问块设备，就像它们直接连接到本地系统一样</li></ul><p><strong>sda和vda：</strong></p><ul><li>sda：<ul><li>物理硬盘：sda通常代表系统中的第一个SCSI或SATA硬盘。</li><li>直接访问：sda通常用于直接访问物理硬盘，这意味着操作系统直接与硬件通信，没有虚拟化层</li></ul></li><li>vda：<ul><li>虚拟硬盘：vda代表的是虚拟环境中的第一个虚拟磁盘设备，这种命名通常出现在使用KVM、QEMU或其他虚拟化技术的环境中</li><li>优化性能：虚拟磁盘可以针对虚拟化环境进行优化，提高性能和灵活性</li></ul></li></ul><h2 id="文件系统">文件系统</h2><h3 id="tmpfs">tmpfs</h3><p><strong>概述：</strong>是linux中的一种临时文件系统，它使用内存或swap来存储文件和目录。因为数据存储在RAM中，使得tmpfs非常适合临时数据的存储。（比如系统启动过程中的临时文件，或者应用程序需要频繁读写的临时数据）</p><p><strong>主要特性：</strong></p><ul><li>速度快：访问速度快于磁盘</li><li>灵活性：可以动态调整大小</li><li>数据易失性：重启系统或卸载tmpfs后，存储在其中的数据会丢失</li></ul><p><strong>使用场景：</strong></p><ul><li>/tmp目录：许多linux发行版使用tmpfs挂载/tmp目录，以提高临时文件处理的速度</li><li>缓存和会话数据：web服务器和数据库可以使用tmpfs来存储缓存数据，提高访问速度</li><li>编译过程中的临时文件：编译大型软件项目时，使用tmpfs可以减少磁盘IO，加快编译速度</li></ul><p><strong>挂载tmpfs：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /mnt/tmp<br>mount -t tmpfs -o size=1G tmpfs /mnt/tmp<br></code></pre></td></tr></table></figure><p>查看是否挂载成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">df</span> -h /mnt/tmp<br></code></pre></td></tr></table></figure><img src="/2024/12/05/Cgroup%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241204234432124.png" class=""><p>卸载tmpfs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">umount /mnt/tmp<br></code></pre></td></tr></table></figure><p><strong>系统启动自动挂载tmpfs：</strong></p><p>在<code>/etc/fstab</code>文件中添加一行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmpfs /mnt/tmp tmpfs defaults,size=1G 0 0<br></code></pre></td></tr></table></figure><h2 id="网络">网络</h2><h3 id="qos">QoS</h3><h4 id="简介-1">简介</h4><p><strong>概述：</strong>是一种控制网络资源使用的机制，以确保关键业务或流量类型(如视频、语音通话)获得必要的带宽和延迟要求，从而提高网络的整体性能和用户体验。QoS通过对网络流量进行分类、排队、调度和流量整形等机制，实现对不同类型流量的差别化处理。linux使用了tc来进行流量控制。</p><p><strong>核心概念：</strong></p><ul><li>流量识别与分类：<ul><li>流量识别是QoS的第一步，通过检查数据包的头部信息(如源/目的IP地址，端口号，协议类型等)来识别流量类型</li><li>分类是根据识别的结果，将流量分入不同的类别或队列。每个类别可以根据其服务质量需求进行不同的处理</li></ul></li><li>流量标记：涉及数据包的头部信息，以反应其QoS优先级。例如，在IP数据包中，可以使用DSCP(differentiatedServices Code Point)字段来标记优先级</li><li>排队：排队策略决定了不同类型的流量如何被存储和转发。不同的排队策略，如FIFO、优先队列、循环队列等，可以根据流量的优先级和需求进行选择</li><li>拥塞避免：当网络出现拥塞时，拥塞避免机制通过丢弃一些数据包来减轻网络负载，常见的算法有TCP的拥塞控制算法，RED等</li><li>流量整形：通过控制数据流的发送速率来调整流量的传输，以符合网络策略或避免网络拥塞。它通常通过延迟额外的数据包实现</li><li>流量调度：决定了不同流量队列中的数据包何时以及以何种顺序被发送。调度算法，如加权公平队列，低延迟队列等。确保高优先级的流量获得快速处理</li><li>带宽管理：涉及分配网络资源，确保关键应用和服务获得足够的带宽。这通常涉及带宽上限和保证来实现</li></ul><p><strong>协议栈的QoS主要由三部分组成：</strong>qdisc(队列规则，queueingdiscipline)，class控制策略， filter根据filter划入具体的控制策略</p><p>一般流程是这样，当一个qdisc被入队的时候，会循环匹配其中的filter，如果匹配到了的话，就会将packet入队到对应的class当中，大部分情况下被class的所有者代表的qdisc入队。一些没有匹配的packet会进入默认的class</p><h4 id="队列规则">队列规则</h4><h4 id="pfifo">pfifo</h4><p>默认的qdisc就是pfifo，实现在net/sched/sch_prio.c</p><p>设置有三个优先级的队列，从高到低分别是：</p><ul><li>0 interactive</li><li>1 best effort</li><li>2 bulk</li></ul><p>先消费0队列在消费1队列，最后消费2队列</p><p>实现依赖如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">prio_sched_data</span> &#123;</span><br><span class="hljs-type">int</span> bands;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcf_proto</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">filter_list</span>;</span><br>u8  prio2band[TC_PRIO_MAX+<span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qdisc</span> *<span class="hljs-title">queues</span>[<span class="hljs-title">TCQ_PRIO_BANDS</span>];</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>bands一般是3个，代表三个不同优先级的队列，然后filter_list是他的过滤器列表，最后prio2band就是ToSTo Queue的映射中linux priority 到band的部分，queues保存的是三个fifo的qdisc，也就是三个队列</p><p>pfifoenqueue的时候会调用prio_classify根据skb-&gt;priority来选择队列进行入队，dequeue的时候则roundrobin每次依次从优先级高到低取出一个packet</p><h4 id="htbhierarchical-token-bucket">HTB(Hierarchical TokenBucket)</h4><p>HTB是一个层级令牌桶的qdsic，而且能加入class</p><h4 id="使用">使用</h4><p>qdisc 参数：parent major:minor或者root</p><p>一个qdisc是根节点就是root，否则其他的情况指定parent。其中major:minor是class的handleid，每个class都要指定一个id用于标识</p><p>handle major: ，这个语法有点奇怪，是可选的，如果 qdisc下面还要分类（多个 class)，则需要指定这个 hanlde。对于root，通常是”1:”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># handle是一组用户指定的标识符，格式为major:minor</span><br><span class="hljs-comment"># 如果是一条queueing discipline, minor需要一直为0，即不写</span><br>tc qdisc add dev eth0 root handle 1: htb<br><span class="hljs-comment"># 具体作用：在eth0网卡上添加一个根队列规则</span><br><span class="hljs-comment"># qdisc：表示要添加一个新的队列规则</span><br><span class="hljs-comment"># dev：指定网络设备名称</span><br><span class="hljs-comment"># root：表示这个队列规则被添加到设备的根位置。在TC中，每个设备都有一个队列规则的层次结构</span><br><span class="hljs-comment"># handle 1:：为这个队列规则指定一个句柄，句柄用于后续操作中引用这个规则</span><br><span class="hljs-comment"># htb：是一种队列规则算法。允许对不同的流量进行分层控制，为每个类比额分配不同的带宽</span><br><br><span class="hljs-comment"># classis指明该class handle的唯一ID，minor需要是非零值</span><br>tc class add dev eth0 parent 1:1 classid 1:6 htb rate 256kbit ceil 512kbit<br><span class="hljs-comment"># 具体作用：在之前配置的队列规则下添加一个新的类</span><br><span class="hljs-comment"># class：表示要添加一个类</span><br><span class="hljs-comment"># parent：指定这个类的父类，挂载在1:1下，而不是直接挂载在根队列规则下</span><br><span class="hljs-comment"># classid：为这个新类指定一个类ID</span><br><span class="hljs-comment"># rate：指定这个类的保证带宽</span><br><span class="hljs-comment"># ceil：指定这个类的最大带宽</span><br><br><span class="hljs-comment"># 新建一个带宽为100kbps的root class，其classid为1:1</span><br>tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps<br><span class="hljs-comment"># parent：直接挂载在根队列规则下</span><br><span class="hljs-comment"># 接着建立两个子class，指定其parent为1:1，ceil用来限制子类最大的带宽</span><br>tc class add dev eth0 parent 1:1 classid 1:10 htb rate 40kbps ceil 100kbps<br>tc class add dev eth0 parent 1:1 classid 1:11 htb rate 60kbps ceil 100kbps<br><span class="hljs-comment"># 随后建立filter指定哪些类型的packet进入哪个class</span><br>tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 match ip dport 80 0xffff flowid 1:10<br><span class="hljs-comment"># 具体作用：添加一个过滤器，用于匹配特定IP流量并将其分配到指定的类</span><br><span class="hljs-comment"># protocol ip：指定过滤器应用于IP协议的数据包</span><br><span class="hljs-comment"># parent 1:0：指定过滤器的父级队列规则，表示根队列规则</span><br><span class="hljs-comment"># prio 1：指定过滤器的优先级为1，数值越低，优先级越高</span><br><span class="hljs-comment"># u32：使用u32过滤器，这是一个通用、功能强大的过滤器</span><br><span class="hljs-comment"># match ip src 1.2.3.4：匹配源IP地址为1.2.3.4的数据包</span><br><span class="hljs-comment"># match ip dport 80 0xffff：匹配目标端口为80的数据包，0xffff是掩码，表示完全匹配</span><br><span class="hljs-comment"># flowid 1:10：指定匹配的数据包将被分配到类ID为1:10的类</span><br>tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 flowid 1:11<br><span class="hljs-comment"># 最后为这些class添加queuing disciplines</span><br>tc qdisc add dev eth0 parent 1:10 handle 20: pfifo <span class="hljs-built_in">limit</span> 5<br>tc qdisc add dev eth0 parent 1:11 handle 30: sfq perturb 10<br></code></pre></td></tr></table></figure><h2 id="设备">设备</h2><h3 id="misc设备">misc设备</h3><p><strong>概述：</strong>通常指代miscellaneous(杂项)设备。它们是一类特殊的字符设备，主要用于子系统中不容易归类到其他设备类别的小设备。'misc'设备由'misc'子系统管理，这个子系统简化了创建和管理这些杂项设备的过程</p><p><strong>特点和管理：</strong></p><ul><li>字符设备：misc设备通常是字符设备，这意味着它们处理数据的方式是按字符（而不是块）来操作</li><li>子系统管理：通过misc子系统，可以简化创建和管理这些设备的步骤</li><li>共享主设备号：所有misc设备共享一个主设备号，但每个设备都有自己独立的次设备号</li><li>设备注册：设备驱动程序通过调用'misc_register'函数注册一个misc设备</li></ul><p><strong>常见的misc设备：</strong></p><ul><li>/dev/urandom和/dev/random<ul><li>提供伪随机数和真随机数生成给</li><li>常用于密码学、密钥生成等随机数的场景</li></ul></li><li>/dev/tty<ul><li>代表当前终端设备的别名</li><li>用于进程与当前终端进行交互</li></ul></li><li>/dev/null<ul><li>被称为位桶或空设备</li><li>写入数据会被丢弃，读取数据时会返回EOF</li><li>常用于丢弃不需要的数据或测试</li></ul></li><li>/dev/zero<ul><li>提供无限量的零字节</li><li>常用于内存初始化或创建空文件</li></ul></li><li>/dev/full<ul><li>提供一个总是返回满的设备，写入时返回ENOSPC错误</li><li>常用于测试错误处理</li></ul></li><li>/dev/loopX<ul><li>环回设备(Loopback device)</li><li>用于将文件作为块设备使用，常用于创建文件系统映像</li></ul></li><li>/dev/kmsg<ul><li>内核消息设备</li><li>用于从用户空间向内核日志发送消息</li></ul></li><li>/dev/hpet：<ul><li>高精度时间计数器</li><li>提供高精度的定时功能</li></ul></li><li>/dev/input/mice和/dev/input/mouseX<ul><li>提供对连接到系统的鼠标设备的访问</li><li>常用于捕获和处理鼠标输入事件</li></ul></li><li>/dev/watchdog<ul><li>看门狗设备</li><li>用于系统监控和恢复，如果系统挂起，未及时重置看门狗计时器，将触发系统重启</li></ul></li></ul><h3 id="rdma">RDMA</h3><p><strong>概述：</strong>Remote Direct Memory Access设备是一类允许直接在不同计算机之间传输数据的网络设备，而不需要经过CPU的干预或传统的操作系统网络栈。RDMA的主要目标是提供低延迟、高带宽的数据传输能力，特别适用于高性能计算、分布式存储系统、大规模数据中心以及金融服务等领域</p><p><strong>基本概念：</strong></p><ul><li>RDMA：RDMA是一种技术，允许在不同主机之间直接传输数据，从而绕过传统的网络协议栈，如TCP/IP。通过直接访问远程主机的内存，RDMA能够大幅减少数据传输的延迟，并减轻CPU的负担</li><li>RDMA设备：是一种支持RDMA技术的网络设备，通常是专用的网卡，如InfiniBand适配器、RoCE网卡或iWARP设备。这些设备通常包含硬件加速器，可以直接处理内存传输和网络数据包，而不需要经过操作系统内核的处理</li></ul><p><strong>关键优势：</strong></p><ul><li>低延迟：由于跳过了内核的网络协议栈，并且可以直接在网络设备上处理数据传输，RDMA显著降低了数据传输的延迟</li><li>高带宽：RDMA设备通常支持非常高的网络带宽，适合大规模数据传输任务</li><li>低CPU开销：在传统的网络通信中，数据包的处理需要占用大量CPU资源。而RDMA技术让数据传输直接在网卡上处理，释放了CPU资源</li><li>零拷贝传输：即数据可以从一台机器的内存直接传输到另一台机器的内存，而不需要中间的内存拷贝操作</li></ul><p><strong>工作原理：</strong>通过一组硬件来直接访问远程系统的内存</p><ul><li>QueuePair(QP)：有发送队列和接收队列组成。它们用于处理数据的发送和接收操作</li><li>MemoryRegion(MR)：MR是RDMA设备访问内存区域的方式。内存区域被注册到RDMA设备中，使其能够直接访问这些区域的物理内存</li><li>CompletionQueue(CQ)：用于通知操作完成的队列。每当一个发送或接收操作完成时，CQ会产生一个完成事件，供应用程序处理</li><li>RDMA Operations：Send/Receive、RDMA Read和RDMAWrite。Send/Receive类似于传统的消息传递，而RDMARead和Write操作则允许直接从远程内存中读取或写入数据</li></ul><h2 id="内核配置">内核配置</h2><p>如何查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /boot/config-$(<span class="hljs-built_in">uname</span> -r) | grep <span class="hljs-variable">$CONFIG_NAME</span><br></code></pre></td></tr></table></figure><ul><li>CONFIG_NAME：某个具体的内核配置名称</li></ul><p><strong>配置状态：</strong></p><p><strong><code>y</code></strong>：表示该功能已启用，并且是静态编译到内核中的，即直接编译到内核映像内，不会作为模块存在。</p><p><strong><code>m</code></strong>：表示该功能被配置为内核模块（module），也就是该功能会作为一个单独的模块被编译出来，加载时才会启用。</p><p><strong><code>n</code></strong>：表示该功能没有启用，也就是说该功能在内核中被禁用，既不编译到内核，也不作为模块编译。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cgroup</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL阴影映射技术介绍</title>
    <link href="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="opengl阴影映射技术介绍">OpenGL阴影映射技术介绍</h1><h2 id="sm">SM</h2><p><strong>概述：</strong> ShadowMapping，最基本的阴影算法之一，通过使用光源的视角渲染场景的深度信息来生成阴影，其核心思想时将光源的深度信息存储在一个深度贴图中，在进行渲染时，利用该深度信息来判断每个片段是否在阴影中</p><p><strong>步骤：</strong></p><ol type="1"><li>生成深度贴图：对场景进行一次光源视角的渲染，生成一个深度贴图，该贴图存储了光源照射到场景中的每个像素的深度值<ul><li>在光源的视角中，进行正交或透视投影渲染</li><li>将深度值存储在深度贴图中</li></ul></li><li>使用深度贴图进行阴影测试：在场景的主渲染阶段，首先将每个片段（像素）的世界坐标转换到光源的视角空间，然后在光源的深度贴图查询该位置的深度值，如果当前片段的深度值大于深度贴图中的值，说明该片段在阴影中</li></ol><p><strong>算法实现：</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> SM(<span class="hljs-type">vec4</span> fragPosLightSpace,<span class="hljs-type">vec3</span> normal,<span class="hljs-type">vec3</span> lightDir,<span class="hljs-type">sampler2D</span> shadowMap)&#123;<br>    <span class="hljs-comment">// 转换为标准齐次坐标 z[-1, 1]</span><br>    <span class="hljs-type">vec3</span> projCoords=fragPosLightSpace.xyz/fragPosLightSpace.w;<br>    <span class="hljs-comment">// xyz: [-1, 1] -&gt; [0, 1]</span><br>    projCoords=projCoords*<span class="hljs-number">.5</span>+<span class="hljs-number">.5</span>;<br>    <span class="hljs-comment">// 只要投影向量的z坐标大于1.0或小于0.0，就把shadow设置为1.0(即超出了光源视锥体的最远处，这样最远处也不会处在阴影中，导致采样过多不真实)</span><br>    <span class="hljs-keyword">if</span>(projCoords.z&gt;<span class="hljs-number">1.</span>||projCoords.z&lt;<span class="hljs-number">0.</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    <br>    <span class="hljs-comment">// 从光源视角看到的深度值（从阴影贴图获取</span><br>    <span class="hljs-type">float</span> closestDepth=<span class="hljs-built_in">texture</span>(shadowMap,projCoords.xy).r;<br>    <span class="hljs-comment">// 从摄像机视角看到的深度值</span><br>    <span class="hljs-type">float</span> currentDepth=projCoords.z;<br>    <span class="hljs-comment">// 偏移量，解决阴影失真的问题, 根据表面朝向光线的角度更改偏移量</span><br>    <span class="hljs-type">float</span> bias=<span class="hljs-built_in">max</span>(<span class="hljs-number">.05</span>*(<span class="hljs-number">1.</span>-<span class="hljs-built_in">dot</span>(normal,lightDir)),<span class="hljs-number">.005</span>);<br>    <span class="hljs-comment">/// 常规做法：如果currentDepth大于closetDepth，说明当前fragment被某个物体遮挡住了，在阴影之中</span><br>    <span class="hljs-type">float</span> shadow=currentDepth-bias&gt;closestDepth?<span class="hljs-number">1.</span>:<span class="hljs-number">0.</span>;<br>    <br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>效果图：</strong> <img src="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/image-20241201160122292.png" class=""></p><h2 id="pcf">PCF</h2><p><strong>概述：</strong> Percentage CloserFilter是对阴影贴图的一种后处理技术，用于减少阴影的锯齿状边缘，通过对阴影贴图中的多个样本进行采样，计算它们的平均值，从而实现阴影的模糊过渡</p><p><strong>步骤：</strong></p><ol type="1"><li>多次采样：在阴影测试阶段，针对每个片段，不仅仅检查单个像素的深度值，而是对一个小范围内的小像素进行采样（例如3×3或5×5的采样区域）</li><li>计算平均值：对采样的范围进行阴影测试，如果当前片段大于从深度贴图采样的值，认为其在阴影中，累加到shadow变量中，最后对shadow变量取平均值</li></ol><p><strong>算法实现：</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> PCF(<span class="hljs-type">vec4</span> fragPosLightSpace,<span class="hljs-type">vec3</span> normal,<span class="hljs-type">vec3</span> lightDir,<span class="hljs-type">sampler2D</span> shadowMap)&#123;<br>    <span class="hljs-comment">// 转换为标准齐次坐标 z[-1, 1]</span><br>    <span class="hljs-type">vec3</span> projCoords=fragPosLightSpace.xyz/fragPosLightSpace.w;<br>    <span class="hljs-comment">// xyz: [-1, 1] -&gt; [0, 1]</span><br>    projCoords=projCoords*<span class="hljs-number">.5</span>+<span class="hljs-number">.5</span>;<br>    <span class="hljs-comment">// 只要投影向量的z坐标大于1.0或小于0.0，就把shadow设置为1.0(即超出了光源视锥体的最远处，这样最远处也不会处在阴影中，导致采样过多不真实)</span><br>    <span class="hljs-keyword">if</span>(projCoords.z&gt;<span class="hljs-number">1.</span>||projCoords.z&lt;<span class="hljs-number">0.</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    <br>    <span class="hljs-comment">// 从光源视角看到的深度值（从阴影贴图获取</span><br>    <span class="hljs-type">float</span> closestDepth=<span class="hljs-built_in">texture</span>(shadowMap,projCoords.xy).r;<br>    <span class="hljs-comment">// 从摄像机视角看到的深度值</span><br>    <span class="hljs-type">float</span> currentDepth=projCoords.z;<br>    <span class="hljs-comment">// 偏移量，解决阴影失真的问题, 根据表面朝向光线的角度更改偏移量</span><br>    <span class="hljs-type">float</span> bias=<span class="hljs-built_in">max</span>(<span class="hljs-number">.05</span>*(<span class="hljs-number">1.</span>-<span class="hljs-built_in">dot</span>(normal,lightDir)),<span class="hljs-number">.005</span>);<br>    <span class="hljs-comment">/// PCF:</span><br>    <span class="hljs-type">float</span> shadow=<span class="hljs-number">0.</span>;<br>    <span class="hljs-comment">// 计算每个纹素的大小</span><br>    <span class="hljs-type">vec2</span> texelSize=<span class="hljs-number">1.</span>/<span class="hljs-built_in">textureSize</span>(shadowMap,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 遍历3x3的邻域</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=-PCF_RADIUS;x&lt;=PCF_RADIUS;++x)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=-PCF_RADIUS;y&lt;=PCF_RADIUS;++y)<br>        &#123;<br>            <span class="hljs-comment">// 从阴影贴图中采样深度值</span><br>            <span class="hljs-type">float</span> pcfDepth=<span class="hljs-built_in">texture</span>(shadowMap,projCoords.xy+<span class="hljs-type">vec2</span>(x,y)*texelSize).r;<br>            <span class="hljs-comment">// 如果当前片段的深度值大于采样的深度值，则在阴影中</span><br>            shadow+=currentDepth-bias&gt;pcfDepth?<span class="hljs-number">1.</span>:<span class="hljs-number">0.</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算平均阴影值</span><br>    <span class="hljs-type">float</span> total=<span class="hljs-number">2</span>*PCF_RADIUS+<span class="hljs-number">1</span>;<br>    shadow/=(total*total);<br>    <br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong>PCF的优点是相对简单，但可能会导致较为模糊的阴影，且在高分辨率阴影贴图上会更有效。</p><p><strong>效果图：</strong> <img src="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/image-20241201161755195.png" class=""></p><h2 id="pcss">PCSS</h2><p><strong>概述：</strong> Percentage Closer SoftShadows是一种基于PCF的扩展，旨在生成更自然的软阴影效果。PCSS通过在阴影贴图的采样过程中引入光源半径的概念，来根据片段距离光源的远近来调整阴影的柔和成都</p><p><strong>步骤：</strong></p><ol type="1"><li>计算光源的大小：由于距离光源较远的区域阴影边缘应该更加模糊，PCSS根据光源的大小（即阴影的投射区域）来动态调整阴影的软化程度</li><li>应用阴影半径：对于每个片段，计算该片段距离光源的距离，并基于该距离来调整PCF的采样区域大小。距离较远的片段采用较大的采样区域，从而产生更软的阴影</li></ol><p><strong>算法实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">PCSS</span><span class="hljs-params">(vec4 fragPosLightSpace,vec3 normal,vec3 lightDir,sampler2D shadowMap)</span></span>&#123;<br>    <span class="hljs-comment">// 转换为标准齐次坐标 z[-1, 1]</span><br>    vec3 projCoords=fragPosLightSpace.xyz/fragPosLightSpace.w;<br>    <span class="hljs-comment">// xyz: [-1, 1] -&gt; [0, 1]</span><br>    projCoords=projCoords*<span class="hljs-number">.5</span><span class="hljs-number">+.5</span>;<br>    <span class="hljs-comment">// 只要投影向量的z坐标大于1.0或小于0.0，就把shadow设置为1.0(即超出了光源视锥体的最远处，这样最远处也不会处在阴影中，导致采样过多不真实)</span><br>    <span class="hljs-keyword">if</span>(projCoords.z&gt;<span class="hljs-number">1.</span>||projCoords.z&lt;<span class="hljs-number">0.</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    <br>    <span class="hljs-comment">// 从光源视角看到的深度值（从阴影贴图获取</span><br>    <span class="hljs-type">float</span> closestDepth=<span class="hljs-built_in">texture</span>(shadowMap,projCoords.xy).r;<br>    <span class="hljs-comment">// 从摄像机视角看到的深度值</span><br>    <span class="hljs-type">float</span> currentDepth=projCoords.z;<br>    <span class="hljs-comment">// 偏移量，解决阴影失真的问题, 根据表面朝向光线的角度更改偏移量</span><br>    <span class="hljs-type">float</span> bias=<span class="hljs-built_in">max</span>(<span class="hljs-number">.05</span>*(<span class="hljs-number">1.</span>-<span class="hljs-built_in">dot</span>(normal,lightDir)),<span class="hljs-number">.005</span>);<br>    <span class="hljs-comment">/// PCSS:</span><br>    <span class="hljs-comment">// 计算平均遮挡物体的深度值</span><br>    <span class="hljs-type">float</span> avgDepth=<span class="hljs-built_in">findBlocker</span>(projCoords.xy,currentDepth,shadowMap,bias);<br>    <span class="hljs-comment">// 如果没有遮挡物体，则直接返回0.0(不在阴影中)</span><br>    <span class="hljs-keyword">if</span>(avgDepth==<span class="hljs-number">-1.</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    &#125;<br>    <span class="hljs-comment">// 半影大小</span><br>    <span class="hljs-type">float</span> penumbra=(currentDepth-avgDepth)/avgDepth*lightWidth;<br>    <span class="hljs-comment">// 采样半径</span><br>    <span class="hljs-type">float</span> filterRadius=penumbra*NEAR_PLANE/currentDepth;<br>    <span class="hljs-comment">// PCF</span><br>    filterRadius*=PCFSampleRadius;<br>    <span class="hljs-type">float</span> shadow=<span class="hljs-number">0.</span>;<br>    <span class="hljs-comment">// 计算每个纹素的大小</span><br>    vec2 texelSize=<span class="hljs-number">1.</span>/<span class="hljs-built_in">textureSize</span>(shadowMap,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 遍历邻域</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=-PCF_RADIUS;x&lt;=PCF_RADIUS;++x)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y=-PCF_RADIUS;y&lt;=PCF_RADIUS;++y)<br>        &#123;<br>            <span class="hljs-comment">// 从阴影贴图中采样深度值</span><br>            <span class="hljs-type">float</span> shadowMapDepth=<span class="hljs-built_in">texture</span>(shadowMap,projCoords.xy+filterRadius*<span class="hljs-built_in">vec2</span>(x,y)*texelSize).r;<br>            <span class="hljs-comment">// 如果当前片段的深度值大于采样的深度值，则在阴影中</span><br>            shadow+=currentDepth-bias&gt;shadowMapDepth?<span class="hljs-number">1.</span>:<span class="hljs-number">0.</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 计算平均阴影值</span><br>    <span class="hljs-type">float</span> total=<span class="hljs-number">2</span>*PCF_RADIUS<span class="hljs-number">+1</span>;<br>    shadow/=(total*total);<br>    <br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong>PCSS能够产生更加平滑和逼真的阴影效果，但相对于普通的PCF，计算开销较大。</p><p><strong>效果图：</strong> <img src="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/image-20241201204040348.png" class=""></p><h2 id="vsm">VSM</h2><p><strong>概述：</strong> Variance Shadow Mapping是一种通过利用方差来改进传统阴影贴图的方法，与传统的阴影贴图不同，VSM使用每个光源的深度值的均值和方差来创建阴影，这样可以在计算中处理阴影的模糊化，同时避免了对深度贴图的多次采样</p><p><strong>步骤：</strong></p><ol type="1"><li>存储深度和方差：在深度贴图中，不仅存储每个像素的深度值，还存储该深度值的方差，这样，光源照射到场景中的区域可以通过方差值来表示阴影的软化程度<ul><li>第一通道存储深度值(z)</li><li>第二通道存储深度值的方差(<spanclass="math inline">\(\delta^2\)</span>)</li></ul></li><li>深度比较：在片段着色器中，使用一个不等式来判断一个片段是否被阴影遮挡，由于存储了方差，阴影边缘会变得更平滑</li></ol><p><strong>算法实现：</strong></p><ul><li>需要两个纹理来存储对应点周围区域内的方差和均值</li><li>两趟pass可以把每个点的复杂度从<spanclass="math inline">\((2R+1)^2\)</span>降到<spanclass="math inline">\((4R+2)\)</span></li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> VSM(<span class="hljs-type">vec4</span> fragPosLightSpace,<span class="hljs-type">vec3</span> normal,<span class="hljs-type">vec3</span> lightDir,<span class="hljs-type">sampler2D</span> d_d2_filter)&#123;<br>    <span class="hljs-type">vec3</span> projCoords=fragPosLightSpace.xyz/fragPosLightSpace.w;<br>    <span class="hljs-comment">// [-1, 1] =&gt; [0, 1]</span><br>    projCoords=projCoords*<span class="hljs-number">.5</span>+<span class="hljs-number">.5</span>;<br>    <span class="hljs-keyword">if</span>(projCoords.z&gt;<span class="hljs-number">1.</span>||projCoords.z&lt;<span class="hljs-number">0.</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>    <br>    depth=projCoords.z;<br>    <br>    <span class="hljs-comment">// 从模糊后的纹理中获得深度值均值和方差</span><br>    d_d2=<span class="hljs-built_in">texture</span>(d_d2_filter,projCoords.xy).rg;<br>    <span class="hljs-type">float</span> var=d_d2.y-d_d2.x*d_d2.x;<span class="hljs-comment">// E(X-EX)^2 = EX^2-E^2X</span><br>    <br>    <span class="hljs-comment">// 偏移量，解决阴影失真的问题, 根据表面朝向光线的角度更改偏移量</span><br>    <span class="hljs-type">float</span> bias=<span class="hljs-built_in">max</span>(<span class="hljs-number">.05</span>*(<span class="hljs-number">1.</span>-<span class="hljs-built_in">dot</span>(normal,lightDir)),<span class="hljs-number">.005</span>);<br>    <span class="hljs-comment">// float bias=.005;</span><br>    <span class="hljs-type">float</span> visibility;<br>    <span class="hljs-keyword">if</span>(depth-bias&lt;d_d2.x)&#123;<br>        visibility=<span class="hljs-number">1.</span>;<span class="hljs-comment">// 没有阴影</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 使用切比雪夫不等式计算阴影</span><br>        <span class="hljs-type">float</span> t_minus_mu=depth-d_d2.x;<br>        visibility=var/(var+t_minus_mu*t_minus_mu);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.</span>-visibility;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong>VSM能提供相对较好的阴影效果，且具有较低的计算开销，但可能会面临一些噪声问题，特别是在低对比度区域</p><p><strong>效果图：</strong> <img src="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/image-20241202160611579.png" class=""></p><p><strong>与PCSS对比：</strong></p><p>PCSS： <img src="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/image-20241202160757509.png" class=""></p><p>VSM: <img src="/2024/12/02/OpenGL%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/image-20241202160922226.png" class=""></p><h2 id="csm">CSM</h2><p><strong>概述：</strong> Cascaded shadow map(联级阴影贴图)</p><p>（待补充）</p><h2 id="其他">其他</h2><p><strong>参考：</strong></p><ul><li><ahref="https://learnopengl-cn.github.io/05%20Advanced%20Lighting/03%20Shadows/01%20Shadow%20Mapping/">阴影映射- LearnOpenGL CN</a></li><li><ahref="https://banbao991.github.io/2021/06/18/CG/Algorithm/SM-PCF-PCSS-VSM/#阴影算法的实现">阴影算法的实现(SM、PCF、PCSS、VSM)| Banbao</a></li><li><ahref="https://blog.csdn.net/m0_56399931/article/details/123593345">算法复现：OpenGL-ShadowMap/PCSS/CSM_openglcsm-CSDN博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opengl</tag>
      
      <tag>阴影映射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习期末复习笔记</title>
    <link href="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>markdown文件下载：https://github.com/1037827920/SCUT-Notes</p><h1 id="期末考试复习笔记">期末考试复习笔记</h1><h2 id="机器学习简介">1. 机器学习简介</h2><h3 id="什么是机器学习">1.1 什么是机器学习</h3><p>如图所示：</p><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241125144004699.png" class=""><p>几乎所有的机器学习都包括以下三个部分：数据、模型和损失函数</p><ul><li>数据：不同的应用需要处理不同的数据</li><li>模型：根据实际情况训练出特定的模型</li><li>评估：通过损失函数来对模型进行统一的评价，主要包括三种：HingeLoss、Logistic Loss、Softmax Loss</li></ul><h3 id="机器学习的分类">1.2 机器学习的分类</h3><h4 id="有监督学习">1.2.1 有监督学习</h4><p><strong>概述：</strong> superviseed learning的核心是利用标注好的数据进行训练，也就是输入数据(features)和对应的目标输出(labels)是已知的。目标是学习一个映射函数f(x)，可以将输入x映射到输出y</p><p><strong>步骤：</strong></p><ol type="1"><li>数据准备：收集和标注数据集，包括输入和输出树</li><li>模型训练：用训练数据让模型学习输入和输出之间的关系</li><li>模型验证：用测试数据评估模型的泛化能力</li></ol><p><strong>常见任务：</strong></p><ul><li>分类问题：将输入分配到离散的类比（例如垃圾邮箱检测、图片分类）</li><li>回归问题：预测连续值（例如，房价预测、天气预测）</li></ul><p><strong>常用算法：</strong></p><ul><li>线性回归</li><li>逻辑回归</li><li>支持向量机(SVM)</li><li>决策树、随机森林</li><li>神经网络</li></ul><h4 id="无监督学习">1.2.2 无监督学习</h4><p><strong>概述：</strong> Unsupervised Learning的输入数据没有标注（没有目标输出），目标是从数据中发掘隐藏的结构、模式或分布</p><p><strong>步骤：</strong></p><ol type="1"><li>数据分析：分析数据中的结构或分布</li><li>模型训练：寻找数据的潜在模式（如聚类或降维）</li><li>结果解释：将模式用于可视化或进一步分析</li></ol><p><strong>常用算法：</strong></p><ul><li>K均值</li><li>DBSCAN</li><li>主成分分析(PCA)</li><li>自编码器</li></ul><h4 id="强化学习">1.2.3 强化学习</h4><p><strong>概述：</strong> Reinforcement Learning模拟的是智能体(Agent)和环境(Environment)的交互过程。智能体通过观察环境状态(State)采取动作(Action)，从环境中接收奖励(Reward)并调整策略，以最大化累计奖励</p><p><strong>特点：</strong></p><ul><li>数据不是预先标注的，而是通过与环境的交互产生</li><li>需要权衡探索(Explore)和利用(Exploit)</li></ul><p><strong>步骤：</strong></p><ol type="1"><li>智能体感知当前环境状态</li><li>智能体根据策略选择动作</li><li>环境根据动作反馈奖励和下一个状态</li><li>智能体通过学习调整策略以优化未来行为</li></ol><p><strong>常见任务：</strong></p><ul><li>游戏AI（例如AlphaGo、强化学习玩Atari游戏）</li><li>自动驾驶</li><li>机器人控制</li><li>动态资源分配（例如云计算资源管理）</li></ul><p><strong>常用算法：</strong></p><ul><li>Q学习</li><li>深度Q网络(DQN)</li><li>策略梯度方法（Policy Gradient）</li><li>Actor-Critic 方法</li></ul><h4 id="对比总结">1.2.4 对比总结</h4><table><thead><tr><th style="text-align: center;">特性</th><th style="text-align: center;">Supervised Learning</th><th style="text-align: center;">Unsupervised Learning</th><th style="text-align: center;">Reinforcement Learning</th></tr></thead><tbody><tr><td style="text-align: center;">数据类型</td><td style="text-align: center;">有标签数据</td><td style="text-align: center;">无标签数据</td><td style="text-align: center;">与环境交互生成数据</td></tr><tr><td style="text-align: center;">目标</td><td style="text-align: center;">学习输入到输出的映射</td><td style="text-align: center;">发现隐藏结构或模式</td><td style="text-align: center;">最大化长期累计奖励</td></tr><tr><td style="text-align: center;">应用场景</td><td style="text-align: center;">分类、回归</td><td style="text-align: center;">聚类、降维、异常检测</td><td style="text-align: center;">游戏AI、自动驾驶</td></tr><tr><td style="text-align: center;">反馈形式</td><td style="text-align: center;">数据中提供明确反馈</td><td style="text-align: center;">数据无明确反馈</td><td style="text-align: center;">奖励信号作为反馈</td></tr></tbody></table><h3 id="机器学习与概率统计">1.3 机器学习与概率统计</h3><p><strong>贝叶斯理论：</strong> <span class="math display">\[P(Y, X) = P(X|Y) * P(Y) \\P(X, Y) = P(Y|X) * P(X)\]</span></p><p><span class="math display">\[P(Y|X) = \frac{P(X|Y)P(Y)}{P(X)} \\P(X) = \sum_YP(X|Y)P(Y)\]</span></p><ul><li>先验概率：在没有新信息之前，我相信的概率</li><li>后验概率：在考虑新信息之后，我相信的概率</li><li>边缘概率：在不考虑其因素的情况下，某个因素发生的概率</li></ul><p><strong>牙科例子：</strong></p><ol type="1"><li><p>定义事件：</p><ul><li>A：患者有智齿发炎</li><li>B：患者有蛀牙</li><li>X：患者牙疼</li></ul></li><li><p>先验概率：</p><ul><li>P(A)：患者智齿发炎的先验概率</li><li>P(B)：患者有蛀牙的先验概率</li></ul></li><li><p>似然性：</p><ul><li>P(X|A)：给定患者有智齿发炎的情况下牙疼的概率</li><li>P(X|B)：给定患者有蛀牙的情况下牙疼的概率</li></ul></li><li><p>边缘概率：</p><ul><li>P(X)：患者牙疼的总概率，可以通过全概率公式计算： <spanclass="math display">\[P(X) = P(X|A)P(A) + P(X|B)P(B)\]</span></li></ul></li><li><p>后验概率：</p><ul><li>P(A|X)：给定患者牙疼的情况下，患者有智齿发炎的后验概率</li><li>P(B|X)：给定患者牙疼的情况下，患者有蛀牙的后验概率</li></ul></li><li><p>贝叶斯定理：</p><ul><li>计算后验概率： <span class="math display">\[P(A|X) = \frac{P(X|A)P(A)}{P(X)} \\P(B|X) = \frac{P(X|B)P(B)}{P(X)}\]</span></li></ul></li></ol><h3 id="信息论简介">1.4 信息论简介</h3><p><strong>对于一个事件的信息度量：</strong> <spanclass="math display">\[I(A) = -log_bP(A)\]</span></p><ul><li>I(A)：表示信息的内容，是一个随机的变量</li><li>P(A)：表示事件发生的概率</li><li>b：基底</li></ul><p><strong>熵(Entropy)：</strong></p><p>熵是一个用于表示预期平均信息含量的变量 <span class="math display">\[H(A) = -E[log_2P(A)] = -\sum_AP(A)log_2P(A)\]</span></p><h2 id="线性回归和梯度下降">2. 线性回归和梯度下降</h2><p>==线性回归是拟合数据的方法，梯度下降是寻找最优解的技巧==</p><h3 id="线性回归">2.1 线性回归</h3><p><strong>概述：</strong></p><p>在一元线性回归中，我们假设目标变量y与特征变量x存在线性关系，模型表达式为：<span class="math display">\[y=W_0+W_1x_1+W_2x_2+\cdots+W_nx_n+\epsilon\]</span> 其中：</p><ul><li><span class="math inline">\(W_0\)</span>是截距(bias)</li><li><spanclass="math inline">\(W_1,W_2,...,W_n\)</span>是回归系数（权重）</li><li>ε是噪声或误差项</li></ul><p>对于多个样本的情况，可以将特征表示为矩阵X，目标值为向量y。在这种情况下，线性回归模型可以写作：<span class="math display">\[\hat{y}=XW\]</span> 其中：</p><ul><li>X是输入特征矩阵（包含所有样本）</li><li>W是权重向量</li><li><span class="math inline">\(\hat{y}\)</span>是模型的预测值向量</li></ul><p><strong>损失函数(MSE)：</strong></p><p>为了让模型拟合数据，通常我们会使用均方误差(MSE)作为损失函数，来度量模型的预测值<spanclass="math inline">\(\hat{y}\)</span>与实际值y之间的差异： <spanclass="math display">\[J(W)=\frac1{2m}\sum_{i=1}^m(\hat{y}_i-y_i)^2=\frac1{2m}(XW-y)^T(XW-y)\]</span></p><ul><li>m：样本数</li><li>损失函数越小，说明这个函数拟合越好。</li></ul><h3 id="闭式解">2.2 闭式解</h3><p><strong>概述：</strong>指通过直接求解方程组，得到回归模型的参数（即权重向量）的解析解，而不需要通过迭代的优化算法（如梯度下降）来找到最优解</p><p><strong>闭式解的推导：</strong></p><p>最小化损失函数<spanclass="math inline">\(J(W)\)</span>以找到最优权重W。通过对<spanclass="math inline">\(W\)</span>求导并让导数为0，可以得到线性回归的解析解。首先对损失函数求导：<span class="math display">\[\frac{\partial J(W)}{\partial W}=\frac1mX^T(XW-y)\]</span> 将导数设置为0，求解<span class="math inline">\(W\)</span>：<span class="math display">\[\begin{gathered}X^T(XW-y)=0 \\X^TXW=X^Ty\end{gathered}\]</span> 可以通过矩阵求逆的方式得到<spanclass="math inline">\(W\)</span>： <span class="math display">\[W=(X^TX)^{-1}X^Ty\]</span> 这就是线性回归的闭式解公式</p><p><strong>闭式解的核心思想：</strong></p><ul><li>直接求解：通过解析方法一次性求出最优权重<spanclass="math inline">\(W\)</span>，不需要像梯度下降一样逐步优化</li><li>线性代数运行：通过矩阵转置、乘法和求逆等线性代数运算实现</li><li>适用场景：对于小规模数据集、闭式解可以快速得到结果。然而当数据量非常大时，计算<spanclass="math inline">\(X^TX\)</span>的逆矩阵可能非常耗时，因此在大数据集上通常采用梯度下降等数据优化方法</li></ul><p><strong>优点与缺点：</strong></p><ul><li>优点：直接得到最优解，计算速度快（适合小数据集</li><li>缺点：对于高维度数据集，矩阵求逆的计算复杂度较高<spanclass="math inline">\(O(n^3)\)</span>，在数据量过大时不适用</li></ul><p><strong>RLS(正则化最小方差)回归算法：</strong>在损失函数中增加一个常量用于处理正则化，从而避免了矩阵的逆无法求解的问题，线性回归是唯一一个可以正确找到正则化关系的机器学习回归方法。</p><p>【没有详细了解】</p><h3 id="梯度下降">2.3 梯度下降</h3><p><strong>概述：</strong>除了求解闭式解外，还可以通过梯度下降的方法逼近最佳的w值</p><p><strong>通用的优化方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">1</span>, epoches + <span class="hljs-number">1</span>):<br>    <span class="hljs-number">1.</span> 寻找一个可行的搜索方向d（找起来有难度<br>    <span class="hljs-number">2.</span> 寻找一个好的步长η[k]<br>    <span class="hljs-number">3.</span> 更新w的值：w[k+<span class="hljs-number">1</span>] = w[k] + η[k] * d[k]<br></code></pre></td></tr></table></figure><p><strong>可以将三步走扩展到五步走：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">w[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">1</span>, epoches + <span class="hljs-number">1</span>):<br>    <span class="hljs-number">1.</span> 构造前向传播，用于求解损失函数L[w[k]]<br>    <span class="hljs-number">2.</span> 构造反向传播，用于计算梯度 w[k] = derication(L[w[k]], w[k])<br>    <span class="hljs-number">3.</span> d = -w[k]<br>    <span class="hljs-number">4.</span> 定义一个好的步长η[k]（步长过长会导致发散，步长过短会导致收敛过慢，所以需要开发者调节）。一般来说，调节方案可以是η[k+<span class="hljs-number">1</span>] = η[k]/(k+<span class="hljs-number">1</span>)<br>    <span class="hljs-number">5.</span> 更新w的值：w[k+<span class="hljs-number">1</span>] = w[k] + η[k] * d[k]<br></code></pre></td></tr></table></figure><h2 id="线性分类svm随机梯度下降多分类">3.线性分类，SVM，随机梯度下降，多分类</h2><h3 id="线性分类">3.1 线性分类</h3><p><strong>概述：</strong>线性分类器是基于线性决策边界进行分类的模型，形式上它会学到一个权重向量W和一个偏置b，其决策规则可以表示为：<span class="math display">\[f(\mathbf{x})=\mathbf{w}^T\mathbf{x}+b\]</span> 在这种情况下，分类是根据f(X)的符号来进行的：</p><ul><li>如果f(x) &gt; 0，则将数据点分类为正类</li><li>否则为负类</li></ul><p>这种方式只输出一个硬分类的结果，没有给出分类的概率</p><h4 id="线性可分数据">3.1.1 线性可分数据</h4><p><strong>概述：</strong>指的是数据集中的不同类别可以通过一条直线（在二维空间中）或一个超平面（在高维空间中）完全分开，没有任何重叠或错误分类</p><p><strong>特点：</strong></p><ul><li>可以找到一个线性决策边界（如一条直线或一个超平面），使得数据集中所有点都可以准确分到正确的类别</li><li>这种类比的数据适合使用线性分类器，如感知器、线性支持向量机（SVM）等</li></ul><p><strong>二维平面中的例子：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">类别</span> <span class="hljs-attr">A:</span> <span class="hljs-string">(蓝色点)</span>   <span class="hljs-string">类别</span> <span class="hljs-attr">B:</span> <span class="hljs-string">(红色点)</span><br><br><span class="hljs-string">蓝</span>   <span class="hljs-string">蓝</span>   <span class="hljs-string">蓝</span>   <span class="hljs-string">蓝</span><br>                <span class="hljs-string">(直线)</span><br><span class="hljs-string">红</span>   <span class="hljs-string">红</span>   <span class="hljs-string">红</span>   <span class="hljs-string">红</span><br><br></code></pre></td></tr></table></figure><p>在这种情况下，直线可以完全分开这两类点，没有任何交错</p><h4 id="线性不可分数据">3.1.2 线性不可分数据</h4><p><strong>概述：</strong>是指数据集中不同类别的点不能通过一条直线（或超平面）来完全分开，一些数据会落在错误的边界一侧，导致无法完美分类</p><p><strong>特点：</strong></p><ul><li>没有单一的线性边界可以准确分隔数据类别</li><li>线性分类器在这种情况下表现不佳，因为它们依赖于线性分界线</li><li>处理线性不可分数据的常用方法包括使用非线性模型（如核化支持向量机、决策树）或者对特征进行转换，，使数据在更高维空间中线性可分</li></ul><p><strong>二维平面中的例子：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">类别</span> <span class="hljs-attr">A:</span> <span class="hljs-string">(蓝色点)</span>   <span class="hljs-string">类别</span> <span class="hljs-attr">B:</span> <span class="hljs-string">(红色点)</span><br><br><span class="hljs-string">蓝</span>   <span class="hljs-string">红</span>   <span class="hljs-string">蓝</span>   <span class="hljs-string">红</span><br><span class="hljs-string">红</span>   <span class="hljs-string">蓝</span>   <span class="hljs-string">红</span>   <span class="hljs-string">蓝</span><br><br></code></pre></td></tr></table></figure><p>在这种情况下，无论如何放置一条直线，总会有一部分点被错误分类。</p><p><strong>解决线性不可分问题：</strong></p><ul><li>引入非线性分类器：如使用核支持向量机（SVM），将数据映射到高维空间，使其在高维空间中线性可分。</li><li>增加特征：通过添加多项式特征或交互特征，可以在输入空间中创建一个更复杂的模型。</li><li>使用核技巧 (Kernel Trick)：这是 SVM的一个重要特性，通过核函数将低维数据映射到高维空间，使原本线性不可分的数据在高维空间中变得线性可分。</li></ul><h3 id="支持向量机线性可分">3.2 支持向量机(线性可分)</h3><p><strong>概述：</strong> Support VectorMachine是一种更为强大的分类算法，特别适合于线性不可分的数据集。SVM的目标是在特征空间中找到一个最优的决策边界（超平面），并且它有一个非常独特的特点：最大化分类边界的间隔</p><p><strong>原理：</strong></p><ul><li><p>超平面：SVM在特征空间中寻找一个超平面，将数据点分类。对于线性可分数据，超平面的方程是：<span class="math display">\[w^Tx+b=0\]</span></p></li><li><p>最大化间隔：SVM不仅寻找一个可以分开数据的超平面，还要找到那个离两类数据点最远的超平面，确保间隔最大化。这被称为最大化分类边界的间隔(Margin)。这样可以增强模型的鲁棒性，减少过拟合</p></li><li><p>支持向量：距离决策边界最近的那些数据点被称为支持向量。这些点对决策边界有最重要的影响</p></li></ul><p><strong>损失函数：</strong></p><ul><li><p>合页损失函数(HingeLoss)：是用于分类函数的损失函数，用来惩罚错误分类或分类边界附件的样本<span class="math display">\[L(y_i,f(x_i))=\max(0,1-y_if(x_i))\]</span> 其中：</p><ul><li><span class="math inline">\(y_i \in \{-1, 1\}\)</span>是样本i的真实标签(SVM通常处理二分类问题)</li><li><span class="math inline">\(f(x_i)=\mathbf{w}^\top x_i+b\)</span>是模型对样本<spanclass="math inline">\(x_i\)</span>的预测结果，表示超平面w和<spanclass="math inline">\(x_i\)</span>的内积再加上偏置b</li><li><span class="math inline">\(1-y_if(x_i)\)</span>是衡量样本离决策边界的距离</li><li>如果样本被正确分类且距离边界大于 1，损失为0；否则，损失随着样本距离边界的接近或错误分类而增加。</li></ul></li><li><p>正则化项：SVM模型的目标是找到能够最大化分类间距（margin）的超平面。因此，为了平衡分类误差和间距的最大化，损失函数通常还包括一个正则化项，用来控制模型的复杂度（即防止过拟合）。常见的正则化项是L2正则化，其形式为： <span class="math display">\[R(\mathbf{w})=\frac12\|\mathbf{w}\|^2\]</span></p></li><li><p>总损失函数： <span class="math display">\[J(\mathbf{w},b)=\frac12\|\mathbf{w}\|^2+C\sum_{i=1}^m\max(0,1-y_i(\mathbf{w}^\topx_i+b))\]</span></p><ul><li>其中：<ul><li>C 是一个超参数，用于控制正则化项和合页损失之间的权衡。较大的 C会减少分类错误，但可能导致过拟合；较小的 C会增加容错性，防止过拟合。</li><li>m 是训练样本的数量。</li></ul></li></ul></li></ul><p><strong>梯度公式：</strong></p><ul><li><p>对权重向量W的梯度： <span class="math display">\[\frac{\partialJ(\mathbf{w},b)}{\partial\mathbf{w}}=\mathbf{w}-C\sum_{i\in\mathcal{M}}y_ix_i\]</span></p></li><li><p>对偏置b的梯度： <span class="math display">\[\frac{\partial J(\mathbf{w},b)}{\partial b}=-C\sum_{i\in\mathcal M}y_i\]</span></p></li></ul><p><strong>核技巧(kernel Trick)：</strong>当数据无法通过线性超平面分割时，SVM使用核技巧将数据映射到高维空间。常见的核函数包括：</p><ul><li>多项式核(Polynomial Kernel)：将原始数据通过多项式映射到高维空间</li><li>高斯核/径向基核(RBFKernel)：将数据点投影到无穷维空间，使得非线性数据在高维空间中变得线性可分</li></ul><h3 id="支持向量机线性不可分">3.3 支持向量机(线性不可分)</h3><p><strong>概述：</strong> 松弛变量(SlackVariable)是用来处理非线性可分情况的一种机制，它通过引入松弛变量允许一定程度的分类错误，从而使SVM能够在线性不可分的情形下仍然能找到一个较优的分类超平面</p><p><strong>定义：</strong> 假设训练样本为<spanclass="math inline">\((x_i, y_i)\)</span>，其中<spanclass="math inline">\(x_i\)</span>是输入特征，<spanclass="math inline">\(y_i \in {-1,1}\)</span>是类比额标签。SVM的分类条件是 ： <spanclass="math display">\[y_i(w \cdot x_i + b) \geq 1\]</span> 对于线性不可分的情况，引入松弛变量<spanclass="math inline">\(\xi_i \geq 0\)</span>，允许某些点违反上述条件：<span class="math display">\[y_i(w \cdot x_i + b) \geq 1 - \xi_i\]</span> 这里：</p><ul><li><span class="math inline">\(\xi_i = 0\)</span>：点<spanclass="math inline">\(x_i\)</span>被正确分类且位于分类边界之外</li><li>$0 &lt; _i <spanclass="math inline">\(：点\)</span>x_i$被正确分类且位于分类边界之内</li><li><span class="math inline">\(\xi_i &gt; 1\)</span>：点<spanclass="math inline">\(x_i\)</span>被错误分类</li></ul><p><strong>优化目标(软边界SVM)：</strong></p><p>引入松弛变量后，SVM的优化目标需要平衡两部分：</p><ul><li>最大化边界(Margin)，即最小化<spanclass="math inline">\(\frac{1}{2}||w||^2\)</span></li><li>最小化分类错误的代价，即最小化<spanclass="math inline">\(\sum_i\xi_i\)</span></li></ul><p>最终目标函数为： <span class="math display">\[\mathop{max}\limits_{w,b,\xi} \frac{1}{2}||w||^2 + C\sum_i\xi_i\]</span> C 是正则化参数，用来权衡分类边界的宽度与分类错误的代价。</p><ul><li>较大的 C：更注重减少分类错误，容忍较小的边界。</li><li>较小的 C：更注重增加边界宽度，容忍更多的分类错误。</li></ul><h3 id="梯度下降-1">3.4 梯度下降</h3><p>是一种用于优化线性回归模型的迭代方法，通过计算损失函数的梯度，并沿着梯度的反方向迭代更新参数<spanclass="math inline">\(W\)</span>，逐步逼近最优解。梯度下降有三种主要变体：</p><ul><li>批量梯度下降(Batch Gradient Descent, BGD)</li><li>随机梯度下降(Stochastic Gradient Descent, SGD)</li><li>随机批量梯度下降(Mini-Batch Gradient Descent, MBGD)</li></ul><p><strong>样本数的对梯度公式的影响：</strong></p><ul><li>如果不除以样本数，计算得到的梯度是累计的梯度，也就是每个样本的误差对权重的累积影响</li><li>如果除以样本数，计算得到的是平均梯度，每次更新会使用平均误差对权重进行更新</li></ul><p><strong>参数更新公式：</strong> <span class="math display">\[W=W-\eta\nabla L(W)\]</span> 其中：</p><ul><li><span class="math inline">\(W\)</span>是参数向量</li><li><spanclass="math inline">\(\eta\)</span>是学习率，控制更新的步长</li><li>损失函数<spanclass="math inline">\(J(W)\)</span>，在线性回归中有介绍，不同的模型可以选取不同的损失函数</li><li><span class="math inline">\(\nabla L(W)\)</span>是损失函数<spanclass="math inline">\(J(W)\)</span>对参数W的梯度（也就是求导，一般来说，如果损失函数是每个样本损失的平均值，也就是除以了样本数m，那损失的函数的梯度就不再需要除以样本数m了</li></ul><h4 id="批量梯度下降">3.4.1 批量梯度下降</h4><p><strong>概述：</strong> 在每次迭代中，使用整个训练集来计算梯度</p><p><strong>过程：</strong></p><ol type="1"><li>首先，初始化模型参数</li><li>定义损失函数<span class="math inline">\(J(W)\)</span></li><li>求解损失函数的导数，也就是损失函数的梯度函数<spanclass="math inline">\(L(W)\)</span></li><li>根据上面给的参数更新公式更新W</li><li>重复迭代</li></ol><p><strong>优点：</strong></p><ul><li>更新稳定，避免了由样本噪声引起的波动</li><li>收敛到全局最优解，梯度方向更精确</li></ul><p><strong>缺点：</strong></p><ul><li>计算成本高</li><li>不适合大规模数据集</li></ul><h4 id="随机梯度下降">3.4.2 随机梯度下降</h4><p><strong>概述：</strong> 在每次迭代中，只使用一个样本计算梯度</p><p><strong>SGD优缺点：</strong></p><ul><li>优点：<ul><li>效率高：对于大规模数据集，SGD不需要每次都遍历整个数据集，它每次只对一个样本进行更新，使得计算更快</li><li>内存友好：由于它只需要处理一个样本，内存消耗相对较低，适合处理大数据</li><li>在线学习：SGD可以随着新数据的到来在线更新模型，而不需要每次都从头开始训练</li></ul></li><li>缺点：<ul><li>噪声较大：由于每次更新使用的是单个样本，更新方向可能不是全局最优，因此SGD的收敛路径往往比较噪声且不稳定</li><li>需要调整学习率：学习率<spanclass="math inline">\(\eta\)</span>的选择至关重要。如果学习率过大，参数更新可能会错过最优点；如果学习率过小，收敛速度将非常慢</li></ul></li></ul><p><strong>学习率衰减策略：</strong></p><p>为了解决噪声问题，常见的做法是在训练过程中逐渐减低学习率，这种方法可以在训练初期进行较大步长的更新，使得模型快速接近最优解，而在后期逐渐减小步长，使得模型在最优解附件收敛</p><p>学习率衰减公式的常见形式是： <span class="math display">\[\eta_t = \frac{\eta_0}{1 + \text{decay_rate} \cdot t}\]</span> 其中：</p><ul><li><span class="math inline">\(\eta_0\)</span>是初始学习率</li><li><span class="math inline">\(t\)</span>是当前的迭代次数</li><li><spanclass="math inline">\(\text{decay_rate}\)</span>是学习率的衰减系数</li></ul><p><strong>伪代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">初始化 W<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):  <span class="hljs-comment"># m是样本数量</span><br>        随机选取一个样本 (x_i, y_i)<br>        计算该样本的梯度： grad = x_i * (x_i W - y_i)<br>        取负梯度方向更新参数： W = W - η * grad<br>        记录训练集或验证集的损失<br></code></pre></td></tr></table></figure><h4 id="批量随机梯度下降">3.4.3 批量随机梯度下降</h4><p><strong>概述：</strong> 每次使用一小批随机样本计算梯度</p><p><strong>过程：</strong></p><ol type="1"><li><p>初始化权重W和b</p></li><li><p>选择批量大小B（比如32，64等</p></li><li><p>每次迭代时，从训练集中随机抽取一批样本，计算该批样本上的损失函数梯度，然后更新权重：<span class="math display">\[W=W-\eta\nabla L(W)\]</span> 其中<span class="math inline">\(\eta\)</span>是学习率， <spanclass="math inline">\(\eta\nabla L(W)\)</span>是对权重的梯度</p></li></ol><p><strong>优点：</strong></p><ul><li>在每次更新时引入随机性，避免陷入局部最优解</li><li>更新效率较高，能在大规模数据集上加速训练</li><li>在批量计算中还可以利用并行化处理，进一步提高效率</li></ul><h3 id="多类别分类问题">3.5 多类别分类问题</h3><p><strong>概述：</strong> Multi-class classification是指预测一个实例属于多个类别中的某一个类别的问题。与二分类(BinaryClassification)不同，二分类问题只有两个类比额，而多类别分类问题有三个或更多类比</p><h4 id="问题定义">3.5.1 问题定义</h4><p>给定一个包含n个样本的数据集，每个样本有m个特征，并且每个样本都属于k个类别中的某一个类别。目标是构建一个分类模型，能够根据输入特征预测该样本的类别</p><h4 id="常见的多类别分类方法">3.5.2 常见的多类别分类方法</h4><p><strong>一对多(One-vs-Rest, OvR)/一对其他(One-vs-All,OvA)：</strong></p><ul><li>原理：这种方法将多类别问题转换为多个二分类问题。对于每一个类别，都训练一个二分类模型，该模型用于判断样本是否属于该类别（”是“或”不是“）。最终预测结果是选择得分最高的类别<ul><li>假设有k个类别，对于每个类别i，构建一个二分类模型<spanclass="math inline">\(h_i(x)\)</span>，其输出是”属于类别i“或”不属于类别i“</li><li>在预测时，对于每个类别，计算其分类模型的输出得分，最终选择得分最高的类别作为预测类别</li></ul></li><li>优缺点：<ul><li>优点：实现简单，能够与现有的二分类模型结合（如逻辑回归、支持向量机）</li><li>缺点：如果类别数很大，每个类别需要训练一个二分器。可能会导致训练时间和计算开销增加</li></ul></li></ul><p><strong>一对一(One-vs-One, OvO)：</strong></p><ul><li>原理：与一对多方法不同，一对一方法将多类别问题转换为多个二分类问题，但这里每对类别都会训练一个分类器，也就是说，对于每两个类别i和j，训练一个二分类模型<spanclass="math inline">\(h_{i,j}(x)\)</span>，用于判断一个样本是属于类别i还是类别j<ul><li>对于k个类别，所有可能的类别对都会训练一个分类器，总共需要训练<spanclass="math inline">\(\frac{k(k-1)}{2}\)</span>个分类器</li><li>在预测时，所有的二分类器都会给出一个预测类别，最终通过投票机制选择的票最多的类别作为最终分类结果</li></ul></li><li>优缺点：<ul><li>优点：可以利用现有的二分类模型，并且每个模型只需处理少量类别之间的区别</li><li>缺点：需要训练的分类器数量较多，计算开销大</li></ul></li></ul><p><strong>直接多类别分类(Direct Multi-classClassification)：</strong></p><ul><li>原理：这种方法直接训练一个多类别分类器，避免将问题分解为多个二分类问题。常见的多类别分类算法包括：<ul><li>Sofrmax回归：这是逻辑回归的扩展，适用于多类别分类问题。模型的输出是每个类别的概率，预测时选择概率最高的类别</li><li>多类别支持向量机(C-SVC with multi-classstrategy)：SVM本身是二分类算法，但可以通过直接使用多类别支持向量机来解决多类别问题，如使用”一对一“策略或”一对多“策略</li><li>决策树：决策树自然适应多类别分类问题，因为每个节点的决策可以基于多个类别进行选择</li></ul></li><li>优缺点：<ul><li>优点：在训练时直接处理多类别问题，不需要分解为多个二分类问题，计算上通常较为高效</li><li>缺点：对于复杂的多类别问题，可能需要更复杂的模型和调优</li></ul></li></ul><p><strong>基于神经网络的方法：</strong></p><ul><li><p>原理：神经网络可以自然地处理多类别分类问题，特别是通过使用softmax激活函数将网络的输出转换为每个类别的概率分布，具体做法是在网络的最后一层使用softmax激活函数，将网络的输出映射到每个类别的概率值</p><ul><li><p>softmax函数：softmax将一个向量转换为一个概率分布，输出中每个元素的值都在0到1之间，且所有元素的和为1，具体公式为：<span class="math display">\[\operatorname{Softmax}\left(z_{i}\right)=\frac{e^{z_{i}}}{\sum_{j}e^{z_{j}}}\]</span> 其中<spanclass="math inline">\(z_i\)</span>是模型输出的第i个类别的得分</p></li><li><p>在训练时，使用交叉熵损失函数来优化模型的参数，目标是最小化真实类别与预测类别之间的差异</p></li></ul></li><li><p>优缺点：</p><ul><li>优点：神经网络能够自动提取特征并进行非线性映射，适合复杂的多类别问题</li><li>缺点：训练过程可能需要更多的数据和计算资源</li></ul></li></ul><h4 id="性能评估">3.5.3 性能评估</h4><p><strong>评估指标：</strong></p><ul><li>准确率(Accuracy)：所有正确分类的样本占总样本的比例</li><li>宏平均(MacroAverage)：对每个类别计算精度(precision)、召回率(recall)和F1-score，然后取这些指标的平均值</li><li>加权平均(WeightedAverage)：对每个类别的精度、召回率和F1-score计算加权平均，权重是类别的支持度（样本数）</li><li>混淆矩阵(ConfusionMatrix)：对于每个类别，记录预测正确和错误的样本数，混淆矩阵帮助分析分类器的错误模式</li></ul><h2 id="逻辑回归和多分类逻辑回归">4. 逻辑回归和多分类逻辑回归</h2><h3 id="逻辑回归">4.1 逻辑回归</h3><p><strong>概述：</strong>是一种用于二分类问题的线性模型，尽管名字里有回归，它实际上用于分类任务。可以说是线性分类的一种特例，但它采用了概率的方式进行分类决策。</p><p><strong>核心思想：</strong></p><p>逻辑回归的目标是通过学习到的模型预测某个输入属于某个类别的概率。其基本形式是将线性回归的输出通过Sigmoid函数转换为一个介于0到1之间的概率值</p><ul><li><p>线性部分：给定一个输入向量X和模型参数W，线性部分的输出为： <spanclass="math display">\[z=W^TX+b\]</span> 这个W是权重向量，b是偏置</p></li><li><p>Sigmoid函数：将线性输出z转换为概率值p： <spanclass="math display">\[p=\frac1{1+e^{-z}}\]</span> 这个p表示预测结果为正类的概率</p></li><li><p>损失函数：逻辑回归的损失函数通常是交叉熵损失，用于评估模型预测的概率分布和实际标签之间的差异：<span class="math display">\[J(W)=-\frac1m\sum_{i=1}^m\left[y_i\log(\hat{y}_i)+(1-y_i)\log(1-\hat{y}_i)\right]\]</span> 其中，<spanclass="math inline">\(\hat{y}_i\)</span>是第i个样本的预测概率，<spanclass="math inline">\(y_i\)</span>是实际标签，m是样本数</p></li><li><p>Logistic回归的梯度公式： <span class="math display">\[\nabla L(W)=X^T(\text{sigmoid}(XW)-y)\]</span></p></li><li></li></ul><p><strong>训练逻辑回归的过程：</strong>通过最小化损失函数的值，调整权重W和偏置b。最常用的优化算法是梯度下降，其中包括不同的变体。</p><h3 id="多分类逻辑回归">4.2 多分类逻辑回归</h3><p><strong>基本原理：</strong>基于softmax函数，将输入样本映射到多个类别的概率分布。softmax函数的公式如下：<span class="math display">\[P(y=c|X) = \frac{exp(W_c^TX + b_c)}{\sum_{k=1}^Kexp(w_k^TX+b_k)}\]</span></p><ul><li>x是输入样本的特征向量</li><li>y是类别标签，取值范围为{1,2,...,K}，K是类别数</li><li><span class="math inline">\(w_c\)</span>和<spanclass="math inline">\(b_c\)</span>是类别c的权重向量和偏置</li><li><spanclass="math inline">\(P(y=c|X)\)</span>是样本属于类别c的概率</li></ul><p><strong>损失函数：</strong>为了优化模型，多分类逻辑回归使用交叉熵损失函数： <spanclass="math display">\[\mathcal{L}=-\frac{1}{N}\sum_{i=1}^N\sum_{c=1}^K(y_i=c)logP(y_i=c|X_i)\]</span></p><ul><li>N是样本数量</li><li>1(<spanclass="math inline">\(y_i=c\)</span>)是指示函数，当样本i的真实标签为c时取值为1，否则为0</li><li><spanclass="math inline">\(P(y_i=c|X_i)\)</span>时通过softmax函数计算的概率</li></ul><p><strong>优化方法：</strong>通过梯度下降或其变种（如SGD、Adam等）优化损失函数，调整参数w和b来最小化误差</p><p><strong>特点：</strong></p><ul><li>概率输出：模型输出类别概率，提供了不确定性信息</li><li>可解释性强：权重w的大小和方向可以解释特征对分类的影响</li><li>计算效率较高：适合小规模和中等规模的数据集</li></ul><h2 id="欠拟合过拟合交叉验证">5. 欠拟合、过拟合、交叉验证</h2><h3 id="欠拟合和过拟合">5.1 欠拟合和过拟合</h3><p><strong>欠拟合(Underfitting)：</strong></p><ul><li>loss_train和loss_val都很高，且无法持续下降到理想的范围。欠拟合表明模型对训练数据的学习不足，可能是由于模型过于简单（例如参数太少，模型不够复杂）</li><li>解决方案：增加模型复杂度（例如增加特征、增加模型层数或参数），或者使用更强的模型</li></ul><p><strong>过拟合(Overfitting)：</strong></p><ul><li>loss_traing持续下降，但loss_val开始上升，这是典型的过拟合现象，意味着模型在训练集上表现良好，但在验证集上的表现变差，这表明模型在过度拟合训练集的细节和噪声，而没有学到验证集中的一般规律</li><li>解决方案：<ul><li>使用正则化方法来限制模型的复杂度</li><li>增加训练集数据量或使用数据增强技术</li><li>提前停止训练，即当loss_val开始上升时停止训练，以防止过拟合</li></ul></li></ul><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241127162054986.png" class=""><h3 id="偏差-方差权衡">5.2 偏差-方差权衡</h3><p><strong>概述：</strong> 用于描述模型的复杂度与预测误差之间的关系</p><p><strong>偏差(Bias)：</strong>描述了模型的预测值与真实值之间的偏离成都。反映了模型对数据的系统性错误，通常是由于模型假设过于简单导致的</p><ul><li>高偏差：模型无法很好地捕捉数据的复杂结果（欠拟合）<ul><li>例如，用线性模型拟合非线性数据，模型无法表达数据中的非线性关系</li></ul></li><li>低偏差：模型能够准确地拟合训练数据，捕捉了数据的主要模式</li></ul><p><strong>方差(Variance)：</strong>描述了模型对数据变化的敏感性，反映了模型的预测结果在不同的训练数据集上的波动性</p><ul><li>高方差：模型过于复杂，过度拟合训练数据，对训练集中的噪声特别敏感(过拟合)<ul><li>例如，用高阶多项式拟合简单线性关系的数据，模型可能对训练集表现和那后，但对测试集表现很差</li></ul></li><li>低方差：模型对数据的变化不敏感，预测稳定</li></ul><p><strong>偏差-方差分解：</strong> 总误差 =偏差<sup>2</sup>+方差+噪声</p><ul><li>偏差：模型假设的错误，与模型复杂度负相关</li><li>方差：模型对数据扰动的敏感性，与模型复杂度正相关</li><li>噪声：数据中的固有随机性，不可通过建模减少</li></ul><p><strong>偏差-方差权衡：</strong></p><ul><li>简单模型</li><li>复杂模型</li><li>最佳模型</li></ul><h3 id="交叉验证">5.3 交叉验证</h3><p><strong>主要目的：</strong></p><ul><li>评估模型的泛化能力：交叉验证可以更全面地评估模型在未见数据上的表现，避免仅依赖单一训练集和测试集可能导致的评估偏差</li><li>减少过拟合风险：如果模型在特定训练集上表现良好，但在其他数据上效果不佳，可能是过拟合的表现。交叉验证通过多次训练和验证，帮助检测和减少过拟合的风险</li><li>优化模型参数：在交叉验证的过程中，可以调整模型的超参数，选择在不同的数据子集上表现最优的参数组合，从而提升模型的整体性能</li></ul><p><strong>常用的基奥查验证方法：</strong></p><ul><li>留出法(HoldoutMethod)：将数据集随机划分为训练集和测试集，通常按一定比例划分</li><li>K折交叉验证(K-FoldCross-Validation)：将数据集划分为K个子集，每次使用其中一个子集作为验证集，其余K-1个子集作为训练集，重复K次，确保每个子集都被用作验证集一次</li><li>留一法(Leave-One-Out Cross-Validation,LOOCV)：当数据集较小，每次将一个样本作为验证集，其余样本作为训练集，重复进行，直到每个样本都被用作训验证集一次</li></ul><h2 id="非线性机器学习与集成方法">6. 非线性机器学习与集成方法</h2><h3 id="决策树">6.1 决策树</h3><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241127202130265.png" class=""><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241127202138788.png" class=""><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241127202948289.png" class=""><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241127202955760.png" class=""><img src="/2024/11/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20241127203005855.png" class=""><h3 id="集成学习">6.2 集成学习</h3><p><strong>概述：</strong>通过组合多个模型的预测结果来提高整体性能。核心思想是多个弱学习器(WeakLearners)结合起来可以形成一个强学习器(Strong Learner)</p><p><strong>核心思想：</strong></p><ul><li>多样性：通过不同的模型或数据生成方式，确保其模型具有差异性</li><li>组合策略：通过投票、加权平均或其他方法，将多个模型的预测结果进行融合</li><li>提高性能：集成学习通常能够降低模型的方差和偏差，从而提高准确性和鲁棒性</li></ul><p><strong>分类：</strong></p><ul><li>Bagging：<ul><li>全称：Bootstrap Aggregation</li><li>原理：<ul><li>从训练集随机采样（有放回地抽样，生成多个子数据集）</li><li>每个子数据集训练一个模型（通常是同一种模型，如决策树）</li><li>最终通过平均（回归）或投票（分类）的方式融合多个模型的预测结果</li></ul></li><li>特点：<ul><li>减少方差，提升模型的稳定性</li><li>基于独立训练的模型，易于并行化</li></ul></li><li>代表算法：随机森林(Random Forest)</li><li>示例：数据集有100个样本，Bagging会随机抽样生成多个大小为100的数据子集，每个子集训练一个决策树模型，最后通过多数投票决定分类结果</li></ul></li><li>Boosting：<ul><li>原理：<ul><li>通过逐步训练模型，将重点放在之前模型容易出错的样本上</li><li>每轮训练一个模型，并更根据该模型的错误情况调整样本的权重（错误的样本权重增加）</li><li>最终通过加权平均的方式组合多个模型</li></ul></li><li>特点：<ul><li>减少偏差，提升模型的预测能力</li><li>各模型依赖顺序训练，串行化了</li></ul></li><li>代表算法：AdaBoost，Gradient Boosting，XGBoost，LightGBM</li><li>示例：初始化所有样本的权重相同，训练第一个模型后，错误分类的样本权重增加；再用调整后的权重训练第二个模型，如此迭代，最后通过加权投票或加权求和得到最终结果</li></ul></li><li>Stacking<ul><li>原理：<ul><li>使用多个不同类型的模型作为基础学习器</li><li>这些基础学习器的输出作为输入，训练一个"元学习器"来学习如何组合这些模型</li></ul></li><li>特点：<ul><li>灵活性强，可以结合多种类型的基模型</li><li>通常需要交叉验证来防止过拟合</li></ul></li><li>代表算法：无固定框架算法，常见于竞赛（如Kaggle )</li><li>示例：使用逻辑回归、随机森林、支持向量机作为基学习器，将它们的预测输出输入到一个线性回归模型中，最终生成预测结果</li></ul></li></ul><h2 id="无监督学习聚类问题">7. 无监督学习：聚类问题</h2><h3 id="聚类基础">7.1 聚类基础</h3><p><strong>概述：</strong>是一种无监督学习方法，目的是将一组数据点划分为若干个子集（称为簇，cluster），使得同一个簇内的数据点具有较高的相似性，而不同簇之间的数据点差异显著。聚类应用于数据没有明确标签的场景，例如客户细分、文本聚类、图像分割等</p><p><strong>特点</strong></p><ul><li>无监督学习：没有标签，完全依赖数据的内在特征</li><li>相似性衡量：通过某种距离度量（欧几里得距离、余弦相似度等）来判断数据点之间的相似性）</li><li>簇的定义：不同算法对簇的定义可能不同，例如基于密度、基于距离或基于概率分布等</li></ul><p><strong>常见算法：</strong>K-Means算法、层次聚类、基于密度的聚类（DBSCAN）、高斯混合模型（GaussiaanMixture Model, GMM）</p><p><strong>评价指标：</strong></p><ul><li>内部指标：<ul><li>只是用数据本身和聚类结果，不依赖外部标签</li><li>常见指标：<ul><li>轮廓系数(Silhouette Coefficient)：<ul><li>衡量簇内点的紧密性和簇间的分离度</li><li>值范围：[-1, 1]，越接近1表明聚类效果越好</li></ul></li><li>簇内平方和(Inertia)：簇内点到簇中心的总平方和，值越小越好</li></ul></li></ul></li><li>外部指标：<ul><li>如果有标签，可以根据真实标签和聚类结果进行比较</li><li>常见指标：<ul><li>调整兰德指数(ARI)：真实标签和聚类结果的一致性</li><li>归一化互信息(NMI)：聚类结果和标签的互信息值</li></ul></li></ul></li></ul><p><strong>应用场景：</strong></p><ul><li>文本分析：文本聚类（新闻分类、主题检测）</li><li>图像处理：图像分割、相似图片检索</li><li>市场营销：客户细分，发现具有相似购买行为的群体</li><li>生物信息学：基因表达数据分析，发现基因簇</li><li>推荐系统：通过聚类用户行为数据，推荐类似内容</li></ul><h3 id="k-means聚类重点">7.2 K-Means聚类【重点】</h3><p><strong>概述：</strong>用于将数据集划分为k个cluster，以最小化簇内的样本与簇中心之间的距离。每个簇由其质心（中心点）表示</p><p><strong>主要思想：</strong></p><ul><li><p>将数据集划分为k个cluster ，使得：</p><ul><li>同一cluster内的数据点批次相似</li><li>不同cluster之间的数据点差异较大</li></ul></li><li><p>使用一种迭代优化方法最小化簇内平方和，即： <spanclass="math display">\[J=\sum_{i=1}^k\sum_{x\in C_i}||x-\mu_i||^2\]</span></p><ul><li><span class="math inline">\(C_i\)</span>：第i个cluster</li><li><span class="math inline">\(\mu_i\)</span>：第i个簇的中心</li><li><spanclass="math inline">\(||x-\mu_i||^2\)</span>：数据点x到簇中心的欧几里得距离</li></ul></li></ul><p><strong>算法流程：</strong></p><ol type="1"><li>初始化：随机选取k个点作为初始簇的中心点（质心）</li><li>分配样本：对于每个数据点，计算它到k个簇中心的距离，并将其分配到最近的簇</li><li>更新簇中心：重新计算每个簇的中心顶，作为该簇内所有点的均值</li><li>重复迭代：重复步骤2、3，直到簇中心不再发生变化，或者达到最大迭代粗疏</li><li>输出</li></ol><p><strong>示例：</strong> 数据集={(1,1),(2,1),(4,3),(5,4)}</p><ol type="1"><li>初始化：随机选择k=2个点作为初始化簇中心，例如(1,1)和(5,4)</li><li>计算每个点到中心的距离并分配簇<ol type="1"><li>点(1,1)(2,1)更接近(1,1)</li><li>点(4,3)(5,4)更接近(5,4)</li></ol></li><li>更新簇中心：<ol type="1"><li>第一个簇的中心更新为(1.5, 1)</li><li>第二个簇的中心更新为(4.5, 3.5)</li></ol></li><li>重复步骤2，3直到中心点不再变化</li></ol><p><strong>选择合适的k值：</strong></p><ul><li>肘部法则(Elbow Method)：<ul><li>绘制簇内平方和随k变化的曲线</li><li>选择肘部点作为最优的k值</li></ul></li><li>轮廓系数：<ul><li>衡量样本在簇内的紧密性和簇间的分离度</li><li>取轮廓系数最大的k值</li></ul></li></ul><h3 id="层次聚合聚类hac">7.3 层次聚合聚类(HAC)</h3><p><strong>概述：</strong>是一种基于树状结构的聚类方法，旨在通过递归地合并或分裂簇的方式，将数据组织成一个层次结构（通常表示为树状图）</p><p><strong>策略：</strong></p><ul><li>自底向上（层次聚合， agglomerative）：<ul><li>每个数据点开始作为一个独立的簇</li><li>逐步将最相似的簇合并，直到所有的数据点都属于一个簇</li><li>适用于数量较小的情况</li></ul></li><li>自顶向下（层次分裂，divisive）：<ul><li>从一个包含所有数据点的簇开始</li><li>逐步将簇分裂成更小的簇，直到每个簇只包含一个数据点</li></ul></li></ul><p><strong>算法步骤：</strong></p><ol type="1"><li>初始化：将每个数据点视为单独的一个簇</li><li>计算距离：计算每对簇之间的距离（使用特定的距离度量方法）</li><li>合并最近的簇：找到距离最近的两个簇，将它们合并为一个簇</li><li>更新距离矩阵：重新计算新簇与其他簇之间的距离</li><li>重复：重复步骤3和步骤4，直到所有的点被合并为一个簇，或者达到指定的递归次数</li></ol><p><strong>簇间的距离度量方法：</strong></p><ul><li>最小距离（单连接，Single Linkage）：<ul><li>定义：两个簇中距离最近的点之间的距离</li><li>容易受到噪声影响，可能产生链式簇</li></ul></li><li>最大距离（完全连接，Complete Linkage）：<ul><li>定义：两个簇中距离最远的点之间的距离</li><li>倾向于生成紧凑的、球形的簇、但可能分割自然的群体</li></ul></li><li>平均距离（Average Linkage）：<ul><li>定义：每个簇中所有点对之间平均距离的加权平均</li><li>在链式簇和紧密簇之间的表现较为平衡</li></ul></li><li>质心距离（Centroid Linkage）：<ul><li>定义：两个簇的质心之间的距离</li><li>敏感于簇内样本分布变化</li></ul></li><li>Ward方法：<ul><li>基于最小化簇内的平方误差</li><li>更倾向于生成大小相似的簇，适合数据分布均匀的情况</li></ul></li></ul><h2 id="无监督学习主成分分析">8. 无监督学习：主成分分析</h2><p><strong>概述：</strong>PCA是一种用于数据降维的技术，通过寻找数据中最大方差方向的线性组合，将高维数据映射到一个低维空间，同时尽可能保留数据的主要信息</p><p><strong>核心思想：</strong> PCA的目标是：</p><ul><li>将数据投影到新的正交坐标系（主成分轴），这些轴按照数据的防擦好大小排序</li><li>最终保留较少的主成分，用于近似原始数据，从而减少数据的纬度</li></ul><p>在降维的同时，PCA通过去除冗余特征和噪声提高模型的效率和泛化能力</p><p><strong>PCA的数学步骤：</strong></p><ol type="1"><li><p>数据标准化：为了消除量纲的影响，PCA的第一步通常是对数据进行标准化（如零均值和单位方差标准化）。假设数据集X的大小为<spanclass="math inline">\(n \times d\)</span>其中n是样本数，d是特征数，对每个特征数<spanclass="math inline">\(x_j\)</span>： <span class="math display">\[x_j&#39;=\frac{x_j - \mu_j}{\delta_j}\]</span> 其中<span class="math inline">\(\mu_j\)</span>是特征<spanclass="math inline">\(x_j\)</span>的均值，<spanclass="math inline">\(\delta_j\)</span>是标准差</p></li><li><p>计算协方差矩阵：计算标准化后的数据的协方差矩阵<spanclass="math inline">\(\sum\)</span>： <span class="math display">\[\sum = \frac{1}{n-1}X^TX\]</span> 协方差矩阵描述了特征之间的线性相关性</p></li><li><p>求解特征值和特征向量：计算协方差矩阵的特征值和特征向量： <spanclass="math display">\[\sum v = \lambda v\]</span></p><ul><li>特征向量v表示新的坐标轴方向（即主成分方向）</li><li>特征值<spanclass="math inline">\(\lambda\)</span>表示沿主成分方向的方差大小</li></ul></li><li><p>选择主成分：按照特征值大小对特征向量排序，选择前k个对应的特征向量，形成主成分矩阵<spanclass="math inline">\(W_k\)</span></p></li><li><p>降维：将原始数据X投影到主成分矩阵<spanclass="math inline">\(W_k\)</span>上： <span class="math display">\[Z=XW_k\]</span> Z是降维后的数据</p></li></ol><p><strong>主成分解释：</strong></p><ul><li>第一主成分：数据方差最大的方向， 最能反映数据的变化</li><li>第二主成分：与第一主成分正交，反映剩余的次要变化</li></ul><p><strong>优点：</strong></p><ul><li>降维效果显著</li><li>去噪能力强</li><li>解释性强</li></ul><p><strong>缺点：</strong></p><ul><li>线性假设</li><li>信息丢失</li><li>易受异常值影响</li></ul><p><strong>应用场景：</strong></p><ul><li>数据预处理：用于特征选择和去除冗余特征</li><li>可视化：将高维数据降到2D或3D空间进行可视化</li><li>压缩：通过降维实现数据压缩</li><li>去噪：舍弃低方差成分，降低数据噪声</li><li>推荐系统</li></ul>]]></content>
    
    
    <categories>
      
      <category>大学课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门009——漫反射在片段着色器中的应用</title>
    <link href="/2024/11/20/OpenGL%E5%85%A5%E9%97%A8009%E2%80%94%E2%80%94%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%9C%A8%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/11/20/OpenGL%E5%85%A5%E9%97%A8009%E2%80%94%E2%80%94%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%9C%A8%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本节将在片段着色器中应用漫反射</p><h1 id="一些概念">一些概念</h1><h2 id="漫反射">漫反射</h2><p><strong>概述：</strong>描述的是粗糙表面对光的反射，反射的光线相关各个方向均匀分布，与视角无光</p><p><strong>特点：</strong></p><ul><li>亮度取决于光源的方向和物体表面法向量之间的夹角</li><li>适合模拟不光滑的表面，例如木材、纸张等</li><li>视角变化不会影响光的强度</li></ul><p><strong>公式（朗伯余弦定律）：</strong> <span class="math display">\[I_d = k_d \cdot I_{light} \cdot max(0, L \cdot N)\]</span></p><ul><li><span class="math inline">\(I_d\)</span>：物体表面的漫反射亮度</li><li><spanclass="math inline">\(k_d\)</span>：漫反射的反射系数(0到1之间)</li><li><span class="math inline">\(I_{light}\)</span>：光源强度</li><li>L：指向光源的单位向量</li><li>N：表面的法向量</li></ul><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 使用环境光</p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><p><strong>源码：</strong> <ahref="https://github.com/1037827920/OpenGL-Learn-Program/tree/main/009-diffuse-reflection">OpenGL-Learn-Program/009-diffuse-reflectionat main · 1037827920/OpenGL-Learn-Program</a></p><h2 id="dependencies">dependencies</h2><p>主要改动shader.vs和shader.fs，其他文件看<ahref="https://github.com/1037827920/OpenGL-Learn-Program/tree/main/009-diffuse-reflection/dependencies">这里</a></p><h3 id="shadervs">shadervs</h3><p>立方体的顶点着色器源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vs">#version 330 core<br>layout (location = 0) in vec3 vPos;<br>layout (location = 1) in vec2 vTexCoord;<br>layout (location = 2) in vec3 vNormal;<br><br>uniform mat4 model;<br>uniform mat4 view;<br>uniform mat4 projection;<br><br>out vec2 TexCoord;<br>out vec3 Normal;<br>out vec3 FragPos;<br><br>void main()<br>&#123;<br>    gl_Position = projection * view * model * vec4(vPos, 1.0f);<br><br>    TexCoord = vTexCoord;<br>    Normal = mat3(transpose(inverse(model))) * vNormal;<br>    FragPos = vec3(model * vec4(vPos, 1.0f));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="shader.fs">shader.fs</h3><figure class="highlight fs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs fs">#version <span class="hljs-number">330</span> core<br><br><span class="hljs-keyword">in</span> vec2 TexCoord;<br><span class="hljs-comment">// 表示片段的法向量，用于确定片段相对于光源的角度</span><br><span class="hljs-keyword">in</span> vec3 Normal;<br><span class="hljs-comment">// 表示片段在世界空间中的位置，用于确定片段相对于光源的距离</span><br><span class="hljs-keyword">in</span> vec3 FragPos;<br><br><span class="hljs-comment">// 第一个纹理</span><br>uniform sampler2D texture0;<br><span class="hljs-comment">// 第二个纹理</span><br>uniform sampler2D texture1;<br><span class="hljs-comment">// 混合比例</span><br>uniform float blendRatio;<br><span class="hljs-comment">// 立方体本身的环境光 光源颜色</span><br>uniform vec3 lightColor;<br><span class="hljs-comment">// 点光源位置</span><br>uniform vec3 lightPos;<br><br>out vec4 FragColor;<br><br><span class="hljs-keyword">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 环境光强度</span><br>    float ambientStrength <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span>;<br>    <span class="hljs-comment">// 计算环境光分量</span><br>    vec3 ambient <span class="hljs-operator">=</span> ambientStrength <span class="hljs-operator">*</span> lightColor;<br><br>    <span class="hljs-comment">// 标准化法向量</span><br>    vec3 norm <span class="hljs-operator">=</span> normalize(Normal);<br>    <span class="hljs-comment">// 计算片段位置和光源位置之间的方向向量</span><br>    vec3 lightDir <span class="hljs-operator">=</span> normalize(lightPos <span class="hljs-operator">-</span> FragPos);<br>    <span class="hljs-comment">// 计算光源到片段的距离</span><br>    float distance <span class="hljs-operator">=</span> length(lightPos <span class="hljs-operator">-</span> FragPos);<br>    <span class="hljs-comment">// 计算衰减</span><br>    float attenuation <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span> <span class="hljs-operator">/</span> (distance <span class="hljs-operator">*</span> distance);<br>    <span class="hljs-comment">// 计算漫反射分量</span><br>    float diff <span class="hljs-operator">=</span> max(dot(norm, lightDir), <span class="hljs-number">0.0</span>);<br>    vec3 diffuse <span class="hljs-operator">=</span> diff <span class="hljs-operator">*</span> lightColor <span class="hljs-operator">*</span> attenuation;<br> <br>    <span class="hljs-comment">// 最终颜色结果</span><br>    vec3 lighting <span class="hljs-operator">=</span> ambient <span class="hljs-operator">+</span> diffuse;<br><br>    <span class="hljs-comment">// 将两个纹理混合并乘以环境光分量</span><br>    FragColor <span class="hljs-operator">=</span> mix(texture(texture0, TexCoord), texture(texture1, TexCoord), blendRatio) <span class="hljs-operator">*</span> vec4(lighting, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器源码的输出会作为片段着色器源码的输入</p><h2 id="utils">utils</h2><p>修改的代码文件只有和Cube.cpp，其他可以看<ahref="https://github.com/1037827920/OpenGL-Learn-Program/tree/main/009-diffuse-reflection/utils">这里</a></p><h3 id="cube.cpp">Cube.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Cube.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><br>Cube::<span class="hljs-built_in">Cube</span>(GLFWWindowFactory* window) : <span class="hljs-built_in">window</span>(window) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;shader = <span class="hljs-built_in">Shader</span>(<span class="hljs-string">&quot;shader.vs&quot;</span>, <span class="hljs-string">&quot;shader.fs&quot;</span>);<br>    <span class="hljs-keyword">this</span>-&gt;lightShader = <span class="hljs-built_in">Shader</span>(<span class="hljs-string">&quot;lightShader.vs&quot;</span>, <span class="hljs-string">&quot;lightShader.fs&quot;</span>);<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-built_in">loadTexture</span>();<br>    <span class="hljs-comment">// 设置顶点数据</span><br>    <span class="hljs-built_in">setupVertices</span>();<br>&#125;<br><br>Cube::~<span class="hljs-built_in">Cube</span>() &#123;<br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br>&#125;<br><br><span class="hljs-comment">/// Public</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 存储光源的位置和强度</span><br>    vector&lt;<span class="hljs-type">float</span>&gt; lightPos = &#123; <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">-1.55f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><br>    <span class="hljs-comment">// 使用立方体的着色器</span><br>    shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 将立方体的VAO绑定到上下文</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br><br>    <span class="hljs-comment">// 设置立方体模型矩阵</span><br>    <span class="hljs-keyword">auto</span> model = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>    <span class="hljs-comment">// 设置平移矩阵</span><br>    model = glm::<span class="hljs-built_in">translate</span>(model, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-3.0f</span>));<br>    <span class="hljs-comment">// 设置旋转矩阵</span><br>    model = glm::<span class="hljs-built_in">rotate</span>(model, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">20.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br><br>    <span class="hljs-comment">// 将uniform变量传递给着色器</span><br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;model&quot;</span>, model);<br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;view&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getViewMatrix</span>());<br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;projection&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getProjectionMatrix</span>());<br>    shader.<span class="hljs-built_in">setVec3</span>(<span class="hljs-string">&quot;lightColor&quot;</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>    shader.<span class="hljs-built_in">setVec3</span>(<span class="hljs-string">&quot;lightPos&quot;</span>, lightPos[<span class="hljs-number">0</span>], lightPos[<span class="hljs-number">1</span>], lightPos[<span class="hljs-number">2</span>]);<br>    shader.<span class="hljs-built_in">setFloat</span>(<span class="hljs-string">&quot;blendRatio&quot;</span>, <span class="hljs-number">0.5f</span>);<br><br>    <span class="hljs-comment">// 绘制立方体</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">36</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 使用光源的着色器</span><br>    lightShader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 光源的VAO仍然使用立方体的VAO</span><br>    <span class="hljs-comment">// 设置模型矩阵</span><br>    model = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>    <span class="hljs-comment">// 设置平移矩阵</span><br>    model = glm::<span class="hljs-built_in">translate</span>(model, glm::<span class="hljs-built_in">vec3</span>(lightPos[<span class="hljs-number">0</span>], lightPos[<span class="hljs-number">1</span>], lightPos[<span class="hljs-number">2</span>]));<br>    <span class="hljs-comment">// 设置缩放矩阵</span><br>    model = glm::<span class="hljs-built_in">scale</span>(model, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.2f</span>));<br><br>    <span class="hljs-comment">// 将uniform变量传递给着色器</span><br>    lightShader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;model&quot;</span>, model);<br>    lightShader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;view&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getViewMatrix</span>());<br>    lightShader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;projection&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getProjectionMatrix</span>());<br>    lightShader.<span class="hljs-built_in">setVec3</span>(<span class="hljs-string">&quot;lightColor&quot;</span>, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>));<br><br>    <span class="hljs-comment">// 绘制光源</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">36</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">/// Private</span><br><span class="hljs-comment">// 设置顶点数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::setupVertices</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-comment">// Front</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>, <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,  <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,  <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Back</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,<span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,  <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,<span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,  <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Left</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Right</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Top</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Bottom</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,  <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span> ,  <span class="hljs-number">0.0f</span>,<span class="hljs-number">-1.0f</span>,<span class="hljs-number">0.0f</span>,<span class="hljs-comment">// Top-right vertex</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 索引数据</span><br>    <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>        <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,<br><br>        <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>        <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>,<br><br>        <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>,<br>        <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>,<br><br>        <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>,<br>        <span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>,<br><br>        <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>,<br>        <span class="hljs-number">18</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>,<br><br>        <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>,<br>        <span class="hljs-number">22</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 创建VAO, VBO, EBO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br><br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br>    <span class="hljs-comment">// 绑定VBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br>    <span class="hljs-comment">// 将顶点数据复制到VBO</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 绑定EBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-comment">// 将索引数据复制到EBO</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 设置顶点位置属性（这里跟顶点着色器源码强相关，每个属性有多少个元素都是看这个顶点着色器源码是怎么写的）</span><br>    <span class="hljs-comment">// 位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 纹理位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 法向量属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">8</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 恢复上下人默认的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 加载纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::loadTexture</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;string&gt; paths = &#123; <span class="hljs-string">&quot;teenager.png&quot;</span>, <span class="hljs-string">&quot;tex.png&quot;</span> &#125;;<br>    <span class="hljs-keyword">this</span>-&gt;texture.<span class="hljs-built_in">resize</span>(paths.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">// 绑定纹理</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; paths.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">bindTexture</span>(<span class="hljs-keyword">this</span>-&gt;texture[i], paths[i].<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 激活纹理</span><br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br>    <span class="hljs-comment">// 将纹理绑定到上下文</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="hljs-keyword">this</span>-&gt;texture[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 激活纹理</span><br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br>    <span class="hljs-comment">// 将纹理绑定到上下文</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="hljs-keyword">this</span>-&gt;texture[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 使用立方体着色器</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 为着色器设置uniform变量</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::bindTexture</span><span class="hljs-params">(GLuint&amp; textureId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span> </span>&#123;<br>    <span class="hljs-comment">// 生成纹理</span><br>    <span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;textureId);<br>    <span class="hljs-comment">// 绑定上下文的纹理</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textureId);<br><br>    <span class="hljs-comment">// 设置纹理环绕方式</span><br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br>    <span class="hljs-comment">// 设置纹理过滤方式</span><br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br>    <span class="hljs-comment">// 加载和生成纹理</span><br>    <span class="hljs-built_in">stbi_set_flip_vertically_on_load</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> width, height, nrChannels;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data = <span class="hljs-built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (data) &#123;<br>        GLenum format;<br>        <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">4</span>)<br>            format = GL_RGBA;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">3</span>)<br>            format = GL_RGB;<br>        <span class="hljs-keyword">else</span><br>            format = GL_RED;<br><br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, format, width, height, <span class="hljs-number">0</span>, format, GL_UNSIGNED_BYTE, data);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">stbi_image_free</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/Cube.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个矩形模型对象</span><br>    <span class="hljs-function">Cube <span class="hljs-title">cube</span><span class="hljs-params">(&amp;myWindow)</span></span>;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>        cube.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(Ambient)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glm CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(assimp CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(yaml-cpp CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(Ambient main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(Ambient PRIVATE glad::glad glfw glm::glm assimp::assimp yaml-cpp::yaml-cpp)<br><br><span class="hljs-comment"># 检查项目是否有dependeicies目录，如果存在，则在使用add_custom_command命令在构建后将dependencies目录中的文件复制到项目的输出目录</span><br><span class="hljs-keyword">set</span>(SOURCE_DIR <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/dependencies&quot;</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">EXISTS</span> <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> Ambient POST_BUILD<br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>        <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span> $&lt;TARGET_FILE_DIR:Ambient&gt;)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/20/OpenGL%E5%85%A5%E9%97%A8009%E2%80%94%E2%80%94%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%9C%A8%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/image-20241120213530485.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门008——环境光在片段着色器中的应用</title>
    <link href="/2024/11/20/OpenGL%E5%85%A5%E9%97%A8008%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%85%89%E5%9C%A8%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/11/20/OpenGL%E5%85%A5%E9%97%A8008%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%85%89%E5%9C%A8%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本节将在片段着色器中应用环境光照(Ambient)</p><h1 id="一些概念">一些概念</h1><h2 id="光照模型">光照模型</h2><h3 id="环境光">环境光</h3><p><strong>概述：</strong>在场景中无处不在、均匀分布的光线，用来模拟从周伟环境反射到物体上的光。即使没有明确的光源，物体表面仍然有一定亮度</p><p><strong>特点：</strong></p><ul><li>不依赖光源方向</li><li>为整个物体提供均匀的基本亮度</li><li>不计算光源与物体表面的方向关系</li></ul><p><strong>公式：</strong> <span class="math display">\[I_a = K_a \cdot I_{ambient}\]</span></p><ul><li><span class="math inline">\(I_a\)</span>：物体表面的环境光亮度</li><li><spanclass="math inline">\(k_a\)</span>：环境光的反射系数（0到1之间）</li><li><span class="math inline">\(I_{ambient}\)</span>：环境光强度</li></ul><h3 id="漫反射">漫反射</h3><p><strong>概述：</strong>描述的是粗糙表面对光的反射，反射的光线相关各个方向均匀分布，与视角无光</p><p><strong>特点：</strong></p><ul><li>亮度取决于光源的方向和物体表面法向量之间的夹角</li><li>适合模拟不光滑的表面，例如木材、纸张等</li><li>视角变化不会影响光的强度</li></ul><p><strong>公式（朗伯余弦定律）：</strong> <span class="math display">\[I_d = k_d \cdot I_{light} \cdot max(0, L \cdot N)\]</span></p><ul><li><span class="math inline">\(I_d\)</span>：物体表面的漫反射亮度</li><li><spanclass="math inline">\(k_d\)</span>：漫反射的反射系数(0到1之间)</li><li><span class="math inline">\(I_{light}\)</span>：光源强度</li><li>L：指向光源的单位向量</li><li>N：表面的法向量</li></ul><h3 id="镜面反射">镜面反射</h3><p><strong>概述：</strong>镜面反射描述的是光滑表面（如金属或镜子）对光的反射，反射光集中在一个特定方向上，与视角密切相关</p><p><strong>特点：</strong></p><ul><li>表现为高光，即表面某些点的强亮反射</li><li>亮度取决于观察者方向、光源方向于物体表面的关系</li><li>表面越光滑，高光越集中；越粗糙，高光越分散</li></ul><p><strong>公式（Phong反射模型）：</strong> <spanclass="math display">\[I_s = k_s \cdot I_{light} \cdot max(0, R \cdot V)^n\]</span></p><ul><li><span class="math inline">\(I_s\)</span>：镜面反射亮度</li><li><spanclass="math inline">\(k_s\)</span>：镜面反射系数（0到1之间）</li><li>R：反射方向的单位向量</li><li>V：观察方向的单位向量</li><li>n：高光的锐利程度，称为”高光指数“</li></ul><h3 id="总结">总结</h3><ul><li>环境光：提供基础的整体亮度，与光源和视角无光</li><li>漫反射：模拟粗糙表面的光照，依赖于光源方向，但与视角无关</li><li>镜面反射：模拟光滑表面的高光，依赖于光源方向和视角</li></ul><p>这三种光照成分通常组合在一起形成Phong光照模型，用于计算场景中物体的颜色和亮度：<span class="math display">\[I = I_a + I_d + I_s\]</span></p><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 使用环境光</p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><p><strong>源码：</strong> <ahref="https://github.com/1037827920/OpenGL-Learn-Program/tree/main/008-ambient-light">OpenGL-Learn-Program/008-ambient-lightat main · 1037827920/OpenGL-Learn-Program</a></p><h2 id="dependencies">dependencies</h2><h3 id="lightshader.vs">lightShader.vs</h3><p>点光源的顶点着色器源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vs">#version 330 core<br>layout (location = 0) in vec3 vPos;<br>layout (location = 1) in vec2 aTexCoord;<br><br>uniform mat4 model;<br>uniform mat4 view;<br>uniform mat4 projection;<br><br>void main()<br>&#123;<br>    gl_Position = projection * view * model * vec4(vPos, 1.0f);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="lightshader.fs">lightShader.fs</h3><p>点光源的片段着色器源码：</p><figure class="highlight fs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fs">#version <span class="hljs-number">330</span> core<br><br><span class="hljs-comment">// 光源颜色</span><br>uniform vec3 lightColor;<br><br><span class="hljs-comment">// 输出的片段颜色</span><br>out vec4 FragColor;<br><br><span class="hljs-keyword">void</span> main()<br>&#123;<br>    FragColor <span class="hljs-operator">=</span> vec4(lightColor, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shader.vs">shader.vs</h3><p>立方体的顶点着色器源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vs">#version 330 core<br>layout (location = 0) in vec3 vPos;<br>layout (location = 1) in vec2 vTexCoord;<br><br>uniform mat4 model;<br>uniform mat4 view;<br>uniform mat4 projection;<br><br>out vec2 TexCoord;<br><br>void main()<br>&#123;<br>    gl_Position = projection * view * model * vec4(vPos, 1.0f);<br><br>    TexCoord = vTexCoord;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="shader.fs">shader.fs</h3><figure class="highlight fs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs fs">#version <span class="hljs-number">330</span> core<br><br><span class="hljs-keyword">in</span> vec2 TexCoord;<br><br><span class="hljs-comment">// 第一个纹理</span><br>uniform sampler2D texture0;<br><span class="hljs-comment">// 第二个纹理</span><br>uniform sampler2D texture1;<br><span class="hljs-comment">// 混合比例</span><br>uniform float blendRatio;<br><span class="hljs-comment">// 光源颜色</span><br>uniform vec3 lightColor;<br><br>out vec4 FragColor;<br><br><span class="hljs-keyword">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 环境光强度</span><br>    float ambientStrength <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span>;<br>    <span class="hljs-comment">// 计算环境光分量</span><br>    vec3 ambient <span class="hljs-operator">=</span> ambientStrength <span class="hljs-operator">*</span> lightColor;<br><br>    <span class="hljs-comment">// 最终颜色结果</span><br>    vec3 lighting <span class="hljs-operator">=</span> ambient;<br><br>    <span class="hljs-comment">// 将两个纹理混合并乘以环境光分量</span><br>    FragColor <span class="hljs-operator">=</span> mix(texture(texture0, TexCoord), texture(texture1, TexCoord), blendRatio) <span class="hljs-operator">*</span> vec4(lighting, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点着色器源码的输出会作为片段着色器源码的输入</p><h2 id="utils">utils</h2><p>新增的代码文件只有Cube.h和Cube.cpp，其他可以看<ahref="https://github.com/1037827920/OpenGL-Learn-Program/tree/main/008-ambient-light/utils">源码的utils目录</a></p><h3 id="cube.h">Cube.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windowFactory.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::vector;<br><span class="hljs-keyword">using</span> std::string;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cube</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Cube</span>(GLFWWindowFactory* window);<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Cube</span>();<br><br>    <span class="hljs-comment">// 绘制函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 顶点数组对象</span><br>    GLuint VAO;<br>    <span class="hljs-comment">// 顶点缓冲对象</span><br>    GLuint VBO;<br>    <span class="hljs-comment">// 索引缓冲对象</span><br>    GLuint EBO;<br>    <span class="hljs-comment">// 着色器对象</span><br>    Shader shader;<br>    <span class="hljs-comment">// 点光源着色器对象</span><br>    Shader lightShader;<br>    <span class="hljs-comment">// 窗口对象</span><br>    GLFWWindowFactory* window;<br>    <span class="hljs-comment">// 纹理对象</span><br>    vector&lt;GLuint&gt; texture;<br><br>    <span class="hljs-comment">// 设置顶点数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupVertices</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadTexture</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 绑定纹理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindTexture</span><span class="hljs-params">(GLuint&amp; textureId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="cube.cpp">Cube.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Cube.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><br>Cube::<span class="hljs-built_in">Cube</span>(GLFWWindowFactory* window) : <span class="hljs-built_in">window</span>(window) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;shader = <span class="hljs-built_in">Shader</span>(<span class="hljs-string">&quot;shader.vs&quot;</span>, <span class="hljs-string">&quot;shader.fs&quot;</span>);<br>    <span class="hljs-keyword">this</span>-&gt;lightShader = <span class="hljs-built_in">Shader</span>(<span class="hljs-string">&quot;lightShader.vs&quot;</span>, <span class="hljs-string">&quot;lightShader.fs&quot;</span>);<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-built_in">loadTexture</span>();<br>    <span class="hljs-comment">// 设置顶点数据</span><br>    <span class="hljs-built_in">setupVertices</span>();<br>&#125;<br><br>Cube::~<span class="hljs-built_in">Cube</span>() &#123;<br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br>&#125;<br><br><span class="hljs-comment">/// Public</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 存储光源的位置和强度</span><br>    vector&lt;<span class="hljs-type">float</span>&gt; lightPos = &#123; <span class="hljs-number">2.0f</span>, <span class="hljs-number">1.5f</span>, <span class="hljs-number">-1.55f</span>, <span class="hljs-number">1.0f</span> &#125;;<br><br>    <span class="hljs-comment">// 使用立方体的着色器</span><br>    shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 将立方体的VAO绑定到上下文</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br><br>    <span class="hljs-comment">// 设置立方体模型矩阵</span><br>    <span class="hljs-keyword">auto</span> model = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>    <span class="hljs-comment">// 设置平移矩阵</span><br>    model = glm::<span class="hljs-built_in">translate</span>(model, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-3.0f</span>));<br>    <span class="hljs-comment">// 设置旋转矩阵</span><br>    model = glm::<span class="hljs-built_in">rotate</span>(model, glm::<span class="hljs-built_in">radians</span>(<span class="hljs-number">20.0f</span>), glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br><br>    <span class="hljs-comment">// 将uniform变量传递给着色器</span><br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;model&quot;</span>, model);<br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;view&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getViewMatrix</span>());<br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;projection&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getProjectionMatrix</span>());<br>    shader.<span class="hljs-built_in">setVec3</span>(<span class="hljs-string">&quot;lightColor&quot;</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>    shader.<span class="hljs-built_in">setVec3</span>(<span class="hljs-string">&quot;lightPos&quot;</span>, lightPos[<span class="hljs-number">0</span>], lightPos[<span class="hljs-number">1</span>], lightPos[<span class="hljs-number">2</span>]);<br>    shader.<span class="hljs-built_in">setFloat</span>(<span class="hljs-string">&quot;blendRatio&quot;</span>, <span class="hljs-number">0.5f</span>);<br><br>    <span class="hljs-comment">// 绘制立方体</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">36</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 使用光源的着色器</span><br>    lightShader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 光源的VAO仍然使用立方体的VAO</span><br>    <span class="hljs-comment">// 设置模型矩阵</span><br>    model = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>    <span class="hljs-comment">// 设置平移矩阵</span><br>    model = glm::<span class="hljs-built_in">translate</span>(model, glm::<span class="hljs-built_in">vec3</span>(lightPos[<span class="hljs-number">0</span>], lightPos[<span class="hljs-number">1</span>], lightPos[<span class="hljs-number">2</span>]));<br>    <span class="hljs-comment">// 设置缩放矩阵</span><br>    model = glm::<span class="hljs-built_in">scale</span>(model, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.2f</span>));<br><br>    <span class="hljs-comment">// 将uniform变量传递给着色器</span><br>    lightShader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;model&quot;</span>, model);<br>    lightShader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;view&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getViewMatrix</span>());<br>    lightShader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;projection&quot;</span>, <span class="hljs-keyword">this</span>-&gt;window-&gt;<span class="hljs-built_in">getProjectionMatrix</span>());<br>    lightShader.<span class="hljs-built_in">setVec3</span>(<span class="hljs-string">&quot;lightColor&quot;</span>, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>));<br><br>    <span class="hljs-comment">// 绘制光源</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">36</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">/// Private</span><br><span class="hljs-comment">// 设置顶点数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::setupVertices</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顶点数据</span><br>    <span class="hljs-type">float</span> vectices[] = &#123;<br>        <span class="hljs-comment">// Front</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,    <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Back</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,    <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Left</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,    <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Right</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,    <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Top</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,    <span class="hljs-comment">// Top-right vertex</span><br><br>        <span class="hljs-comment">// Bottom</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// Bottom-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-1.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,   <span class="hljs-comment">// Bottom-right vertex</span><br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,   <span class="hljs-comment">// Top-left vertex</span><br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>    <span class="hljs-comment">// Top-right vertex</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 索引数据</span><br>    <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>        <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,<br><br>        <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>        <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>,<br><br>        <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>,<br>        <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>,<br><br>        <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>,<br>        <span class="hljs-number">14</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>,<br><br>        <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>,<br>        <span class="hljs-number">18</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>,<br><br>        <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>,<br>        <span class="hljs-number">22</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 创建VAO, VBO, EBO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;EBO);<br><br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br>    <span class="hljs-comment">// 绑定VBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br>    <span class="hljs-comment">// 将顶点数据复制到VBO</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vectices), vectices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 绑定EBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-comment">// 将索引数据复制到EBO</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 设置顶点位置属性（这里跟顶点着色器源码强相关，每个属性有多少个元素都是看这个顶点着色器源码是怎么写的）</span><br>    <span class="hljs-comment">// 位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 纹理位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 恢复上下人默认的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 加载纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::loadTexture</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;string&gt; paths = &#123; <span class="hljs-string">&quot;teenager.png&quot;</span>, <span class="hljs-string">&quot;tex.png&quot;</span> &#125;;<br>    <span class="hljs-keyword">this</span>-&gt;texture.<span class="hljs-built_in">resize</span>(paths.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">// 绑定纹理</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; paths.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">bindTexture</span>(<span class="hljs-keyword">this</span>-&gt;texture[i], paths[i].<span class="hljs-built_in">c_str</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 激活纹理</span><br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br>    <span class="hljs-comment">// 将纹理绑定到上下文</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="hljs-keyword">this</span>-&gt;texture[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 激活纹理</span><br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br>    <span class="hljs-comment">// 将纹理绑定到上下文</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="hljs-keyword">this</span>-&gt;texture[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 使用立方体着色器</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 为着色器设置uniform变量</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cube::bindTexture</span><span class="hljs-params">(GLuint&amp; textureId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span> </span>&#123;<br>    <span class="hljs-comment">// 生成纹理</span><br>    <span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;textureId);<br>    <span class="hljs-comment">// 绑定上下文的纹理</span><br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textureId);<br><br>    <span class="hljs-comment">// 设置纹理环绕方式</span><br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br>    <span class="hljs-comment">// 设置纹理过滤方式</span><br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br>    <span class="hljs-comment">// 加载和生成纹理</span><br>    <span class="hljs-built_in">stbi_set_flip_vertically_on_load</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> width, height, nrChannels;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data = <span class="hljs-built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (data) &#123;<br>        GLenum format;<br>        <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">4</span>)<br>            format = GL_RGBA;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">3</span>)<br>            format = GL_RGB;<br>        <span class="hljs-keyword">else</span><br>            format = GL_RED;<br><br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, format, width, height, <span class="hljs-number">0</span>, format, GL_UNSIGNED_BYTE, data);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">stbi_image_free</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/Cube.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个矩形模型对象</span><br>    <span class="hljs-function">Cube <span class="hljs-title">cube</span><span class="hljs-params">(&amp;myWindow)</span></span>;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>        cube.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(Ambient)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glm CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(assimp CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(yaml-cpp CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(Ambient main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(Ambient PRIVATE glad::glad glfw glm::glm assimp::assimp yaml-cpp::yaml-cpp)<br><br><span class="hljs-comment"># 检查项目是否有dependeicies目录，如果存在，则在使用add_custom_command命令在构建后将dependencies目录中的文件复制到项目的输出目录</span><br><span class="hljs-keyword">set</span>(SOURCE_DIR <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/dependencies&quot;</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">EXISTS</span> <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> Ambient POST_BUILD<br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>        <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span> $&lt;TARGET_FILE_DIR:Ambient&gt;)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/20/OpenGL%E5%85%A5%E9%97%A8008%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%85%89%E5%9C%A8%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/image-20241120204702647.png" class=""><p>可以看到，在只有环境光的情况下，立方体是很暗的，因为点光源（右上角那个很亮的立方体）的光源还没有应用到立方体上</p>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMeter的简单使用</title>
    <link href="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文将介绍JMeter的简单使用方法（windows11平台），用来测试web应用的性能，也可以作为后端接口的测试。</p><p><strong>JMeter下载地址：</strong> <ahref="https://jmeter.apache.org/download_jmeter.cgi">Apache JMeter -Download Apache JMeter</a></p><p>选择二进制包下载后解压，双击/bin/jmeter.bat</p><h1 id="语言设置">语言设置</h1><p>可以在Options/Choose Language将语言设置为中文</p><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117163738309.png" class=""><h1 id="创建线程组">创建线程组</h1><p>右键Test Plan，按下图操作</p><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117163835921.png" class=""><h1 id="设置线程组">设置线程组</h1><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117163925672.png" class=""><ul><li>名称：线程组名称</li><li>注释（可选设置）</li><li>线程数：可以用作是用户数，即多少个同时并发向API发送请求</li><li>Ramp-Up时间：在设定的时间内启动上面设置的线程数</li><li>循环次数：即一个线程发送设定的请求，可以勾选永远，这样线程就会一直发送API请求</li></ul><h1 id="添加http请求">添加HTTP请求</h1><p>右键线程组，按下图操作</p><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117164146898.png" class=""><h1 id="设置http请求">设置HTTP请求</h1><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117164232440.png" class=""><ul><li>名称：接口名称</li><li>注释（可选）</li><li>协议：http/https</li><li>服务器名称或IP：服务器域名或IP地址</li><li>端口号：web程序监听的端口号</li><li>请求方法：GET/POST/....</li><li>路径：API接口路径</li></ul><h1 id="添加http请求头">添加HTTP请求头</h1><p>右键线程组，按下图操作</p><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117164430297.png" class=""><p>然后设置接口的HTTP请求头 ，如果有的话</p><h1 id="添加监听器">添加监听器</h1><p>查看结果树：可以查看请求响应是否成功，也可以看到响应内存</p><img src="/2024/11/17/JMeter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/image-20241117164613252.png" class=""><p>聚合报告：可以查看API响应时间以及吞吐量</p>]]></content>
    
    
    <categories>
      
      <category>软件测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jmeter</tag>
      
      <tag>性能测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门007——摄像机</title>
    <link href="/2024/11/06/OpenGL%E5%85%A5%E9%97%A8007%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA/"/>
    <url>/2024/11/06/OpenGL%E5%85%A5%E9%97%A8007%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>本节将用opengl实现一个Camera类，学习如何在顶点/片段着色器中应用模型/视图/投影矩阵，以及理解坐标变换和渲染流程。</p><h1 id="一些概念">一些概念</h1><h2 id="坐标转换">坐标转换</h2><p>关于坐标转换，模型矩阵，视图矩阵，投影矩阵，可以看<ahref="https://1037827920.github.io/2024/11/01/OpenGL入门002——顶点着色器和片段着色器/#坐标转换阶段">这篇的概念说明</a>。</p><h2 id="欧拉角">欧拉角</h2><p><strong>偏航角：</strong></p><ul><li>概述：Yaw是绕世界坐标系的Y轴旋转的角度</li><li>作用：控制摄像机左右旋转</li><li>实现：在摄像机类中，Yaw用于计算摄像机的前向量，从而影响摄像机的视图方向</li></ul><p><strong>俯仰角：</strong></p><ul><li>概述：Pitch是绕摄像机自身的X轴旋转的角度</li><li>作用：控制摄像机上下旋转</li><li>实现：在摄像机类中，Pitch同样用于计算摄像机的前向量，从而影响摄像机的视图方向</li></ul><p><strong>滚转角：</strong></p><ul><li>概述：Roll是绕摄像机自身的Z轴的角度</li><li>作用：控制摄像机的左右倾斜</li><li>实现：在摄像机类中，滚转角用于计算摄像机的右向量，从而影响摄像机的上向量和右向量</li></ul><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 实现Camera类</p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="dependencies">dependencies</h2><h3 id="shader.fs">shader.fs</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">// 指定OpenGL着色器语言的版本为3.30</span><br>#version <span class="hljs-number">330</span> core<br><span class="hljs-comment">// 输入变量，表示纹理坐标</span><br><span class="hljs-keyword">in</span> vec2 TexCoord;<br><span class="hljs-comment">// 输出变量，表示片段的最终颜色</span><br>out vec4 FragColor;<br><span class="hljs-comment">// uniform变量，表示第一个纹理</span><br>uniform sampler2D texture0;<br><span class="hljs-comment">// uniform变量，表示第二个纹理</span><br>uniform sampler2D texture1;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><span class="hljs-comment">// 在两个纹理之间进行线性插值</span><br>FragColor <span class="hljs-operator">=</span> mix(texture(texture0, TexCoord), texture(texture1, TexCoord), <span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shader.vs">shader.vs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">0</span>) in vec2 aPos;<br><span class="hljs-built_in">layout</span> (location = <span class="hljs-number">1</span>) in vec2 aTex;<br><br>out vec2 TexCoord;<br><br>uniform mat4 model;<br>uniform mat4 view;<br>uniform mat4 projection;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    gl_Position = projection * view * model * <span class="hljs-built_in">vec4</span>(aPos, <span class="hljs-number">1.0f</span>);<br>TexCoord = aTex;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="teenager.png">teenager.png</h3><img src="/2024/11/06/OpenGL%E5%85%A5%E9%97%A8007%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA/image-20241104161400601.png" class=""><h3 id="tex.png">tex.png</h3><img src="/2024/11/06/OpenGL%E5%85%A5%E9%97%A8007%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA/image-20241104161423902.png" class=""><h2 id="utils">utils</h2><h3 id="camera.h">camera.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CAMERA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 定义摄像机移动的几种可能选项</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Camera_Movement</span> &#123;<br>    FORWARD, <span class="hljs-comment">// 向前</span><br>    BACKWARD, <span class="hljs-comment">// 向后</span><br>LEFT, <span class="hljs-comment">// 向左</span><br>    RIGHT, <span class="hljs-comment">// 向右</span><br>    UP, <span class="hljs-comment">// 向上</span><br>    DOWN, <span class="hljs-comment">// 向下</span><br>    ROLL_LEFT, <span class="hljs-comment">// 左旋转</span><br>    ROLL_RIGHT, <span class="hljs-comment">// 右旋转</span><br>    PITCH_UP, <span class="hljs-comment">// 向上俯仰</span><br>    PITCH_DOWN, <span class="hljs-comment">// 向下俯仰</span><br>    YAW_LEFT, <span class="hljs-comment">// 向左偏航</span><br>    YAW_RIGHT, <span class="hljs-comment">// 向右偏航</span><br>&#125;;<br><br><span class="hljs-comment">// 摄像机默认参数</span><br><span class="hljs-comment">// 偏航角</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> YAW = <span class="hljs-number">-90.0f</span>;<br><span class="hljs-comment">// 俯仰角</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> PITCH = <span class="hljs-number">0.0f</span>;<br><span class="hljs-comment">// 滚转角</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ROLL = <span class="hljs-number">0.0f</span>;<br><span class="hljs-comment">// 移动速度</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> SPEED = <span class="hljs-number">12.5f</span>;<br><span class="hljs-comment">// 鼠标灵敏度</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> SENSITIVITY = <span class="hljs-number">0.1f</span>;<br><span class="hljs-comment">// 缩放</span><br><span class="hljs-type">const</span> <span class="hljs-type">float</span> ZOOM = <span class="hljs-number">45.0f</span>;<br><br><span class="hljs-comment">// 摄像机类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 位置</span><br>    glm::vec3 Position;<br>    <span class="hljs-comment">// 前向量</span><br>    glm::vec3 Front;<br>    <span class="hljs-comment">// 上向量</span><br>    glm::vec3 Up;<br>    <span class="hljs-comment">// 右向量</span><br>    glm::vec3 Right;<br>    <span class="hljs-comment">// 世界上向量</span><br>    glm::vec3 WorldUp;<br>    <br>    <span class="hljs-comment">// 偏航角，控制摄像机左右旋转</span><br>    <span class="hljs-type">float</span> Yaw;<br>    <span class="hljs-comment">// 俯仰角，控制摄像机上下旋转</span><br>    <span class="hljs-type">float</span> Pitch;<br>    <span class="hljs-comment">// 滚转角，控制摄像机的左右倾斜</span><br>    <span class="hljs-type">float</span> Roll;<br>    <br>    <span class="hljs-comment">// 移动速度</span><br>    <span class="hljs-type">float</span> MovementSpeed;<br>    <span class="hljs-comment">// 鼠标灵敏度</span><br>    <span class="hljs-type">float</span> MouseSensitivity;<br>    <span class="hljs-comment">// 缩放</span><br>    <span class="hljs-type">float</span> Zoom;<br>    <br>    <span class="hljs-comment">// 使用向量的构造函数</span><br>    <span class="hljs-built_in">Camera</span>(glm::vec3 position = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>), glm::vec3 up = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>), <span class="hljs-type">float</span> yaw = YAW, <span class="hljs-type">float</span> pitch = PITCH, <span class="hljs-type">float</span> roll = ROLL) : <span class="hljs-built_in">Front</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>)), <span class="hljs-built_in">MovementSpeed</span>(SPEED), <span class="hljs-built_in">MouseSensitivity</span>(SENSITIVITY), <span class="hljs-built_in">Zoom</span>(ZOOM) &#123;<br>        Position = position;<br>        WorldUp = up;<br>        Yaw = yaw;<br>        Pitch = pitch;<br>        Roll = roll;<br>        <span class="hljs-built_in">updateCameraVectors</span>();<br>    &#125;<br>    <span class="hljs-comment">// 使用标量的构造函数</span><br>    <span class="hljs-built_in">Camera</span>(<span class="hljs-type">float</span> posX, <span class="hljs-type">float</span> posY, <span class="hljs-type">float</span> posZ, <span class="hljs-type">float</span> upX, <span class="hljs-type">float</span> upY, <span class="hljs-type">float</span> upZ, <span class="hljs-type">float</span> yaw, <span class="hljs-type">float</span> pitch, <span class="hljs-type">float</span> roll = ROLL) : <span class="hljs-built_in">Front</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">-1.0f</span>)), <span class="hljs-built_in">MovementSpeed</span>(SPEED), <span class="hljs-built_in">MouseSensitivity</span>(SENSITIVITY), <span class="hljs-built_in">Zoom</span>(ZOOM) &#123;<br>        Position = glm::<span class="hljs-built_in">vec3</span>(posX, posY, posZ);<br>        WorldUp = glm::<span class="hljs-built_in">vec3</span>(upX, upY, upZ);<br>        Yaw = yaw;<br>        Pitch = pitch;<br>        Roll = roll;<br>        <span class="hljs-built_in">updateCameraVectors</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回使用前向量和上向量以计算的视图矩阵</span><br>    <span class="hljs-function">glm::mat4 <span class="hljs-title">GetViewMatrix</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> glm::<span class="hljs-built_in">lookAt</span>(<span class="hljs-keyword">this</span>-&gt;Position, <span class="hljs-keyword">this</span>-&gt;Position + <span class="hljs-keyword">this</span>-&gt;Front, <span class="hljs-keyword">this</span>-&gt;Up);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 处理键盘输入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessKeyboard</span><span class="hljs-params">(Camera_Movement direction, <span class="hljs-type">float</span> deltaTime)</span> </span>&#123;<br>        <span class="hljs-type">float</span> velocity = MovementSpeed * deltaTime;<br>        <span class="hljs-keyword">if</span> (direction == FORWARD) <br>            <span class="hljs-keyword">this</span>-&gt;Position += <span class="hljs-keyword">this</span>-&gt;Front * velocity;<br>        <span class="hljs-keyword">if</span> (direction == BACKWARD) <br>            <span class="hljs-keyword">this</span>-&gt;Position -= <span class="hljs-keyword">this</span>-&gt;Front * velocity;<br>        <span class="hljs-keyword">if</span> (direction == LEFT)<br>            <span class="hljs-keyword">this</span>-&gt;Position -= <span class="hljs-keyword">this</span>-&gt;Right * velocity;<br>        <span class="hljs-keyword">if</span> (direction == RIGHT) <br>            <span class="hljs-keyword">this</span>-&gt;Position += <span class="hljs-keyword">this</span>-&gt;Right * velocity;<br>        <span class="hljs-keyword">if</span> (direction == UP)<br>            <span class="hljs-keyword">this</span>-&gt;Position += <span class="hljs-keyword">this</span>-&gt;Up * velocity;<br>        <span class="hljs-keyword">if</span> (direction == DOWN)<br>            <span class="hljs-keyword">this</span>-&gt;Position -= <span class="hljs-keyword">this</span>-&gt;Up * velocity;<br>        <span class="hljs-keyword">if</span> (direction == ROLL_LEFT)<br>            <span class="hljs-keyword">this</span>-&gt;Roll -= velocity;<br>        <span class="hljs-keyword">if</span> (direction == ROLL_RIGHT)<br>            <span class="hljs-keyword">this</span>-&gt;Roll += velocity;<br>        <span class="hljs-keyword">if</span> (direction == PITCH_UP)<br>            <span class="hljs-keyword">this</span>-&gt;Pitch += velocity;<br>        <span class="hljs-keyword">if</span> (direction == PITCH_DOWN)<br>            <span class="hljs-keyword">this</span>-&gt;Pitch -= velocity;<br>        <span class="hljs-keyword">if</span> (direction == YAW_LEFT)<br>            <span class="hljs-keyword">this</span>-&gt;Yaw -= velocity;<br>        <span class="hljs-keyword">if</span> (direction == YAW_RIGHT)<br>            <span class="hljs-keyword">this</span>-&gt;Yaw += velocity;<br>        <br>        <span class="hljs-built_in">updateAngles</span>();<br>        <span class="hljs-built_in">updateCameraVectors</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 处理鼠标的移动</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessMouseMovement</span><span class="hljs-params">(<span class="hljs-type">float</span> xoffset, <span class="hljs-type">float</span> yoffset, GLboolean constrainPitch = <span class="hljs-literal">true</span>)</span> </span>&#123;<br>        xoffset *= MouseSensitivity;<br>        yoffset *= MouseSensitivity;<br><br>        <span class="hljs-keyword">this</span>-&gt;Yaw += xoffset;<br>        <span class="hljs-keyword">this</span>-&gt;Pitch += yoffset;<br><br>        <span class="hljs-comment">// 确保当前俯仰角超出范围时，屏幕不会翻转</span><br>        <span class="hljs-keyword">if</span> (constrainPitch) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Pitch &gt; <span class="hljs-number">89.0f</span>)<br>                <span class="hljs-keyword">this</span>-&gt;Pitch = <span class="hljs-number">89.0f</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Pitch &lt; <span class="hljs-number">-89.0f</span>)<br>                <span class="hljs-keyword">this</span>-&gt;Pitch = <span class="hljs-number">-89.0f</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用更新的欧拉角更新前向量、右向量和上向量</span><br>        <span class="hljs-built_in">updateCameraVectors</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 处理鼠标滚轮事件，只处理在垂直滚轮轴上的输入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ProcessMouseScroll</span><span class="hljs-params">(<span class="hljs-type">float</span> yoffset)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;Zoom -= (<span class="hljs-type">float</span>)yoffset;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Zoom &lt; <span class="hljs-number">1.0f</span>) <br>            <span class="hljs-keyword">this</span>-&gt;Zoom = <span class="hljs-number">1.0f</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Zoom &gt; <span class="hljs-number">45.0f</span>)<br>            <span class="hljs-keyword">this</span>-&gt;Zoom = <span class="hljs-number">45.0f</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 更新角度，确保俯仰角在合理范围内</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateAngles</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Pitch &gt; <span class="hljs-number">89.9f</span>)<br>            <span class="hljs-keyword">this</span>-&gt;Pitch = <span class="hljs-number">89.9f</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Pitch &lt; <span class="hljs-number">-89.9f</span>) <br>            <span class="hljs-keyword">this</span>-&gt;Pitch = <span class="hljs-number">-89.9f</span>;<br>    &#125;<br>    <span class="hljs-comment">// 更新前向量，上向量和右向量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateCameraVectors</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 计算新的前向量</span><br>        glm::vec3 front;<br>        front.x = <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(Yaw)) * <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(Pitch));<br>        front.y = <span class="hljs-built_in">sin</span>(glm::<span class="hljs-built_in">radians</span>(Pitch));<br>        front.z = <span class="hljs-built_in">sin</span>(glm::<span class="hljs-built_in">radians</span>(Yaw)) * <span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(Pitch));<br>        <span class="hljs-keyword">this</span>-&gt;Front = glm::<span class="hljs-built_in">normalize</span>(front);<br>        <br>        <span class="hljs-comment">// 计算新的右向量</span><br>        <span class="hljs-keyword">this</span>-&gt;Right = glm::<span class="hljs-built_in">normalize</span>(glm::<span class="hljs-built_in">cross</span>(Front, WorldUp));<br>        glm::mat4 rollMatrix = glm::<span class="hljs-built_in">rotate</span>(glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>), glm::<span class="hljs-built_in">radians</span>(<span class="hljs-keyword">this</span>-&gt;Roll), <span class="hljs-keyword">this</span>-&gt;Front);<br>        <span class="hljs-keyword">this</span>-&gt; Right = glm::<span class="hljs-built_in">vec3</span>(rollMatrix * glm::<span class="hljs-built_in">vec4</span>(<span class="hljs-keyword">this</span>-&gt;Right, <span class="hljs-number">0.0f</span>));<br>        <br>        <span class="hljs-comment">// 计算新的上向量</span><br>        Up = glm::<span class="hljs-built_in">normalize</span>(glm::<span class="hljs-built_in">cross</span>(<span class="hljs-keyword">this</span>-&gt;Right, <span class="hljs-keyword">this</span>-&gt;Front));<br>    &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="windowfactory.h">windowFactory.h</h3><p>这个文件有改动！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;camera.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span> <span class="hljs-comment">// gald前面不能包含任何opengl头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLFWWindowFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>() &#123;&#125;<br>    <span class="hljs-comment">// 构造函数，初始化窗口</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title) &#123;<br>        <span class="hljs-comment">// 初始化glfw</span><br>        <span class="hljs-built_in">glfwInit</span>();<br>        <span class="hljs-comment">// 设置opengl版本</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>        <span class="hljs-comment">// 创建glfw窗口</span><br>        <span class="hljs-keyword">this</span>-&gt;window = <span class="hljs-built_in">glfwCreateWindow</span>(width, height, title, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;window == <span class="hljs-literal">NULL</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">glfwTerminate</span>();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置当前窗口的上下文</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>        <span class="hljs-comment">// 加载所有opengl函数指针</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">// 再次设置当前窗口的上下文，确保当前上下文仍然是刚刚创建的窗口，是一个安全措施</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>        <span class="hljs-comment">// 设置鼠标移动的回调函数</span><br>        <span class="hljs-built_in">glfwSetCursorPosCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, mouse_callback);<br>        <span class="hljs-comment">// 设置鼠标滚轮滚动的回调函数</span><br>        <span class="hljs-built_in">glfwSetScrollCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, scroll_callback);<br>        <span class="hljs-comment">// 告诉GLFW捕获鼠标</span><br>        <span class="hljs-built_in">glfwSetInputMode</span>(<span class="hljs-keyword">this</span>-&gt;window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取窗口对象</span><br>    <span class="hljs-function">GLFWwindow* <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;window;<br>    &#125;<br><br>    <span class="hljs-comment">// 运行窗口，传入一个自定义的更新函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; updateFunc)</span> </span>&#123;<br>        <span class="hljs-comment">// 启用深度测试，opengl将在绘制每个像素之前比较其深度值，以确定该像素是否应该被绘制</span><br>        <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br><br>        <span class="hljs-comment">// 循环渲染</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(<span class="hljs-keyword">this</span>-&gt;window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>            <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>            <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>            <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br><br>            <span class="hljs-type">float</span> currentFrame = <span class="hljs-built_in">glfwGetTime</span>();<br>            <span class="hljs-keyword">this</span>-&gt;deltaTime = currentFrame - <span class="hljs-keyword">this</span>-&gt;lastFrame;<br>            <span class="hljs-keyword">this</span>-&gt;lastFrame = currentFrame;<br>            <span class="hljs-keyword">this</span>-&gt;timeElapsed += <span class="hljs-keyword">this</span>-&gt;deltaTime;<br>            <span class="hljs-keyword">this</span>-&gt;frameCount++;<br><br>            <span class="hljs-comment">// 处理输入</span><br>            GLFWWindowFactory::<span class="hljs-built_in">process_input</span>(<span class="hljs-keyword">this</span>-&gt;window);<br><br>            <span class="hljs-comment">// 初始化投影矩阵和视图矩阵</span><br>            <span class="hljs-keyword">this</span>-&gt;projection =<br>                glm::<span class="hljs-built_in">perspective</span>(glm::<span class="hljs-built_in">radians</span>(camera.Zoom),<br>                    (<span class="hljs-type">float</span>)SCR_WIDTH / (<span class="hljs-type">float</span>)SCR_HEIGHT, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br>            <span class="hljs-keyword">this</span>-&gt;view = <span class="hljs-keyword">this</span>-&gt;camera.<span class="hljs-built_in">GetViewMatrix</span>();<br><br>            <span class="hljs-comment">// 执行更新函数</span><br>            <span class="hljs-built_in">updateFunc</span>();<br><br>            <span class="hljs-comment">// 交换缓冲区</span><br>            <span class="hljs-built_in">glfwSwapBuffers</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>            <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>            <span class="hljs-built_in">glfwPollEvents</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 窗口大小改变的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>        <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>        <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>    &#125;<br><br>    <span class="hljs-comment">// 鼠标移动的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">mouse_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">double</span> xposIn, <span class="hljs-type">double</span> yposIn)</span> </span>&#123;<br>        <span class="hljs-type">float</span> xpos = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(xposIn);<br>        <span class="hljs-type">float</span> ypos = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(yposIn);<br><br>        <span class="hljs-keyword">if</span> (firstMouse) &#123;<br>            lastX = xpos;<br>            lastY = ypos;<br>            firstMouse = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">float</span> xoffset = xpos - lastX;<br>        <span class="hljs-comment">// 反转y坐标，因为y坐标的范围是从上到下，我们需要从下到上</span><br>        <span class="hljs-type">float</span> yoffset = lastY - ypos;<br><br>        lastX = xpos;<br>        lastY = ypos;<br><br>        camera.<span class="hljs-built_in">ProcessMouseMovement</span>(xoffset, yoffset);<br>    &#125;<br><br>    <span class="hljs-comment">// 鼠标滚轮的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">scroll_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">double</span> xoffset, <span class="hljs-type">double</span> yoffset)</span> </span>&#123;<br>        camera.<span class="hljs-built_in">ProcessMouseScroll</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">float</span>&gt;(yoffset));<br>    &#125;<br><br>    <span class="hljs-comment">// 处理输入</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>        <span class="hljs-comment">// 按下ESC键时进入if块</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>            <span class="hljs-comment">// 关闭窗口</span><br>            <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_W) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(FORWARD, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_S) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(BACKWARD, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_A) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(LEFT, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_D) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(RIGHT, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_Q) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(UP, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_E) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(DOWN, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_I) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(PITCH_UP, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_K) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(PITCH_DOWN, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_J) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(YAW_LEFT, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_L) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(YAW_RIGHT, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_U) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(ROLL_LEFT, deltaTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_O) == GLFW_PRESS)<br>            camera.<span class="hljs-built_in">ProcessKeyboard</span>(ROLL_RIGHT, deltaTime);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取投影矩阵</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> glm::mat4 <span class="hljs-title">getProjectionMatrix</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;projection;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取视图矩阵</span><br>    <span class="hljs-function">glm::mat4 <span class="hljs-title">getViewMatrix</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;view;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 投影矩阵</span><br>    glm::mat4 projection;<br>    <span class="hljs-comment">// 视图矩阵</span><br>    glm::mat4 view;<br>    <span class="hljs-comment">// 摄像机</span><br>    <span class="hljs-type">static</span> Camera camera;<br>    <span class="hljs-comment">// 屏幕宽度</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SCR_WIDTH = <span class="hljs-number">800</span>;<br>    <span class="hljs-comment">// 屏幕高度</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SCR_HEIGHT = <span class="hljs-number">600</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 窗口对象</span><br>    GLFWwindow* window;<br><br>    <span class="hljs-comment">// 经过的时间</span><br>    <span class="hljs-type">float</span> timeElapsed;<br>    <span class="hljs-comment">// 帧计数</span><br>    <span class="hljs-type">int</span> frameCount;<br><br>    <span class="hljs-comment">// 上一次鼠标的X坐标</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">float</span> lastX;<br>    <span class="hljs-comment">// 上一次鼠标的Y坐标</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">float</span> lastY;<br>    <span class="hljs-comment">// 是否第一次鼠标移动</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> firstMouse;<br><br>    <span class="hljs-comment">// 时间间隔</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">float</span> deltaTime;<br>    <span class="hljs-comment">// 上一帧的时间</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">float</span> lastFrame;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="windowfactory.cpp">windowFactory.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;windowFactory.h&quot;</span></span><br><br>Camera GLFWWindowFactory::camera = <span class="hljs-built_in">Camera</span>(glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>));<br><br><span class="hljs-comment">// 初始化鼠标的最后X位置为屏幕宽度的一半</span><br><span class="hljs-type">float</span> GLFWWindowFactory::lastX = GLFWWindowFactory::SCR_WIDTH / <span class="hljs-number">2.0f</span>;<br><span class="hljs-comment">// 初始化鼠标的最后Y位置为屏幕高度的一半</span><br><span class="hljs-type">float</span> GLFWWindowFactory::lastY = GLFWWindowFactory::SCR_HEIGHT / <span class="hljs-number">2.0f</span>;<br><span class="hljs-comment">// 标记是否为第一次鼠标输入</span><br><span class="hljs-type">bool</span> GLFWWindowFactory::firstMouse = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 初始化帧间隔时间</span><br><span class="hljs-type">float</span> GLFWWindowFactory::deltaTime = <span class="hljs-number">0.0f</span>;<br><span class="hljs-comment">// 初始化上一帧的时间</span><br><span class="hljs-type">float</span> GLFWWindowFactory::lastFrame = <span class="hljs-number">0.0f</span>;<br></code></pre></td></tr></table></figure><h3 id="shader.h">shader.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SHADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-keyword">using</span> std::ifstream;<br><span class="hljs-keyword">using</span> std::stringstream;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shader</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Shader</span>() &#123;&#125;<br>    <span class="hljs-comment">// 着色器程序ID</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ID;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Shader</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertexPath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentPath) &#123;<br>        string vertexCode;<br>        string fragmentCode;<br>        ifstream vShaderFile;<br>        ifstream fShaderFile;<br><br>        <span class="hljs-comment">// 确保ifstream对象可以抛出异常</span><br>        vShaderFile.<span class="hljs-built_in">exceptions</span>(ifstream::failbit | ifstream::badbit);<br>        fShaderFile.<span class="hljs-built_in">exceptions</span>(ifstream::failbit | ifstream::badbit);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 打开文件</span><br>            vShaderFile.<span class="hljs-built_in">open</span>(vertexPath);<br>            fShaderFile.<span class="hljs-built_in">open</span>(fragmentPath);<br>            <span class="hljs-comment">// 读取文件缓冲区内容到stream中</span><br>            stringstream vShaderStream, fShaderStream;<br>            vShaderStream &lt;&lt; vShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            fShaderStream &lt;&lt; fShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            <span class="hljs-comment">// 关闭文件处理器</span><br>            vShaderFile.<span class="hljs-built_in">close</span>();<br>            fShaderFile.<span class="hljs-built_in">close</span>();<br>            <span class="hljs-comment">// 将stream转换为字符串</span><br>            vertexCode = vShaderStream.<span class="hljs-built_in">str</span>();<br>            fragmentCode = fShaderStream.<span class="hljs-built_in">str</span>();<br>        &#125; <span class="hljs-built_in">catch</span> (ifstream::failure&amp; e) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* vShaderCode = vertexCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fShaderCode = fragmentCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-comment">// 编译着色器</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex, fragment;<br>        <span class="hljs-comment">// 顶点着色器</span><br>        vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(vertex, <span class="hljs-number">1</span>, &amp;vShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(vertex);<br>        <span class="hljs-built_in">checkCompileErrors</span>(vertex, <span class="hljs-string">&quot;VERTEX&quot;</span>);<br>        <span class="hljs-comment">// 片段着色器</span><br>        fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(fragment, <span class="hljs-number">1</span>, &amp;fShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(fragment);<br>        <span class="hljs-built_in">checkCompileErrors</span>(fragment, <span class="hljs-string">&quot;FRAGMENT&quot;</span>);<br>        <span class="hljs-comment">// 着色器程序</span><br>        ID = <span class="hljs-built_in">glCreateProgram</span>();<br>        <span class="hljs-built_in">glAttachShader</span>(ID, vertex);<br>        <span class="hljs-built_in">glAttachShader</span>(ID, fragment);<br>        <span class="hljs-built_in">glLinkProgram</span>(ID);<br>        <span class="hljs-built_in">checkCompileErrors</span>(ID, <span class="hljs-string">&quot;PROGRAM&quot;</span>);<br>        <span class="hljs-comment">// 删除着色器</span><br>        <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>        <span class="hljs-built_in">glDeleteShader</span>(fragment);<br>    &#125;<br><br>    <span class="hljs-comment">// 激活着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">glUseProgram</span>(ID);<br>    &#125;<br><br>    <span class="hljs-comment">// 实用的uniform工具函数</span><br>    <span class="hljs-comment">// 用于在着色器程序中设置uniform值</span><br>    <span class="hljs-comment">// 设置一个布尔类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBool</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">bool</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), (<span class="hljs-type">int</span>)value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个整型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个浮点类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFloat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec2&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform2fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform2f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec3&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform3fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform3f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y, z);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec4&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform4fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z, <span class="hljs-type">float</span> w)</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform4f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y, z, w);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个mat2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat2&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix2fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">//  设置一个mat3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat3&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix3fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个mat4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat4&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix4fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 检查着色器编译/链接错误</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkCompileErrors</span><span class="hljs-params">(GLuint shader, string type)</span> </span>&#123;<br>        GLint success;<br>        GLchar infoLog[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-string">&quot;PROGRAM&quot;</span>) &#123;<br>            <span class="hljs-built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">glGetShaderInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">glGetProgramInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                cout &lt;&lt; <span class="hljs-string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.h">RectangleModel.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shader.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleModel</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">RectangleModel</span>(<span class="hljs-type">const</span> Shader&amp; shader);<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">RectangleModel</span>();<br>    <br>    <span class="hljs-comment">// 绘制矩形</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    Shader shader;<br>    <br>    <span class="hljs-comment">// 纹理</span><br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;texture;<br>    <br>    <br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compileShaders</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setElements</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadTexture</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 绑定纹理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindTexture</span><span class="hljs-params">(GLuint&amp; textured, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.cpp">RectangleModel.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 构造函数</span><br>RectangleModel::<span class="hljs-built_in">RectangleModel</span>(<span class="hljs-type">const</span> Shader&amp; shader) : <span class="hljs-built_in">shader</span>(shader) &#123;<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-built_in">loadTexture</span>();<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-built_in">setElements</span>();<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>RectangleModel::~<span class="hljs-built_in">RectangleModel</span>() &#123;<br>    <span class="hljs-comment">// 删除VAO</span><br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 删除VBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 删除EBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>&#125;<br><br><span class="hljs-comment">/// public</span><br><span class="hljs-comment">// 绘制矩形</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用着色器程序</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br>    <span class="hljs-comment">// 获取当前时间</span><br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-comment">// 计算毫秒数</span><br>    <span class="hljs-keyword">auto</span> duration = now.<span class="hljs-built_in">time_since_epoch</span>();<br>    <span class="hljs-type">double</span> milliseconds = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="hljs-built_in">count</span>();<br><br>    <span class="hljs-comment">// 设置模型矩阵</span><br>    glm::mat4 model = glm::<span class="hljs-built_in">mat4</span>(<span class="hljs-number">1.0f</span>);<br>    shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;model&quot;</span>, model);<br><br>    <span class="hljs-comment">// 绘制矩形，即绘制两个三角形，GL_UNSIGNED_INT表示索引数组中的每个元素都是一个无符号整数</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/// private</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::setElements</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//顶点数据</span><br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.1f</span>, <span class="hljs-number">-0.75f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.1f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">-0.1f</span>, <span class="hljs-number">-0.1f</span>,<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br>    &#125;;<br>    <span class="hljs-comment">// 索引数据</span><br>    <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<br><br>    &#125;;<br><br>    <span class="hljs-comment">// 生成一个VAO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 绑定VAO，使其成为当前操作的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 生成一个VBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 绑定VBO, 使其成为当前操作的VBO，GL_ARRAY_BUFFER表示顶点缓冲区</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 为当前绑定的VBO创建并初始化数据存储，GL_STATIC_DRAW表示数据将一次性提供给缓冲区，并且在之后的绘制过程中不会频繁更改</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>    <span class="hljs-comment">// 生成一个EBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>    <span class="hljs-comment">// 绑定EBO，使其成为当前操作的EBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-comment">// 传递索引数据</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 定义顶点属性的布局</span><br>    <span class="hljs-comment">// - index：顶点属性的索引</span><br>    <span class="hljs-comment">// - size：每个顶点属性的数量</span><br>    <span class="hljs-comment">// - type：数据类型</span><br>    <span class="hljs-comment">// - normalized：是否将非浮点数值归一化</span><br>    <span class="hljs-comment">// - stride：连续顶点属性之间的间隔</span><br>    <span class="hljs-comment">// - pointer：数据在缓冲区中的偏移量</span><br>    <span class="hljs-comment">// 设置顶点属性指针，位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 设置顶点属性指针，颜色属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-comment">// 启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 加载纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::loadTexture</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; path = &#123; <span class="hljs-string">&quot;teenager.png&quot;</span>, <span class="hljs-string">&quot;tex.png&quot;</span> &#125;;<br>    texture.<span class="hljs-built_in">resize</span>(path.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">bindTexture</span>(texture[i], path[i].<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    <span class="hljs-comment">// 参数传入指定要激活的纹理单元，例如GL_TEXTURE0/1/*</span><br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 使用着色器程序</span><br>    shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 设置uniform变量</span><br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::bindTexture</span><span class="hljs-params">(GLuint&amp; textureId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span> </span>&#123;<br>    <span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;textureId);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textureId);<br>    <span class="hljs-comment">// 设置纹理环绕和过滤方式</span><br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    <span class="hljs-comment">// 加载并生成纹理</span><br>    <span class="hljs-built_in">stbi_set_flip_vertically_on_load</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> width, height, nrChannels;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data = <span class="hljs-built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (data) &#123;<br>        GLenum format;<br>        <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">4</span>)<br>            format = GL_RGBA;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">3</span>)<br>            format = GL_RGB;<br>        <span class="hljs-keyword">else</span><br>            format = GL_RED;<br><br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, format, width, height, <span class="hljs-number">0</span>, format, GL_UNSIGNED_BYTE, data);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">stbi_image_free</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个着色器对象</span><br>    <span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">&quot;shader.vs&quot;</span>, <span class="hljs-string">&quot;shader.fs&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个矩形模型对象</span><br>    <span class="hljs-function">RectangleModel <span class="hljs-title">rectangle</span><span class="hljs-params">(shader)</span></span>;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 设置投影矩阵</span><br>        shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;projection&quot;</span>, myWindow.<span class="hljs-built_in">getProjectionMatrix</span>());<br>        <span class="hljs-comment">// 设置视图矩阵</span><br>        shader.<span class="hljs-built_in">setMat4</span>(<span class="hljs-string">&quot;view&quot;</span>, myWindow.<span class="hljs-built_in">getViewMatrix</span>());<br>        <span class="hljs-comment">// 绘制矩形</span><br>        rectangle.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(Camera)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glm CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(assimp CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(yaml-cpp CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(Camera main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(Camera PRIVATE glad::glad glfw glm::glm assimp::assimp yaml-cpp::yaml-cpp)<br><br><span class="hljs-comment"># 检查项目是否有dependeicies目录，如果存在，则在使用add_custom_command命令在构建后将dependencies目录中的文件复制到项目的输出目录</span><br><span class="hljs-keyword">set</span>(SOURCE_DIR <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/dependencies&quot;</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">EXISTS</span> <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> Camera POST_BUILD<br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>        <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span> $&lt;TARGET_FILE_DIR:Camera&gt;)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/06/OpenGL%E5%85%A5%E9%97%A8007%E2%80%94%E2%80%94%E6%91%84%E5%83%8F%E6%9C%BA/image-20241106235015805.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门006——着色器在纹理混合中的应用</title>
    <link href="/2024/11/05/OpenGL%E5%85%A5%E9%97%A8006%E2%80%94%E2%80%94%E7%9D%80%E8%89%B2%E5%99%A8%E5%9C%A8%E7%BA%B9%E7%90%86%E6%B7%B7%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/11/05/OpenGL%E5%85%A5%E9%97%A8006%E2%80%94%E2%80%94%E7%9D%80%E8%89%B2%E5%99%A8%E5%9C%A8%E7%BA%B9%E7%90%86%E6%B7%B7%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本节将理解顶点和片段着色器在纹理混合中的应用</p><h1 id="一些概念">一些概念</h1><h2 id="纹理">纹理</h2><ul><li><strong>概述：</strong>纹理是一张二维图像或一组数据，用来给3D模型赋予更多细节，模拟出更为复杂和逼真的外观。比如一块简单的立方体可以通过纹理变得像是由木材、金属或石头制作，而不需要为此增加实际的几何复杂度</li></ul><p><strong>纹理映射：</strong>是将纹理图像的坐标（通常是二维UV坐标）映射到3D模型的表面，UV坐标系用于指定纹理在模型表面上的位置，其中：</p><ul><li>U表示横向坐标（从左到右）</li><li>V表示纵向坐标（从上到下）</li></ul><p>每个模型顶点都有一个或多个UV坐标，使得纹理能够精确地贴合到模型表面</p><p><strong>纹理类型：</strong></p><ul><li>颜色纹理：最常见的纹理类型，用于赋予物体颜色和图案</li><li>法线纹理：用于模拟复杂的表面细节，如凹凸感和细小的表面特征，而无需修改几何体</li><li>位移纹理：用来改变模型的几何结构，实际移动顶点以产生真实的凹凸效果</li><li>环境贴图：用于模拟反射或折射效果，创建逼真的镜面或水面效果</li></ul><h2 id="时间依赖动画">时间依赖动画</h2><p><strong>概述：</strong>使用时间变量来控制动画的状态变换，以确保动画帧以固定的速度播放或根据外部条件动态调整。</p><p><strong>时间步进和概率：</strong>动画通常分为帧，每一帧代表动画在特定时间点上的状态，为了使动画平滑，必须考虑帧率（每秒显示的帧数）和时间步进，常见方法包括固定时间步进和可变时间步进</p><p><strong>插值方法：</strong>时间依赖动画通常使用插值技术，在两个关键帧之间平滑过渡：</p><ul><li>线性插值：在起始点和结束点之间按线性比例过渡，适合简单的动画</li><li>贝塞尔曲线和样条插值：用于创建更复杂、平滑的曲线运行，适合有自然过渡需求的动画，如角色行走或物体掉落</li></ul><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong>本节将理解顶点和片段着色器在纹理混合中的应用</p><p><strong>环境：</strong></p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="dependencies">dependencies</h2><h3 id="shader.fs">shader.fs</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">// 指定OpenGL着色器语言的版本为3.30</span><br>#version <span class="hljs-number">330</span> core<br><span class="hljs-comment">// 输入变量，表示纹理坐标</span><br><span class="hljs-keyword">in</span> vec2 TexCoord;<br><span class="hljs-comment">// 输出变量，表示片段的最终颜色</span><br>out vec4 FragColor;<br><span class="hljs-comment">// uniform变量，表示第一个纹理</span><br>uniform sampler2D texture0;<br><span class="hljs-comment">// uniform变量，表示第二个纹理</span><br>uniform sampler2D texture1;<br><span class="hljs-comment">// uniform变量，表示混合比例</span><br>uniform float blendRatio;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><span class="hljs-comment">// 使用mix函数根据blendRatio混合两个纹理的颜色，并将结果赋值给输出变量FragColor</span><br>FragColor <span class="hljs-operator">=</span> mix(texture(texture0, TexCoord), texture(texture1, TexCoord), blendRatio);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shader.vs">shader.vs</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vs">#version 330 core<br>layout (location = 0) in vec2 aPos;<br>layout (location = 1) in vec2 aTex;<br><br>out vec2 TexCoord;<br><br>void main() &#123;<br>gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);<br>TexCoord = aTex;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="teenager.png">teenager.png</h3><img src="/2024/11/05/OpenGL%E5%85%A5%E9%97%A8006%E2%80%94%E2%80%94%E7%9D%80%E8%89%B2%E5%99%A8%E5%9C%A8%E7%BA%B9%E7%90%86%E6%B7%B7%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/image-20241104161400601.png" class=""><h3 id="tex.png">tex.png</h3><img src="/2024/11/05/OpenGL%E5%85%A5%E9%97%A8006%E2%80%94%E2%80%94%E7%9D%80%E8%89%B2%E5%99%A8%E5%9C%A8%E7%BA%B9%E7%90%86%E6%B7%B7%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/image-20241104161423902.png" class=""><h2 id="utils">utils</h2><h3 id="windowfactory.h">windowFactory.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span> <span class="hljs-comment">// gald前面不能包含任何opengl头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLFWWindowFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>() &#123;&#125;<br>    <span class="hljs-comment">// 构造函数，初始化窗口</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title) &#123;<br>        <span class="hljs-comment">// 初始化glfw</span><br>        <span class="hljs-built_in">glfwInit</span>();<br>        <span class="hljs-comment">// 设置opengl版本</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>        <span class="hljs-comment">// 创建glfw窗口</span><br>        <span class="hljs-keyword">this</span>-&gt;window = <span class="hljs-built_in">glfwCreateWindow</span>(width, height, title, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;window == <span class="hljs-literal">NULL</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">glfwTerminate</span>();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置当前窗口的上下文</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>        <span class="hljs-comment">// 加载所有opengl函数指针</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">// 再次设置当前窗口的上下文，确保当前上下文仍然是刚刚创建的窗口，是一个安全措施</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取窗口对象</span><br>    <span class="hljs-function">GLFWwindow* <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;window;<br>    &#125;<br><br>    <span class="hljs-comment">// 运行窗口，传入一个自定义的更新函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; updateFunc)</span> </span>&#123;<br>        <span class="hljs-comment">// 启用深度测试，opengl将在绘制每个像素之前比较其深度值，以确定该像素是否应该被绘制</span><br>        <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br><br>        <span class="hljs-comment">// 循环渲染</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(<span class="hljs-keyword">this</span>-&gt;window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>            <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>            <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>            <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br><br>            <span class="hljs-comment">// 处理输入</span><br>            GLFWWindowFactory::<span class="hljs-built_in">process_input</span>(<span class="hljs-keyword">this</span>-&gt;window);<br><br>            <span class="hljs-comment">// 执行更新函数</span><br>            <span class="hljs-built_in">updateFunc</span>();<br><br>            <span class="hljs-comment">// 交换缓冲区</span><br>            <span class="hljs-built_in">glfwSwapBuffers</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>            <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>            <span class="hljs-built_in">glfwPollEvents</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 窗口大小改变的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>        <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>        <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理输入</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>        <span class="hljs-comment">// 按下ESC键时进入if块</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>            <span class="hljs-comment">// 关闭窗口</span><br>            <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 窗口对象</span><br>    GLFWwindow* window;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="shader.h">shader.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SHADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-keyword">using</span> std::ifstream;<br><span class="hljs-keyword">using</span> std::stringstream;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shader</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Shader</span>() &#123;&#125;<br>    <span class="hljs-comment">// 着色器程序ID</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ID;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Shader</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertexPath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentPath) &#123;<br>        string vertexCode;<br>        string fragmentCode;<br>        ifstream vShaderFile;<br>        ifstream fShaderFile;<br><br>        <span class="hljs-comment">// 确保ifstream对象可以抛出异常</span><br>        vShaderFile.<span class="hljs-built_in">exceptions</span>(ifstream::failbit | ifstream::badbit);<br>        fShaderFile.<span class="hljs-built_in">exceptions</span>(ifstream::failbit | ifstream::badbit);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 打开文件</span><br>            vShaderFile.<span class="hljs-built_in">open</span>(vertexPath);<br>            fShaderFile.<span class="hljs-built_in">open</span>(fragmentPath);<br>            <span class="hljs-comment">// 读取文件缓冲区内容到stream中</span><br>            stringstream vShaderStream, fShaderStream;<br>            vShaderStream &lt;&lt; vShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            fShaderStream &lt;&lt; fShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            <span class="hljs-comment">// 关闭文件处理器</span><br>            vShaderFile.<span class="hljs-built_in">close</span>();<br>            fShaderFile.<span class="hljs-built_in">close</span>();<br>            <span class="hljs-comment">// 将stream转换为字符串</span><br>            vertexCode = vShaderStream.<span class="hljs-built_in">str</span>();<br>            fragmentCode = fShaderStream.<span class="hljs-built_in">str</span>();<br>        &#125; <span class="hljs-built_in">catch</span> (ifstream::failure&amp; e) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* vShaderCode = vertexCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fShaderCode = fragmentCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-comment">// 编译着色器</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex, fragment;<br>        <span class="hljs-comment">// 顶点着色器</span><br>        vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(vertex, <span class="hljs-number">1</span>, &amp;vShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(vertex);<br>        <span class="hljs-built_in">checkCompileErrors</span>(vertex, <span class="hljs-string">&quot;VERTEX&quot;</span>);<br>        <span class="hljs-comment">// 片段着色器</span><br>        fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(fragment, <span class="hljs-number">1</span>, &amp;fShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(fragment);<br>        <span class="hljs-built_in">checkCompileErrors</span>(fragment, <span class="hljs-string">&quot;FRAGMENT&quot;</span>);<br>        <span class="hljs-comment">// 着色器程序</span><br>        ID = <span class="hljs-built_in">glCreateProgram</span>();<br>        <span class="hljs-built_in">glAttachShader</span>(ID, vertex);<br>        <span class="hljs-built_in">glAttachShader</span>(ID, fragment);<br>        <span class="hljs-built_in">glLinkProgram</span>(ID);<br>        <span class="hljs-built_in">checkCompileErrors</span>(ID, <span class="hljs-string">&quot;PROGRAM&quot;</span>);<br>        <span class="hljs-comment">// 删除着色器</span><br>        <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>        <span class="hljs-built_in">glDeleteShader</span>(fragment);<br>    &#125;<br><br>    <span class="hljs-comment">// 激活着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">glUseProgram</span>(ID);<br>    &#125;<br><br>    <span class="hljs-comment">// 实用的uniform工具函数</span><br>    <span class="hljs-comment">// 用于在着色器程序中设置uniform值</span><br>    <span class="hljs-comment">// 设置一个布尔类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBool</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">bool</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), (<span class="hljs-type">int</span>)value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个整型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个浮点类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFloat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec2&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform2fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform2f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec3&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform3fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform3f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y, z);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec4&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform4fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z, <span class="hljs-type">float</span> w)</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform4f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y, z, w);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个mat2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat2&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix2fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">//  设置一个mat3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat3&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix3fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个mat4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat4&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix4fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 检查着色器编译/链接错误</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkCompileErrors</span><span class="hljs-params">(GLuint shader, string type)</span> </span>&#123;<br>        GLint success;<br>        GLchar infoLog[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-string">&quot;PROGRAM&quot;</span>) &#123;<br>            <span class="hljs-built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">glGetShaderInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">glGetProgramInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                cout &lt;&lt; <span class="hljs-string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.h">RectangleModel.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;shader.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleModel</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">RectangleModel</span>(<span class="hljs-type">const</span> Shader&amp; shader);<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">RectangleModel</span>();<br>    <br>    <span class="hljs-comment">// 绘制矩形</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    Shader shader;<br>    <br>    <span class="hljs-comment">// 着色器程序</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram;<br>    <span class="hljs-comment">// 纹理</span><br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;texture;<br>    <br>    <br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compileShaders</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setElements</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadTexture</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 绑定纹理</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindTexture</span><span class="hljs-params">(GLuint&amp; textured, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.cpp">RectangleModel.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stb_image.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 构造函数</span><br>RectangleModel::<span class="hljs-built_in">RectangleModel</span>(<span class="hljs-type">const</span> Shader&amp; shader) : <span class="hljs-built_in">shader</span>(shader) &#123;<br>    <span class="hljs-comment">// 加载纹理</span><br>    <span class="hljs-built_in">loadTexture</span>();<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-built_in">setElements</span>();<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>RectangleModel::~<span class="hljs-built_in">RectangleModel</span>() &#123;<br>    <span class="hljs-comment">// 删除VAO</span><br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 删除VBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 删除EBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>&#125;<br><br><span class="hljs-comment">/// public</span><br><span class="hljs-comment">// 绘制矩形</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用着色器程序</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br><br>    <span class="hljs-comment">// 获取当前时间</span><br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-comment">// 计算毫秒数</span><br>    <span class="hljs-keyword">auto</span> duration = now.<span class="hljs-built_in">time_since_epoch</span>();<br>    <span class="hljs-type">double</span> milliseconds = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="hljs-built_in">count</span>();<br>    <span class="hljs-comment">// 计算混合比例</span><br>    <span class="hljs-type">float</span> blendRatio = <span class="hljs-number">0.5f</span> * (std::<span class="hljs-built_in">sin</span>(milliseconds / <span class="hljs-number">1000.0</span>) + <span class="hljs-number">1.0f</span>);<br>    <span class="hljs-comment">// 设置uniform变量</span><br>    shader.<span class="hljs-built_in">setFloat</span>(<span class="hljs-string">&quot;blendRatio&quot;</span>, blendRatio);<br><br>    <span class="hljs-comment">// 绘制矩形，即绘制两个三角形，GL_UNSIGNED_INT表示索引数组中的每个元素都是一个无符号整数</span><br>    <span class="hljs-comment">// 六个矩形</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">36</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/// private</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::setElements</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-comment">// 矩形1</span><br>        <span class="hljs-number">-0.9f</span>, <span class="hljs-number">-0.9f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.9f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.9f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br><br>        <span class="hljs-comment">// 矩形2</span><br>        <span class="hljs-number">-0.4f</span>, <span class="hljs-number">-0.9f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.9f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.4f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">0.0f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br><br>        <span class="hljs-comment">// 矩形3</span><br>        <span class="hljs-number">0.1f</span>, <span class="hljs-number">-0.9f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.9f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.1f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br><br>        <span class="hljs-comment">// 矩形4</span><br>        <span class="hljs-number">-0.9f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.9f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br><br>        <span class="hljs-comment">// 矩形5</span><br>        <span class="hljs-number">-0.4f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.4f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>,<br><br>        <span class="hljs-comment">// 矩形6</span><br>        <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span><br>    &#125;;<br>    <span class="hljs-comment">// 索引数据</span><br>    <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-comment">// 矩形 1</span><br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<br><br>        <span class="hljs-comment">// 矩形 2</span><br>        <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<br>        <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>,<br><br>        <span class="hljs-comment">// 矩形 3</span><br>        <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>,<br>        <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>,<br><br>        <span class="hljs-comment">// 矩形 4</span><br>        <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>,<br>        <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>,<br><br>        <span class="hljs-comment">// 矩形5</span><br>        <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>,<br>        <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>,<br><br>        <span class="hljs-comment">// 矩形6</span><br>        <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>,<br>        <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 生成一个VAO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 绑定VAO，使其成为当前操作的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 生成一个VBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 绑定VBO, 使其成为当前操作的VBO，GL_ARRAY_BUFFER表示顶点缓冲区</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 为当前绑定的VBO创建并初始化数据存储，GL_STATIC_DRAW表示数据将一次性提供给缓冲区，并且在之后的绘制过程中不会频繁更改</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>    <span class="hljs-comment">// 生成一个EBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>    <span class="hljs-comment">// 绑定EBO，使其成为当前操作的EBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-comment">// 传递索引数据</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 定义顶点属性的布局</span><br>    <span class="hljs-comment">// - index：顶点属性的索引</span><br>    <span class="hljs-comment">// - size：每个顶点属性的数量</span><br>    <span class="hljs-comment">// - type：数据类型</span><br>    <span class="hljs-comment">// - normalized：是否将非浮点数值归一化</span><br>    <span class="hljs-comment">// - stride：连续顶点属性之间的间隔</span><br>    <span class="hljs-comment">// - pointer：数据在缓冲区中的偏移量</span><br>    <span class="hljs-comment">// 设置顶点属性指针，位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 设置顶点属性指针，颜色属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-comment">// 启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 加载纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::loadTexture</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; path = &#123; <span class="hljs-string">&quot;teenager.png&quot;</span>, <span class="hljs-string">&quot;tex.png&quot;</span> &#125;;<br>    texture.<span class="hljs-built_in">resize</span>(path.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-built_in">bindTexture</span>(texture[i], path[i].<span class="hljs-built_in">c_str</span>());<br>    &#125;<br>    <span class="hljs-comment">// 参数传入指定要激活的纹理单元，例如GL_TEXTURE0/1/*</span><br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, texture[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 使用着色器程序</span><br>    shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 设置uniform变量</span><br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture0&quot;</span>, <span class="hljs-number">0</span>);<br>    shader.<span class="hljs-built_in">setInt</span>(<span class="hljs-string">&quot;texture1&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 绑定纹理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::bindTexture</span><span class="hljs-params">(GLuint&amp; textureId, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span> </span>&#123;<br>    <span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;textureId);<br>    <span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, textureId);<br>    <span class="hljs-comment">// 设置纹理环绕和过滤方式</span><br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br>    <span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    <span class="hljs-comment">// 加载并生成纹理</span><br>    <span class="hljs-built_in">stbi_set_flip_vertically_on_load</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> width, height, nrChannels;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* data = <span class="hljs-built_in">stbi_load</span>(path, &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (data) &#123;<br>        GLenum format;<br>        <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">4</span>)<br>            format = GL_RGBA;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nrChannels == <span class="hljs-number">3</span>)<br>            format = GL_RGB;<br>        <span class="hljs-keyword">else</span><br>            format = GL_RED;<br><br>        <span class="hljs-built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="hljs-number">0</span>, format, width, height, <span class="hljs-number">0</span>, format, GL_UNSIGNED_BYTE, data);<br>        <span class="hljs-built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-built_in">stbi_image_free</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个着色器对象</span><br>    <span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">&quot;shader.vs&quot;</span>, <span class="hljs-string">&quot;shader.fs&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个矩形模型对象</span><br>    <span class="hljs-function">RectangleModel <span class="hljs-title">rectangle</span><span class="hljs-params">(shader)</span></span>;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>        rectangle.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(Shader)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glm CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(Shader main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(Shader PRIVATE glad::glad glfw glm::glm)<br><br><span class="hljs-comment"># 检查项目是否有dependeicies目录，如果存在，则在使用add_custom_command命令在构建后将dependencies目录中的文件复制到项目的输出目录</span><br><span class="hljs-keyword">set</span>(SOURCE_DIR <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/dependencies&quot;</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">EXISTS</span> <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> Shader POST_BUILD<br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>        <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span> $&lt;TARGET_FILE_DIR:Shader&gt;)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/05/OpenGL%E5%85%A5%E9%97%A8006%E2%80%94%E2%80%94%E7%9D%80%E8%89%B2%E5%99%A8%E5%9C%A8%E7%BA%B9%E7%90%86%E6%B7%B7%E5%90%88%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/image-20241105110453273.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门005——使用Shader类管理着色器</title>
    <link href="/2024/11/03/OpenGL%E5%85%A5%E9%97%A8005%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Shader%E7%B1%BB%E7%AE%A1%E7%90%86%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    <url>/2024/11/03/OpenGL%E5%85%A5%E9%97%A8005%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Shader%E7%B1%BB%E7%AE%A1%E7%90%86%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>本节将把着色器有关的代码抽象出来为外部文件，通过OpenGL的API与着色器进行交互，从外部文件中加载着色器代码</p><h1 id="一些概念">一些概念</h1><h2 id="统一变量">统一变量</h2><p><strong>概述：</strong> 在OpenGL着色器中，统一变量(unfiormvariable)是一种全局变量，可以从应用程序代码传递到着色器中，统一变量在着色器的整个生命周期内保持不变，通常用于传递一些不会频繁变化的数据，例如变换矩阵、材质属性、光源参数等</p><p><strong>特点：</strong></p><ul><li>全局性</li><li>只读性</li><li>应用程序设置</li></ul><p><strong>声明：</strong> 在着色器中，使用uniform关键字声明统一变量</p><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 学习如何使用Shader类来管理OpenGL的着色器</p><p><strong>环境：</strong></p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="dependencies">dependencies</h2><h3 id="shader.fs">shader.fs</h3><p><strong>作用：</strong> 着色器代码</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-comment">// 指定OpenGL着色器语言的版本为3.30</span><br>#version <span class="hljs-number">330</span> core<br><span class="hljs-comment">// 输入变量，表示传入的颜色值</span><br><span class="hljs-keyword">in</span> vec3 ourColor;<br><span class="hljs-comment">// 输出变量，表示片段的最终颜色</span><br>out vec4 FragColor;<br><br><span class="hljs-keyword">void</span> main() &#123;<br><span class="hljs-comment">// 将输入的颜色值转换为vec4，并将alpha值设置为1.0，赋值给输出变量</span><br>FragColor <span class="hljs-operator">=</span> vec4(ourColor, <span class="hljs-number">1.0</span>f);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="shader.vs">shader.vs</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vs">#version 330 core<br>layout (location = 0) in vec2 aPos;<br>layout (location = 1) in vec3 aColor;<br><br>out vec3 ourColor;<br><br>void main()<br>&#123;<br>gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);<br>ourColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="utils">utils</h2><h3 id="windowfactory.h">windowFactory.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span> <span class="hljs-comment">// gald前面不能包含任何opengl头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLFWWindowFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>() &#123;&#125;<br>    <span class="hljs-comment">// 构造函数，初始化窗口</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title) &#123;<br>        <span class="hljs-comment">// 初始化glfw</span><br>        <span class="hljs-built_in">glfwInit</span>();<br>        <span class="hljs-comment">// 设置opengl版本</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>        <span class="hljs-comment">// 创建glfw窗口</span><br>        <span class="hljs-keyword">this</span>-&gt;window = <span class="hljs-built_in">glfwCreateWindow</span>(width, height, title, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;window == <span class="hljs-literal">NULL</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">glfwTerminate</span>();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置当前窗口的上下文</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>        <span class="hljs-comment">// 加载所有opengl函数指针</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">// 再次设置当前窗口的上下文，确保当前上下文仍然是刚刚创建的窗口，是一个安全措施</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取窗口对象</span><br>    <span class="hljs-function">GLFWwindow* <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;window;<br>    &#125;<br><br>    <span class="hljs-comment">// 运行窗口，传入一个自定义的更新函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; updateFunc)</span> </span>&#123;<br>        <span class="hljs-comment">// 启用深度测试，opengl将在绘制每个像素之前比较其深度值，以确定该像素是否应该被绘制</span><br>        <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br><br>        <span class="hljs-comment">// 循环渲染</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(<span class="hljs-keyword">this</span>-&gt;window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>            <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>            <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>            <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br><br>            <span class="hljs-comment">// 处理输入</span><br>            GLFWWindowFactory::<span class="hljs-built_in">process_input</span>(<span class="hljs-keyword">this</span>-&gt;window);<br><br>            <span class="hljs-comment">// 执行更新函数</span><br>            <span class="hljs-built_in">updateFunc</span>();<br><br>            <span class="hljs-comment">// 交换缓冲区</span><br>            <span class="hljs-built_in">glfwSwapBuffers</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>            <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>            <span class="hljs-built_in">glfwPollEvents</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 窗口大小改变的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>        <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>        <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理输入</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>        <span class="hljs-comment">// 按下ESC键时进入if块</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>            <span class="hljs-comment">// 关闭窗口</span><br>            <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 窗口对象</span><br>    GLFWwindow* window;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="shader.h">shader.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SHADER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHADER_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glm/glm.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::string;<br><span class="hljs-keyword">using</span> std::ifstream;<br><span class="hljs-keyword">using</span> std::stringstream;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shader</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Shader</span>() &#123;&#125;<br>    <span class="hljs-comment">// 着色器程序ID</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ID;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Shader</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertexPath, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentPath) &#123;<br>        string vertexCode;<br>        string fragmentCode;<br>        ifstream vShaderFile;<br>        ifstream fShaderFile;<br><br>        <span class="hljs-comment">// 确保ifstream对象可以抛出异常</span><br>        vShaderFile.<span class="hljs-built_in">exceptions</span>(ifstream::failbit | ifstream::badbit);<br>        fShaderFile.<span class="hljs-built_in">exceptions</span>(ifstream::failbit | ifstream::badbit);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 打开文件</span><br>            vShaderFile.<span class="hljs-built_in">open</span>(vertexPath);<br>            fShaderFile.<span class="hljs-built_in">open</span>(fragmentPath);<br>            <span class="hljs-comment">// 读取文件缓冲区内容到stream中</span><br>            stringstream vShaderStream, fShaderStream;<br>            vShaderStream &lt;&lt; vShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            fShaderStream &lt;&lt; fShaderFile.<span class="hljs-built_in">rdbuf</span>();<br>            <span class="hljs-comment">// 关闭文件处理器</span><br>            vShaderFile.<span class="hljs-built_in">close</span>();<br>            fShaderFile.<span class="hljs-built_in">close</span>();<br>            <span class="hljs-comment">// 将stream转换为字符串</span><br>            vertexCode = vShaderStream.<span class="hljs-built_in">str</span>();<br>            fragmentCode = fShaderStream.<span class="hljs-built_in">str</span>();<br>        &#125; <span class="hljs-built_in">catch</span> (ifstream::failure&amp; e) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* vShaderCode = vertexCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fShaderCode = fragmentCode.<span class="hljs-built_in">c_str</span>();<br>        <span class="hljs-comment">// 编译着色器</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertex, fragment;<br>        <span class="hljs-comment">// 顶点着色器</span><br>        vertex = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(vertex, <span class="hljs-number">1</span>, &amp;vShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(vertex);<br>        <span class="hljs-built_in">checkCompileErrors</span>(vertex, <span class="hljs-string">&quot;VERTEX&quot;</span>);<br>        <span class="hljs-comment">// 片段着色器</span><br>        fragment = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>        <span class="hljs-built_in">glShaderSource</span>(fragment, <span class="hljs-number">1</span>, &amp;fShaderCode, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">glCompileShader</span>(fragment);<br>        <span class="hljs-built_in">checkCompileErrors</span>(fragment, <span class="hljs-string">&quot;FRAGMENT&quot;</span>);<br>        <span class="hljs-comment">// 着色器程序</span><br>        ID = <span class="hljs-built_in">glCreateProgram</span>();<br>        <span class="hljs-built_in">glAttachShader</span>(ID, vertex);<br>        <span class="hljs-built_in">glAttachShader</span>(ID, fragment);<br>        <span class="hljs-built_in">glLinkProgram</span>(ID);<br>        <span class="hljs-built_in">checkCompileErrors</span>(ID, <span class="hljs-string">&quot;PROGRAM&quot;</span>);<br>        <span class="hljs-comment">// 删除着色器</span><br>        <span class="hljs-built_in">glDeleteShader</span>(vertex);<br>        <span class="hljs-built_in">glDeleteShader</span>(fragment);<br>    &#125;<br><br>    <span class="hljs-comment">// 激活着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">glUseProgram</span>(ID);<br>    &#125;<br><br>    <span class="hljs-comment">// 实用的uniform工具函数</span><br>    <span class="hljs-comment">// 用于在着色器程序中设置uniform值</span><br>    <span class="hljs-comment">// 设置一个布尔类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setBool</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">bool</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), (<span class="hljs-type">int</span>)value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个整型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1i</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个浮点类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFloat</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform1f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), value);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec2&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform2fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform2f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec3&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform3fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform3f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y, z);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个vec4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::vec4&amp; value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform4fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, &amp;value[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 设置一个vec4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setVec4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z, <span class="hljs-type">float</span> w)</span> </span>&#123;<br>        <span class="hljs-built_in">glUniform4f</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), x, y, z, w);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个mat2类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat2</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat2&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix2fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">//  设置一个mat3类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat3</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat3&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix3fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个mat4类型的uniform变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMat4</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> glm::mat4&amp; mat)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">glUniformMatrix4fv</span>(<span class="hljs-built_in">glGetUniformLocation</span>(ID, name.<span class="hljs-built_in">c_str</span>()), <span class="hljs-number">1</span>, GL_FALSE, &amp;mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 检查着色器编译/链接错误</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkCompileErrors</span><span class="hljs-params">(GLuint shader, string type)</span> </span>&#123;<br>        GLint success;<br>        GLchar infoLog[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">if</span> (type != <span class="hljs-string">&quot;PROGRAM&quot;</span>) &#123;<br>            <span class="hljs-built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">glGetShaderInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">glGetProgramiv</span>(shader, GL_LINK_STATUS, &amp;success);<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-built_in">glGetProgramInfoLog</span>(shader, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>                cout &lt;&lt; <span class="hljs-string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.h">RectangleModel.h</h3><p><strong>作用：</strong> 矩阵模型的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;shader.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleModel</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">RectangleModel</span>(<span class="hljs-type">const</span> Shader&amp; shader);<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">RectangleModel</span>();<br>    <br>    <span class="hljs-comment">// 绘制矩形</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    Shader shader;<br>    <br>    <span class="hljs-comment">// 着色器程序</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram;<br>    <br>    <br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compileShaders</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setElements</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.cpp">RectangleModel.cpp</h3><p><strong>作用：</strong> 三角形模型的具体实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 构造函数</span><br>RectangleModel::<span class="hljs-built_in">RectangleModel</span>(<span class="hljs-type">const</span> Shader&amp; shader) : <span class="hljs-built_in">shader</span>(shader) &#123;<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-built_in">setElements</span>();<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>RectangleModel::~<span class="hljs-built_in">RectangleModel</span>() &#123;<br>    <span class="hljs-comment">// 删除VAO</span><br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 删除VBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 删除EBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>&#125;<br><br><span class="hljs-comment">/// public</span><br><span class="hljs-comment">// 绘制矩形</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用着色器程序</span><br>    <span class="hljs-keyword">this</span>-&gt;shader.<span class="hljs-built_in">use</span>();<br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-comment">// 绘制矩形，即绘制两个三角形，GL_UNSIGNED_INT表示索引数组中的每个元素都是一个无符号整数</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/// private</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::setElements</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顶点数据</span><br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,<br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.0f</span>,<span class="hljs-number">1.0f</span>,<span class="hljs-number">0.0f</span>,<br>    &#125;;<br>    <span class="hljs-comment">// 索引数据</span><br>    <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, &#125;;<br><br>    <span class="hljs-comment">// 生成一个VAO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 绑定VAO，使其成为当前操作的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 生成一个VBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 绑定VBO, 使其成为当前操作的VBO，GL_ARRAY_BUFFER表示顶点缓冲区</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 为当前绑定的VBO创建并初始化数据存储，GL_STATIC_DRAW表示数据将一次性提供给缓冲区，并且在之后的绘制过程中不会频繁更改</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>    <span class="hljs-comment">// 生成一个EBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>    <span class="hljs-comment">// 绑定EBO，使其成为当前操作的EBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-comment">// 传递索引数据</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 定义顶点属性的布局</span><br>    <span class="hljs-comment">// - index：顶点属性的索引</span><br>    <span class="hljs-comment">// - size：每个顶点属性的数量，每个顶点有三个分享</span><br>    <span class="hljs-comment">// - type：数据类型</span><br>    <span class="hljs-comment">// - normalized：是否将非浮点数值归一化</span><br>    <span class="hljs-comment">// - stride：连续顶点属性之间的间隔</span><br>    <span class="hljs-comment">// - pointer：数据在缓冲区中的偏移量</span><br>    <span class="hljs-comment">// 设置顶点属性指针，位置属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 设置顶点属性指针，颜色属性</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">5</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)(<span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-comment">// 启用顶点属性</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个着色器对象</span><br>    <span class="hljs-function">Shader <span class="hljs-title">shader</span><span class="hljs-params">(<span class="hljs-string">&quot;shader.vs&quot;</span>, <span class="hljs-string">&quot;shader.fs&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 创建一个矩形模型对象</span><br>    <span class="hljs-function">RectangleModel <span class="hljs-title">rectangle</span><span class="hljs-params">(shader)</span></span>;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>        rectangle.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(Shader)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glm CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(Shader main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(Shader PRIVATE glad::glad glfw glm::glm)<br><br><span class="hljs-comment"># 检查项目是否有dependeicies目录，如果存在，则在使用add_custom_command命令在构建后将dependencies目录中的文件复制到项目的输出目录</span><br><span class="hljs-keyword">set</span>(SOURCE_DIR <span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/dependencies&quot;</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">EXISTS</span> <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> Shader POST_BUILD<br>        <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_directory<br>        <span class="hljs-variable">$&#123;SOURCE_DIR&#125;</span> $&lt;TARGET_FILE_DIR:Shader&gt;)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/03/OpenGL%E5%85%A5%E9%97%A8005%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Shader%E7%B1%BB%E7%AE%A1%E7%90%86%E7%9D%80%E8%89%B2%E5%99%A8/image-20241103164109981.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门004——使用EBO绘制矩形</title>
    <link href="/2024/11/01/OpenGL%E5%85%A5%E9%97%A8004%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8EBO%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2/"/>
    <url>/2024/11/01/OpenGL%E5%85%A5%E9%97%A8004%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8EBO%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p>hexo clean hexo s 本节将利用EBO来绘制矩形</p><h1 id="一些概念">一些概念</h1><h2 id="ebo">EBO</h2><p><strong>概述：</strong> Element Buffer Object用于存储顶点的索引数据，以便在绘制图形时可以重用顶点数据，从而减少内存使用和提供高性能</p><p><strong>使用步骤：</strong></p><ol type="1"><li>定义顶点和索引数据：<ul><li>顶点数据包含图形的顶点坐标</li><li>索引数据定义了绘制图形的顺序</li></ul></li><li>生成和绑定VAO</li><li>生成和绑定VBO</li><li>传递顶点数据到VBO</li><li>生成和绑定EBO：<ul><li>使用glGenBuffers生成EBO</li><li>使用glBindBuffer绑定EBO</li></ul></li><li>传递索引数据到EBO：使用glBufferData将索引数据传递到EBO</li><li>绘制图形：使用glDrawElements函数，根据EBO中的索引数据绘制图形</li></ol><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 利用EBO绘制一个矩形</p><p><strong>环境：</strong></p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="utils">utils</h2><p>创建utils目录，将windowFactory.h，RectangleModel.h，RectangleModel.cpp文件放到这个目录下面</p><h3 id="windowfactory.h">windowFactory.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span> <span class="hljs-comment">// gald前面不能包含任何opengl头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLFWWindowFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>() &#123;&#125;<br>    <span class="hljs-comment">// 构造函数，初始化窗口</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title) &#123;<br>        <span class="hljs-comment">// 初始化glfw</span><br>        <span class="hljs-built_in">glfwInit</span>();<br>        <span class="hljs-comment">// 设置opengl版本</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>        <span class="hljs-comment">// 创建glfw窗口</span><br>        <span class="hljs-keyword">this</span>-&gt;window = <span class="hljs-built_in">glfwCreateWindow</span>(width, height, title, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;window == <span class="hljs-literal">NULL</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">glfwTerminate</span>();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置当前窗口的上下文</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>        <span class="hljs-comment">// 加载所有opengl函数指针</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">// 再次设置当前窗口的上下文，确保当前上下文仍然是刚刚创建的窗口，是一个安全措施</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取窗口对象</span><br>    <span class="hljs-function">GLFWwindow* <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;window;<br>    &#125;<br><br>    <span class="hljs-comment">// 运行窗口，传入一个自定义的更新函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; updateFunc)</span> </span>&#123;<br>        <span class="hljs-comment">// 启用深度测试，opengl将在绘制每个像素之前比较其深度值，以确定该像素是否应该被绘制</span><br>        <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br><br>        <span class="hljs-comment">// 循环渲染</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(<span class="hljs-keyword">this</span>-&gt;window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>            <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>            <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>            <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br><br>            <span class="hljs-comment">// 处理输入</span><br>            GLFWWindowFactory::<span class="hljs-built_in">process_input</span>(<span class="hljs-keyword">this</span>-&gt;window);<br><br>            <span class="hljs-comment">// 执行更新函数</span><br>            <span class="hljs-built_in">updateFunc</span>();<br><br>            <span class="hljs-comment">// 交换缓冲区</span><br>            <span class="hljs-built_in">glfwSwapBuffers</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>            <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>            <span class="hljs-built_in">glfwPollEvents</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 窗口大小改变的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>        <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>        <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理输入</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>        <span class="hljs-comment">// 按下ESC键时进入if块</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>            <span class="hljs-comment">// 关闭窗口</span><br>            <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 窗口对象</span><br>    GLFWwindow* window;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.h">RectangleModel.h</h3><p><strong>作用：</strong> 矩形模型的头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleModel</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">RectangleModel</span>();<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">RectangleModel</span>();<br>    <br>    <span class="hljs-comment">// 绘制矩形</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> EBO;<br>    <br>    <span class="hljs-comment">// 着色器程序</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram;<br>    <br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compileShaders</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setElements</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="rectanglemodel.cpp">RectangleModel.cpp</h3><p><strong>作用：</strong> 三角形模型的具体实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 顶点属性位置</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> VERTEX_ATTR_POSITION = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每个顶点的组件数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_COMPONENTS_PER_VERTEX = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// 构造函数</span><br>RectangleModel::<span class="hljs-built_in">RectangleModel</span>() &#123;<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">compileShaders</span>();<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-built_in">setElements</span>();<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>RectangleModel::~<span class="hljs-built_in">RectangleModel</span>() &#123;<br>    <span class="hljs-comment">// 删除VAO</span><br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 删除VBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 删除EBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>&#125;<br><br><span class="hljs-comment">/// public</span><br><span class="hljs-comment">// 绘制矩形</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用着色器程序</span><br>    <span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-comment">// 绘制矩形，即绘制两个三角形，GL_UNSIGNED_INT表示索引数组中的每个元素都是一个无符号整数</span><br>    <span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/// private</span><br><span class="hljs-comment">// 编译着色器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::compileShaders</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顶点着色器源码</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertexShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span> <span class="hljs-comment">// 指定了GLSL（OpenGL着色器语言）的版本</span><br>        <span class="hljs-string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span> <span class="hljs-comment">// 定义了一个输入变量aPos，它是一个vec3类型的变量, 并且指定了它的位置值为0, 这意味着顶点属性数组的第一个属性将被绑定到这个变量</span><br>        <span class="hljs-string">&quot;void main()\n&quot;</span><br>        <span class="hljs-string">&quot;&#123;\n&quot;</span><br>        <span class="hljs-string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span> <span class="hljs-comment">// 将输入的顶点位置aPos转换为一个四维向量，gl_Postion是OpengGL固定功能管线中用于存储顶点位置的变量</span><br>        <span class="hljs-string">&quot;&#125;\0&quot;</span>;<br><br>    <span class="hljs-comment">// 片段着色器源码</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span> <span class="hljs-comment">// 指定了GLSL（OpenGL着色器语言）的版本</span><br>        <span class="hljs-string">&quot;out vec4 FragColor;\n&quot;</span> <span class="hljs-comment">// 定义了一个输出变量FragColor，它是一个vec4类型的变量，表示片段颜色，out关键字表示这个变量将输出到渲染管线的下一个阶段</span><br>        <span class="hljs-string">&quot;void main()\n&quot;</span><br>        <span class="hljs-string">&quot;&#123;\n&quot;</span><br>        <span class="hljs-string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span> <span class="hljs-comment">// 将输出颜色设置为橙色</span><br>        <span class="hljs-string">&quot;&#125;\n\0&quot;</span>;<br><br>    <span class="hljs-comment">// 构建并编译顶点着色程序</span><br>    <span class="hljs-comment">// 创建一个着色器对象，GL_VERTEX_SHADER表示顶点着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertexShader = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-comment">// 将着色器源码附加到着色器对象上</span><br>    <span class="hljs-built_in">glShaderSource</span>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(vertexShader);<br>    <span class="hljs-comment">// 检查着色器是否编译成功</span><br>    <span class="hljs-type">int</span> success;<br>    <span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(vertexShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span><br>            &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 构建并编译片段着色器</span><br>    <span class="hljs-comment">// 创建一个着色器对象，GL_FRAGMENT_SHADER表示片段着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-comment">// 将着色器源码附加到着色器对象上</span><br>    <span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br>    <span class="hljs-comment">// 检查着色器是否编译成功</span><br>    <span class="hljs-built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span><br>            &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 创建着色器程序对象</span><br>    <span class="hljs-keyword">this</span>-&gt;shaderProgram = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-comment">// 将着色器对象附加到着色器程序上</span><br>    <span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br>    <span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br>    <span class="hljs-comment">// 链接程序对象</span><br>    <span class="hljs-built_in">glLinkProgram</span>(shaderProgram);<br>    <span class="hljs-comment">// 检查链接是否成功</span><br>    <span class="hljs-built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span><br>            &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 删除着色器对象</span><br>    <span class="hljs-built_in">glDeleteShader</span>(vertexShader);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragmentShader);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RectangleModel::setElements</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顶点数据</span><br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">-0.75f</span>,<br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">-0.75f</span>,<br>        <span class="hljs-number">-0.75f</span>, <span class="hljs-number">0.75f</span>,<br>        <span class="hljs-number">0.75f</span>, <span class="hljs-number">0.75f</span><br>    &#125;;<br>    <span class="hljs-comment">// 索引数据</span><br>    <span class="hljs-type">int</span> indices[] = &#123;<br>        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<br>        <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, &#125;;<br>    <br>    <span class="hljs-comment">// 生成一个VAO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 绑定VAO，使其成为当前操作的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 生成一个VBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 绑定VBO, 使其成为当前操作的VBO，GL_ARRAY_BUFFER表示顶点缓冲区</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 为当前绑定的VBO创建并初始化数据存储，GL_STATIC_DRAW表示数据将一次性提供给缓冲区，并且在之后的绘制过程中不会频繁更改</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>    <span class="hljs-comment">// 生成一个EBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;EBO);<br>    <span class="hljs-comment">// 绑定EBO，使其成为当前操作的EBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    <span class="hljs-comment">// 传递索引数据</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);<br>    <br>    <span class="hljs-comment">// 定义顶点属性的布局</span><br>    <span class="hljs-comment">// - index：顶点属性的索引</span><br>    <span class="hljs-comment">// - size：每个顶点属性的数量，每个顶点有三个分享</span><br>    <span class="hljs-comment">// - type：数据类型</span><br>    <span class="hljs-comment">// - normalized：是否将非浮点数值归一化</span><br>    <span class="hljs-comment">// - stride：连续顶点属性之间的间隔</span><br>    <span class="hljs-comment">// - pointer：数据在缓冲区中的偏移量</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(VERTEX_ATTR_POSITION, NUM_COMPONENTS_PER_VERTEX, GL_FLOAT, GL_FALSE, NUM_COMPONENTS_PER_VERTEX * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 启用顶点属性数组</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(VERTEX_ATTR_POSITION);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><p><strong>作用：</strong> 程序入口点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/RectangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 创建一个矩形模型对象</span><br>    RectangleModel rectangle;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>        rectangle.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(HelloFactory)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(HelloFactory main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(HelloFactory PRIVATE glad::glad glfw)<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/01/OpenGL%E5%85%A5%E9%97%A8004%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8EBO%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2/image-20241101165040296.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门003——使用Factory设计模式简化渲染流程</title>
    <link href="/2024/11/01/OpenGL%E5%85%A5%E9%97%A8003%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Factory%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8C%96%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/01/OpenGL%E5%85%A5%E9%97%A8003%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Factory%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8C%96%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>前面两节已经学会了如何使用opengl创建窗口并绘制三角形，我们可以看出有些步骤是固定的，而且都写在main.cpp，这一节我们将了解如何使用Factroy设计模型。将模型渲染逻辑封装在一个单独的类中，简化开发流程，且提高代码复用性。</p><h1 id="一些概念">一些概念</h1><h2 id="factory设计模式">Factory设计模式</h2><p><strong>概述：</strong> 提供了一种将对象的实例化过程封装起来的方式，使得客户端可以通过调用Factroy类的方法来创建对象。</p><p><strong>作用：</strong></p><ul><li>封装对象的创建过程，将对象的实例化过程封装在Factory类中，客户端可以通过调用工厂类的方法来创建对象，而无需知道对象的具体实现细节</li><li>隐藏对象的创建逻辑，从而实现对象的创建逻辑和客户端代码的分离</li><li>提高代码的可维护性和可扩展性以及复用性</li></ul><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 使用Factory设计模式绘制一个三角形</p><p><strong>环境：</strong></p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="utils">utils</h2><p>创建utils目录，将windowFactory.h，TriangleModel.h，TriangleMode.cpp文件放到这个目录下面</p><h3 id="windowfactory.h">windowFactory.h</h3><p><strong>作用：</strong> 实现创建窗口对象的Factory类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span> <span class="hljs-comment">// gald前面不能包含任何opengl头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GLFWWindowFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>() &#123;&#125;<br>    <span class="hljs-comment">// 构造函数，初始化窗口</span><br>    <span class="hljs-built_in">GLFWWindowFactory</span>(<span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title) &#123;<br>        <span class="hljs-comment">// 初始化glfw</span><br>        <span class="hljs-built_in">glfwInit</span>();<br>        <span class="hljs-comment">// 设置opengl版本</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>        <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>        <span class="hljs-comment">// 创建glfw窗口</span><br>        <span class="hljs-keyword">this</span>-&gt;window = <span class="hljs-built_in">glfwCreateWindow</span>(width, height, title, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;window == <span class="hljs-literal">NULL</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">glfwTerminate</span>();<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 设置当前窗口的上下文</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>        <span class="hljs-comment">// 加载所有opengl函数指针</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-comment">// 再次设置当前窗口的上下文，确保当前上下文仍然是刚刚创建的窗口，是一个安全措施</span><br>        <span class="hljs-built_in">glfwMakeContextCurrent</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>        <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>        <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(<span class="hljs-keyword">this</span>-&gt;window, framebuffer_size_callback);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取窗口对象</span><br>    <span class="hljs-function">GLFWwindow* <span class="hljs-title">getWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;window;<br>    &#125;<br><br>    <span class="hljs-comment">// 运行窗口，传入一个自定义的更新函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">void</span>()&gt; updateFunc)</span> </span>&#123;<br>        <span class="hljs-comment">// 启用深度测试，opengl将在绘制每个像素之前比较其深度值，以确定该像素是否应该被绘制</span><br>        <span class="hljs-built_in">glEnable</span>(GL_DEPTH_TEST);<br><br>        <span class="hljs-comment">// 循环渲染</span><br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(<span class="hljs-keyword">this</span>-&gt;window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>            <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>            <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>            <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>            <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br><br>            <span class="hljs-comment">// 处理输入</span><br>            GLFWWindowFactory::<span class="hljs-built_in">process_input</span>(<span class="hljs-keyword">this</span>-&gt;window);<br><br>            <span class="hljs-comment">// 执行更新函数</span><br>            <span class="hljs-built_in">updateFunc</span>();<br><br>            <span class="hljs-comment">// 交换缓冲区</span><br>            <span class="hljs-built_in">glfwSwapBuffers</span>(<span class="hljs-keyword">this</span>-&gt;window);<br>            <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>            <span class="hljs-built_in">glfwPollEvents</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 窗口大小改变的回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>        <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>        <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理输入</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>        <span class="hljs-comment">// 按下ESC键时进入if块</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>            <span class="hljs-comment">// 关闭窗口</span><br>            <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 窗口对象</span><br>    GLFWwindow* window;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="trianglemodel.h">TriangleModel.h</h3><p><strong>作用：</strong> 三角模型的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TriangleModel</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">TriangleModel</span>();<br>    <span class="hljs-comment">// 默认析构函数</span><br>    ~<span class="hljs-built_in">TriangleModel</span>();<br>    <br>    <span class="hljs-comment">// 绘制三角形</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-comment">// 着色器程序</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram;<br>    <br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">compileShaders</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setupBuffers</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="trianglemode.cpp">TriangleMode.cpp</h3><p><strong>作用：</strong> 三角形模型的具体实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TriangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 顶点属性位置</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> VERTEX_ATTR_POSITION = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 每个顶点的组件数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_COMPONENTS_PER_VERTEX = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 默认构造函数</span><br>TriangleModel::<span class="hljs-built_in">TriangleModel</span>() &#123;<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">compileShaders</span>();<br>    <span class="hljs-comment">// 设置缓冲区</span><br>    <span class="hljs-built_in">setupBuffers</span>();<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>TriangleModel::~<span class="hljs-built_in">TriangleModel</span>() &#123;<br>    <span class="hljs-comment">// 删除VAO</span><br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 删除VBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>&#125;<br><br><span class="hljs-comment">/// public</span><br><span class="hljs-comment">// 绘制三角形</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TriangleModel::draw</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用着色器程序</span><br>    <span class="hljs-built_in">glUseProgram</span>(<span class="hljs-keyword">this</span>-&gt;shaderProgram);<br>    <span class="hljs-comment">// 绑定VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 绘制三角形</span><br>    <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-comment">/// private</span><br><span class="hljs-comment">// 编译着色器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TriangleModel::compileShaders</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顶点着色器源码</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* vertexShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span> <span class="hljs-comment">// 指定了GLSL（OpenGL着色器语言）的版本</span><br>        <span class="hljs-string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span> <span class="hljs-comment">// 定义了一个输入变量aPos，它是一个vec3类型的变量, 并且指定了它的位置值为0, 这意味着顶点属性数组的第一个属性将被绑定到这个变量</span><br>        <span class="hljs-string">&quot;void main()\n&quot;</span><br>        <span class="hljs-string">&quot;&#123;\n&quot;</span><br>        <span class="hljs-string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span> <span class="hljs-comment">// 将输入的顶点位置aPos转换为一个四维向量，gl_Postion是OpengGL固定功能管线中用于存储顶点位置的变量</span><br>        <span class="hljs-string">&quot;&#125;\0&quot;</span>;<br><br>    <span class="hljs-comment">// 片段着色器源码</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fragmentShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span> <span class="hljs-comment">// 指定了GLSL（OpenGL着色器语言）的版本</span><br>        <span class="hljs-string">&quot;out vec4 FragColor;\n&quot;</span> <span class="hljs-comment">// 定义了一个输出变量FragColor，它是一个vec4类型的变量，表示片段颜色，out关键字表示这个变量将输出到渲染管线的下一个阶段</span><br>        <span class="hljs-string">&quot;void main()\n&quot;</span><br>        <span class="hljs-string">&quot;&#123;\n&quot;</span><br>        <span class="hljs-string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span> <span class="hljs-comment">// 将输出颜色设置为橙色</span><br>        <span class="hljs-string">&quot;&#125;\n\0&quot;</span>;<br><br>    <span class="hljs-comment">// 构建并编译顶点着色程序</span><br>    <span class="hljs-comment">// 创建一个着色器对象，GL_VERTEX_SHADER表示顶点着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertexShader = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-comment">// 将着色器源码附加到着色器对象上</span><br>    <span class="hljs-built_in">glShaderSource</span>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(vertexShader);<br>    <span class="hljs-comment">// 检查着色器是否编译成功</span><br>    <span class="hljs-type">int</span> success;<br>    <span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(vertexShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span><br>            &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 构建并编译片段着色器</span><br>    <span class="hljs-comment">// 创建一个着色器对象，GL_FRAGMENT_SHADER表示片段着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-comment">// 将着色器源码附加到着色器对象上</span><br>    <span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br>    <span class="hljs-comment">// 检查着色器是否编译成功</span><br>    <span class="hljs-built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span><br>            &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 创建着色器程序对象</span><br>    <span class="hljs-keyword">this</span>-&gt;shaderProgram = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-comment">// 将着色器对象附加到着色器程序上</span><br>    <span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br>    <span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br>    <span class="hljs-comment">// 链接程序对象</span><br>    <span class="hljs-built_in">glLinkProgram</span>(shaderProgram);<br>    <span class="hljs-comment">// 检查链接是否成功</span><br>    <span class="hljs-built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span><br>            &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 删除着色器对象</span><br>    <span class="hljs-built_in">glDeleteShader</span>(vertexShader);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragmentShader);<br>&#125;<br><br><span class="hljs-comment">// 设置缓冲区</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TriangleModel::setupBuffers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顶点数据</span><br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,<br><br>        <span class="hljs-number">1.0f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,<br>        <span class="hljs-number">0.25f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 生成一个VAO</span><br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 绑定VAO，使其成为当前操作的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-keyword">this</span>-&gt;VAO);<br>    <span class="hljs-comment">// 生成一个VBO</span><br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;<span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 绑定VBO, 使其成为当前操作的VBO，GL_ARRAY_BUFFER表示顶点缓冲区</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-keyword">this</span>-&gt;VBO);<br>    <span class="hljs-comment">// 为当前绑定的VBO创建并初始化数据存储，GL_STATIC_DRAW表示数据将一次性提供给缓冲区，并且在之后的绘制过程中不会频繁更改</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 定义顶点属性的布局</span><br>    <span class="hljs-comment">// - index：顶点属性的索引</span><br>    <span class="hljs-comment">// - size：每个顶点属性的数量，每个顶点有三个分享</span><br>    <span class="hljs-comment">// - type：数据类型</span><br>    <span class="hljs-comment">// - normalized：是否将非浮点数值归一化</span><br>    <span class="hljs-comment">// - stride：连续顶点属性之间的间隔</span><br>    <span class="hljs-comment">// - pointer：数据在缓冲区中的偏移量</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(VERTEX_ATTR_POSITION, NUM_COMPONENTS_PER_VERTEX, GL_FLOAT, GL_FALSE, NUM_COMPONENTS_PER_VERTEX * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 启用顶点属性数组</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(VERTEX_ATTR_POSITION);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="main.cpp">main.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/TriangleModel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;utils/windowFactory.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个窗口Factory对象</span><br>    <span class="hljs-function">GLFWWindowFactory <span class="hljs-title">myWindow</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">&quot;This is Title&quot;</span>)</span></span>;<br>    <br>    <span class="hljs-comment">// 创建一个三角形模型对象</span><br>    TriangleModel triangle;<br>    <br>    <span class="hljs-comment">// 运行窗口，传入一个lambda表达式，用于自定义渲染逻辑</span><br>    myWindow.<span class="hljs-built_in">run</span>([&amp;]() &#123;<br>        <span class="hljs-comment">// 绘制三角形</span><br>        triangle.<span class="hljs-built_in">draw</span>();<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(HelloFactory)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><br><span class="hljs-comment"># 搜索并收集utils文件夹下的所有源文件</span><br><span class="hljs-keyword">file</span>(GLOB UTILS <span class="hljs-string">&quot;utils/*.cpp&quot;</span>, <span class="hljs-string">&quot;utils/*.h&quot;</span>)<br><br><span class="hljs-comment"># 添加可执行文件（还要加入utils文件夹下的源文件）</span><br><span class="hljs-keyword">add_executable</span>(HelloFactory main.cpp <span class="hljs-variable">$&#123;UTILS&#125;</span>)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(HelloFactory PRIVATE glad::glad glfw)<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/01/OpenGL%E5%85%A5%E9%97%A8003%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8Factory%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8C%96%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/image-20241101155202439.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门002——顶点着色器和片段着色器</title>
    <link href="/2024/11/01/OpenGL%E5%85%A5%E9%97%A8002%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    <url>/2024/11/01/OpenGL%E5%85%A5%E9%97%A8002%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一些概念">一些概念</h1><h2 id="坐标转换阶段">坐标转换阶段</h2><p><strong>概述：</strong>模型空间、世界空间、视图空间和裁剪空间是对象在3D场景中经历的不同坐标变换阶段。每个空间对应渲染管道的一个步骤，逐步将模型从其初始位置转换到最终屏幕上的位置</p><p><strong>模型空间：</strong></p><ul><li>定义：这是对象的本地坐标系，是模型创建时的坐标</li><li>作用：模型空间定义了物体的基本形状和几何信息，不受场景中其他物体位置的影响。每个模型都有自己的模型空间坐标</li><li>转换：通过模型矩阵，可以将模型空间的坐标转换为世界空间</li></ul><p><strong>世界空间：</strong></p><ul><li>定义：这是整个场景的坐标系，所有模型在世界空间中都有唯一的位置和方向，可以视为“全局坐标系”</li><li>作用：将所有对象放置在同一个坐标系统中，确保它们相对位置正确</li><li>转换：通过应用视图矩阵，将世界空间的坐标转换为视图空间，视图矩阵通常基于摄像机的位置和方向</li></ul><p><strong>视图空间：</strong></p><ul><li>定义：又称为“摄像机空间“，是以摄像机位置为原点的坐标系，此时场景中的所有对象都以摄像机为参考重新定位</li><li>作用：使得所有对象相对于摄像机的位置和方向变得更直观，便于确定哪些对象可见、如何投影到屏幕</li><li>转换：使用投影矩阵将视图空间转换为裁剪空间，这一步决定了图像的投影类型（如透视投影或正交投影）</li></ul><p><strong>裁剪空间：</strong></p><ul><li>定义：应用投影变换后的空间，此时3D场景的坐标被转换为一个标准化的3D盒子，所有可见的坐标x，y，z值均被限制在-1到1之间</li><li>作用：裁剪空间便于对视锥外部的物体进行裁剪，只保留可见部分。裁剪后的坐标将进行透视除法，映射到2D屏幕上的坐标，即归一化设备坐标</li><li>转换：裁剪空间进一步转换为屏幕空间，经过视口变换，使坐标适配屏幕的分辨率和比例</li></ul><h2 id="顶点着色器">顶点着色器</h2><p><strong>概述：</strong> 顶点着色器（VertexShader）是对输入的顶点进行处理，顶点是组成几何体的基本元素，比如三角形的每个角都是一个顶点</p><p><strong>作用：</strong></p><ul><li>顶点位置变换：顶点着色器通常会将顶点从模型空间（即对象的局部坐标系）转换到世界空间、视图空间，最后转换到裁剪空间，以便在屏幕上正确显示</li><li>顶点属性处理：除了位置，顶点着色器还可以处理其他与顶点相关的属性，比如法线、纹理坐标、颜色等</li><li>光照计算：在某些情况下，顶点着色器可以进行基础的光照计算，如使用法线来计算顶点的光照效果</li></ul><p><strong>输入：</strong> 顶点的坐标、法线、纹理坐标等数据</p><p><strong>输出：</strong>处理后的顶点坐标，如变换后的顶点位置和其他顶点属性，供后续的图形流水线使用</p><h2 id="片段着色器">片段着色器</h2><p><strong>概述：</strong> 片段着色器（FramgmentShader）是屏幕上每个像素的潜在颜色值，在光栅化阶段之后，每个几何体被转换为一系列像素片段，片段着色器负责确定这些片段的最终颜色</p><p><strong>作用：</strong></p><ul><li>颜色计算：片段着色器通过对纹理、光照、材质等信息的处理，确定每个像素的颜色，它通常会结合插值后的顶点属性（如纹理坐标或颜色）进行复杂的颜色计算</li><li>光照效果：片段着色器可以进行精确的光照计算，以便生成更逼真的阴影和高光效果</li><li>纹理映射：片段着色器可以从纹理中采样，根据纹理坐标获取纹理颜色，并应用到片段上</li></ul><p><strong>输入：</strong>每个片段的插值属性（如纹理坐标、颜色、发现等）</p><p><strong>输出：</strong>每个片段的最终颜色值，传递给屏幕或帧缓冲区</p><h2 id="vbo">VBO</h2><p><strong>概述：</strong> VBO(Vertex BufferObject)是一个存储在GPU内存中的缓冲区，用于存放顶点数据。通常，顶点数据包含顶点的坐标、颜色、法线、纹理坐标等信息。通过使用VBO，程序可以将这些顶点数据传输到GPU，这样GPU可以在渲染时快速访问它们，而不需要每帧都从CPU传输数据</p><p><strong>关键步骤：</strong></p><ul><li>创建VBO：使用glGenBuffers()创建一个VBO</li><li>绑定VBO：使用glBindBuffer()绑定VBO，指定将要存储的缓冲数据类型（如顶点数据GL_ARRY_BUFFER）</li><li>填充VBO：使用glBufferData()将顶点数据传输到VBO中</li></ul><h2 id="vao">VAO</h2><p><strong>概述：</strong> VAO(Vertex ArrayObject)是一个用于保存VBO配置的对象，它记录了与绘制顶点相关的所有状态信息。VAO不仅仅是VBO的一个包装器，它还保存了顶点属性指针和启用状态。例如：每个顶点的布局、数据的解释方式（如步幅、偏移量），以及使用的VBO。使用VAO可以简化渲染过程，因为当VAO被绑定时，所有与其关联的VBO和顶点属性信息都会自动生效。</p><p><strong>关键步骤：</strong></p><ul><li>创建VAO：使用glGenVertexArrays()创建一个VAO</li><li>绑定VAO：使用glBindVertexArray()绑定VAO</li><li>设置顶点属性指针：使用glVertexAttribPointer()设置顶点属性指针（告诉OpenGL如何解释顶点数据）</li><li>启用顶点属性：使用glEnableVertexAttribArray()启用顶点属性</li></ul><h1 id="实战">实战</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong> 绘制一个三角形</p><p><strong>环境：</strong></p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="main.cpp">main.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 屏幕宽度</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SCR_WIDTH = <span class="hljs-number">800</span>;<br><span class="hljs-comment">// 屏幕高度</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SCR_HEIGHT = <span class="hljs-number">600</span>;<br><br><span class="hljs-comment">// 窗口大小改变的回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>&#125;<br><br><span class="hljs-comment">// 处理输入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>    <span class="hljs-comment">// 按下ESC键时进入if块</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>        <span class="hljs-comment">// 关闭窗口</span><br>        <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 顶点着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *vertexShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span> <span class="hljs-comment">// 指定了GLSL（OpenGL着色器语言）的版本</span><br>                                 <span class="hljs-string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span> <span class="hljs-comment">// 定义了一个输入变量aPos，它是一个vec3类型的变量, 并且指定了它的位置值为0, 这意味着顶点属性数组的第一个属性将被绑定到这个变量</span><br>                                 <span class="hljs-string">&quot;void main()\n&quot;</span><br>                                 <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                                 <span class="hljs-string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span> <span class="hljs-comment">// 将输入的顶点位置aPos转换为一个四维向量，gl_Postion是OpengGL固定功能管线中用于存储顶点位置的变量</span><br>                                 <span class="hljs-string">&quot;&#125;\0&quot;</span>;<br><br><span class="hljs-comment">// 片段着色器源码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *fragmentShaderSource = <span class="hljs-string">&quot;#version 330 core\n&quot;</span> <span class="hljs-comment">// 指定了GLSL（OpenGL着色器语言）的版本</span><br>                                   <span class="hljs-string">&quot;out vec4 FragColor;\n&quot;</span> <span class="hljs-comment">// 定义了一个输出变量FragColor，它是一个vec4类型的变量，表示片段颜色，out关键字表示这个变量将输出到渲染管线的下一个阶段</span><br>                                   <span class="hljs-string">&quot;void main()\n&quot;</span><br>                                   <span class="hljs-string">&quot;&#123;\n&quot;</span><br>                                   <span class="hljs-string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span> <span class="hljs-comment">// 将输出颜色设置为橙色</span><br>                                   <span class="hljs-string">&quot;&#125;\n\0&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化glfw</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-comment">// 设置opengl版本</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>    <span class="hljs-comment">// 创建glfw窗口</span><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="hljs-string">&quot;I am window title&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (window == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to create glfw window&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">// 终止GLFW</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设置当前窗口的上下文</span><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<br>    <br>    <span class="hljs-comment">// 加载opengl函数指针</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构建并编译顶点着色程序</span><br>    <span class="hljs-comment">// 创建一个着色器对象，GL_VERTEX_SHADER表示顶点着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vertexShader = <span class="hljs-built_in">glCreateShader</span>(GL_VERTEX_SHADER);<br>    <span class="hljs-comment">// 将着色器源码附加到着色器对象上</span><br>    <span class="hljs-built_in">glShaderSource</span>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(vertexShader);<br>    <span class="hljs-comment">// 检查着色器是否编译成功</span><br>    <span class="hljs-type">int</span> success;<br>    <span class="hljs-type">char</span> infoLog[<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(vertexShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span><br>                  &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 构建并编译片段着色器</span><br>    <span class="hljs-comment">// 创建一个着色器对象，GL_FRAGMENT_SHADER表示片段着色器</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fragmentShader = <span class="hljs-built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);<br>    <span class="hljs-comment">// 将着色器源码附加到着色器对象上</span><br>    <span class="hljs-built_in">glShaderSource</span>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 编译着色器</span><br>    <span class="hljs-built_in">glCompileShader</span>(fragmentShader);<br>    <span class="hljs-comment">// 检查着色器是否编译成功</span><br>    <span class="hljs-built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetShaderInfoLog</span>(fragmentShader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span><br>                  &lt;&lt; infoLog &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 创建着色器程序对象</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> shaderProgram = <span class="hljs-built_in">glCreateProgram</span>();<br>    <span class="hljs-comment">// 将着色器对象附加到着色器程序上</span><br>    <span class="hljs-built_in">glAttachShader</span>(shaderProgram, vertexShader);<br>    <span class="hljs-built_in">glAttachShader</span>(shaderProgram, fragmentShader);<br>   <span class="hljs-comment">// 链接程序对象</span><br>    <span class="hljs-built_in">glLinkProgram</span>(shaderProgram);<br>    <span class="hljs-comment">// 检查链接是否成功</span><br>    <span class="hljs-built_in">glGetProgramiv</span>(shaderProgram, GL_LINK_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-built_in">glGetProgramInfoLog</span>(shaderProgram, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, infoLog);<br>        cout &lt;&lt; <span class="hljs-string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span><br>                  &lt;&lt; infoLog &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-comment">// 删除着色器对象</span><br>    <span class="hljs-built_in">glDeleteShader</span>(vertexShader);<br>    <span class="hljs-built_in">glDeleteShader</span>(fragmentShader);<br>    <br>    <span class="hljs-comment">// 设置三角形的顶点数据</span><br>    <span class="hljs-type">float</span> vertices[] = &#123;<br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-comment">// 左下角</span><br>        <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下角</span><br>        <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>    <span class="hljs-comment">// 顶部</span><br>    &#125;;<br>    <span class="hljs-comment">// 生成一个VAO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VAO;<br>    <span class="hljs-built_in">glGenVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-comment">// 绑定VAO，使其成为当前操作的VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>    <span class="hljs-comment">// 生成一个VBO</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> VBO;<br>    <span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-comment">// 绑定VBO, 使其成为当前操作的VBO，GL_ARRAY_BUFFER表示顶点缓冲区</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<br>    <span class="hljs-comment">// 为当前绑定的VBO创建并初始化数据存储，GL_STATIC_DRAW表示数据将一次性提供给缓冲区，并且在之后的绘制过程中不会频繁更改</span><br>    <span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<br>    <span class="hljs-comment">// 定义顶点属性的布局</span><br>    <span class="hljs-comment">// - index：顶点属性的索引</span><br>    <span class="hljs-comment">// - size：每个顶点属性的数量，每个顶点有三个分享</span><br>    <span class="hljs-comment">// - type：数据类型</span><br>    <span class="hljs-comment">// - normalized：是否将非浮点数值归一化</span><br>    <span class="hljs-comment">// - stride：连续顶点属性之间的间隔</span><br>    <span class="hljs-comment">// - pointer：数据在缓冲区中的偏移量</span><br>    <span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>), (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 启用顶点属性数组</span><br>    <span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 解绑VBO</span><br>    <span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 解绑VAO</span><br>    <span class="hljs-built_in">glBindVertexArray</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 循环渲染</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>        <span class="hljs-comment">// 处理输入</span><br>        <span class="hljs-built_in">process_input</span>(window);<br>        <br>        <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <br>        <span class="hljs-comment">// 使用着色器程序</span><br>        <span class="hljs-built_in">glUseProgram</span>(shaderProgram);<br>        <span class="hljs-comment">// 绑定VAO</span><br>        <span class="hljs-built_in">glBindVertexArray</span>(VAO);<br>        <span class="hljs-comment">// 绘制三角形</span><br>        <span class="hljs-built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="hljs-number">0</span> ,<span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 交换缓冲区</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除VAO</span><br>    <span class="hljs-built_in">glDeleteVertexArrays</span>(<span class="hljs-number">1</span>, &amp;VAO);<br>    <span class="hljs-comment">// 删除VBO</span><br>    <span class="hljs-built_in">glDeleteBuffers</span>(<span class="hljs-number">1</span>, &amp;VBO);<br>    <span class="hljs-comment">// 删除着色器程序</span><br>    <span class="hljs-built_in">glDeleteProgram</span>(shaderProgram);<br>    <br>    <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(HelloTriangle)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><br><span class="hljs-comment"># 添加可执行文件</span><br><span class="hljs-keyword">add_executable</span>(HelloTriangle main.cpp)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(HelloTriangle PRIVATE glad::glad glfw)<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/11/01/OpenGL%E5%85%A5%E9%97%A8002%E2%80%94%E2%80%94%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8/image-20241101115233690.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL入门001——使用glad和glfw创建一个窗口</title>
    <link href="/2024/10/31/OpenGL%E5%85%A5%E9%97%A8001%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8glad%E5%92%8Cglfw%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/"/>
    <url>/2024/10/31/OpenGL%E5%85%A5%E9%97%A8001%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8glad%E5%92%8Cglfw%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="glfw">glfw</h1><p><strong>概述：</strong>用于OpenGL开发中创建窗口、上下文和处理输入等操作。提供跨平台支持，简化了底层的操作系统调用</p><p><strong>作用：</strong></p><ul><li>窗口和上下文管理：<ul><li>创建窗口：GLFW提供API创建OpenGL窗口，并设置窗口大小、标题、位置等，窗口是渲染图像的主要界面</li><li>OpenGL上下文：每个窗口都有独立的OpenGL上下文，用于管理OpenGL的状态和资源。GLFW自动为窗口创建上下文，简化开发流程</li><li>双缓冲：GFLW支持双缓冲，用于减少图形闪烁问题，在双缓冲模式下，渲染的图像会在后台缓冲区绘制，完成后交换到前台缓冲区，实现平滑显示</li></ul></li><li>输入处理：<ul><li>键盘输入：GLFW提供API监听键盘事件，包括按键按下、释放等，开发者可以查询某个按键的状态，或使用回调函数处理键盘输入</li><li>鼠标输入：GLFW还提供鼠标位置、滚轮和按键事件的处理。</li><li>手柄/控制器支持：GLFW支持游戏手柄，适用于需要控制器输入的应用</li></ul></li><li>事件管理：<ul><li>窗口事件：GLFW可以监听窗口的事件，包括窗口大小改变、窗口关闭等事件。开发者可以注册相应的回调函数，方便实现窗口重绘或调整界面元素</li><li>刷新帧：GLFW提供了帧刷新功能，让开发者在双缓冲模式下完成每帧的渲染后，将图像从后台缓冲区切换到前台</li></ul></li></ul><h1 id="glad">glad</h1><p><strong>概述：</strong>是一个用于管理OpenGL函数指针的库，由于OpenGL是一个跨平台的图形API，不同平台上的OpenGL实现可能会有所不同，因此需要一个工具来加载和管理这些函数指针。</p><p><strong>作用：</strong></p><ul><li>加载OpenGL函数指针：OpenGL函数在运行时由驱动程序提供，GLAD负责加载这些函数指针，使得程序可以调用OpenGL函数</li><li>跨平台支持：glad支持多种平台和opengl版本，简化了跨平台开发的复杂性</li></ul><h1 id="创建窗口进行渲染的基本流程">创建窗口进行渲染的基本流程</h1><h2 id="简介">简介</h2><p>怎么在vscode上使用cmake构建项目，具体可以看这篇<ahref="https://1037827920.github.io/2024/10/31/Windows上如何使用CMake构建项目/">Windows上如何使用CMake构建项目- 凌云行者的博客</a></p><p><strong>目的：</strong>利用glfw和glad进行窗口的创建，然后循环渲染。</p><p><strong>环境：</strong></p><ul><li>编译工具链：使用msys2安装的mingw-gcc</li><li>依赖项：glfw3:x64-mingw-static，glad:x64-mingw-static（通过vcpkg安装）</li></ul><h2 id="main.cpp">main.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-comment">// 屏幕宽度</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SCR_WIDTH = <span class="hljs-number">800</span>;<br><span class="hljs-comment">// 屏幕高度</span><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> SCR_HEIGHT = <span class="hljs-number">600</span>;<br><br><span class="hljs-comment">// 窗口大小改变的回调函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">framebuffer_size_callback</span><span class="hljs-params">(GLFWwindow* window, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span> </span>&#123;<br>    <span class="hljs-comment">// 确保视口与新窗口尺寸匹配，注意在视网膜显示器上，宽度和高度会显著大于指定值</span><br>    <span class="hljs-built_in">glViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>&#125;<br><br><span class="hljs-comment">// 处理输入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_input</span><span class="hljs-params">(GLFWwindow* window)</span> </span>&#123;<br>    <span class="hljs-comment">// 按下ESC键时进入if块</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<br>        <span class="hljs-comment">// 关闭窗口</span><br>        <span class="hljs-built_in">glfwSetWindowShouldClose</span>(window, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化glfw</span><br>    <span class="hljs-built_in">glfwInit</span>();<br>    <span class="hljs-comment">// 设置opengl版本</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 使用核心模式：确保不使用任何被弃用的功能</span><br>    <span class="hljs-built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<br><br>    <span class="hljs-comment">// 创建glfw窗口</span><br>    GLFWwindow* window = <span class="hljs-built_in">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class="hljs-string">&quot;I am window title&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (window == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to create glfw window&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-comment">// 终止GLFW</span><br>        <span class="hljs-built_in">glfwTerminate</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设置当前窗口的上下文</span><br>    <span class="hljs-built_in">glfwMakeContextCurrent</span>(window);<br>    <span class="hljs-comment">// 设置窗口大小改变的回调函数</span><br>    <span class="hljs-built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);<br>    <br>    <span class="hljs-comment">// 加载opengl函数指针</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 循环渲染</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">glfwWindowShouldClose</span>(window)) &#123; <span class="hljs-comment">// 检查是否应该关闭窗口</span><br>        <span class="hljs-comment">// 处理输入</span><br>        <span class="hljs-built_in">process_input</span>(window);<br>        <br>        <span class="hljs-comment">// 清空屏幕所用的颜色</span><br>        <span class="hljs-built_in">glClearColor</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<br>        <span class="hljs-comment">// 清空颜色缓冲，主要目的是为每一帧的渲染准备一个干净的画布</span><br>        <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>        <br>        <span class="hljs-comment">// 交换缓冲区</span><br>        <span class="hljs-built_in">glfwSwapBuffers</span>(window);<br>        <span class="hljs-comment">// 处理所有待处理事件，去poll所有事件，看看哪个没处理的</span><br>        <span class="hljs-built_in">glfwPollEvents</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 终止GLFW，清理GLFW分配的资源</span><br>    <span class="hljs-built_in">glfwTerminate</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cmakelists.txt">CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 设置CMake的最低版本要求</span><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(HelloWorld)<br><br><span class="hljs-comment"># vcpkg集成, 这里要换成你自己的vcpkg工具链文件和共享库路径</span><br><span class="hljs-keyword">set</span>(VCPKG_ROOT D:/software6/vcpkg/)<br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH <span class="hljs-variable">$&#123;VCPKG_ROOT&#125;</span>/installed/x64-mingw-static/share)<br><br><span class="hljs-comment"># 查找所需的包</span><br><span class="hljs-keyword">find_package</span>(glad CONFIG REQUIRED)<br><span class="hljs-keyword">find_package</span>(glfw3 CONFIG REQUIRED)<br><br><span class="hljs-comment"># 添加可执行文件</span><br><span class="hljs-keyword">add_executable</span>(HelloWorld main.cpp)<br><br><span class="hljs-comment"># 链接所需的库</span><br><span class="hljs-keyword">target_link_libraries</span>(HelloWorld PRIVATE glad::glad glfw)<br></code></pre></td></tr></table></figure><h2 id="最终效果">最终效果</h2><img src="/2024/10/31/OpenGL%E5%85%A5%E9%97%A8001%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8glad%E5%92%8Cglfw%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3/image-20241101115319592.png" class="">]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>opengl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows上如何使用CMake构建项目</title>
    <link href="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="编译器安装">1. 编译器安装</h1><p>推荐使用MSYS2，windows平台下载地址：<ahref="https://www.msys2.org/">MSYS2</a></p><p><strong>pacman基本命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Sy <span class="hljs-comment"># 更新软件包数据</span><br>pacman -Syu <span class="hljs-comment"># 更新所有</span><br>pacman -Ss &lt;package_name&gt; <span class="hljs-comment"># 查询package信息</span><br>pacman -S &lt;package_name&gt; <span class="hljs-comment"># 安装package</span><br>pacman -R &lt;package_name&gt; <span class="hljs-comment"># 卸载package</span><br></code></pre></td></tr></table></figure><p><strong>安装编译工具链：</strong></p><p>安装gcc/g++：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S mingw-w64-x86_64-toolchain<br></code></pre></td></tr></table></figure><p>安装clang：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S mingw-w64-clang-x86_64-toolchain<br></code></pre></td></tr></table></figure><h1 id="下载cmake">2. 下载CMake</h1><p>下载地址：<ahref="https://github.com/Kitware/CMake/releases">Releases ·Kitware/CMake</a></p><p>找到.msi扩展名的文件下载后，双击打开安装</p><p>还要在vscode上下载CMake Tools扩展</p><h1 id="第一个示例">3. 第一个示例</h1><p><strong>目标：</strong>在vscode上，使用CMake构建项目，并且使用了MinGW Makefiles生成器</p><p><strong>步骤：</strong></p><ol type="1"><li><p>新建一个目录</p></li><li><p>创建文件<code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建文件<code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>) <span class="hljs-comment"># 要求CMake的最低版本</span><br><br><span class="hljs-comment"># 设置项目名称</span><br><span class="hljs-keyword">project</span>(hello-world)<br><br><span class="hljs-comment"># 添加一个可执行文件</span><br><span class="hljs-keyword">add_executable</span>(hello-world main.cpp)<br></code></pre></td></tr></table></figure></li><li><p>按下<code>ctrl+shirt+p</code>输入<code>CMake: Configure</code>，会让你选择编译器环境，选择我们安装的mingw-gcc就行（图中第三行）（如果选择错了可以点击左侧Cmake图标更换编译器配置）<img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241101114717412.png" class=""></p></li><li><p>按下<code>ctrl+shirt+p</code>输入<code>CMake: Build</code>（可以自己配置预设编译器环境，也可以让CMake去猜测要使用的编译器环境，这种方式就是没有指定预设，而是让CMake去猜，因为前面配置了编译器，所以也不算猜？）</p></li><li><p>找到vscode左侧中的CMake图标并打开： <img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241031124904553.png" class=""></p></li><li><p>选中项目右键选择“在终端中运行”：（可能需要先build一下才会出现）<img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241031124944800.png" class=""></p></li><li><p>成功！ <img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241031125004663.png" class=""></p></li></ol><h1 id="使用vcpkg安装依赖">4. 使用vcpkg安装依赖</h1><p><strong>安装步骤：</strong></p><p>clone仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/microsoft/vcpkg.git<br></code></pre></td></tr></table></figure><p>进入vcpkg目录并编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> vcpkg<br>./bootstrap-vcpkg.sh  <span class="hljs-comment"># Linux/macOS</span><br>./bootstrap-vcpkg.bat <span class="hljs-comment"># Windows</span><br></code></pre></td></tr></table></figure><p>会在项目根目录下生成一个vcpkg的可执行文件，安装包：（坑点，默认情况下安装包适用于MSVC编译器且动态库版本，如果你使用的是Mingw，需要额外指定&lt;package_name&gt;:x64-mingw-static）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vcpkg install &lt;package_name&gt;<br></code></pre></td></tr></table></figure><p>卸载包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vcpkg remove &lt;package_name&gt;<br></code></pre></td></tr></table></figure><p><strong>与CMake集成：</strong></p><p>第一种方法：从命令行中安装依赖，需要设置工具链文件，可以使用如下任一途径：</p><ul><li>在<code>CMakePresets.json</code>文件中设置<code>CMAKE_TOOLCHAIN_FILE</code></li><li>在CMake配置调用中将<code>-DCMAKE_TOOLCHAIN_FILE=&lt;path/to/vcpkg&gt;/scripts/buildsystems/vcpkg.cmake</code>作为参数传递</li><li>在<code>CMakeLists.txt</code>文件中初次调用<code>project()</code>之前，设置<code>CMAKE_TOOLCHAIN_FILE</code>CMake变量</li></ul><p><strong>与MSBuild集成：</strong></p><p>直接通过<code>vcpkg integrate install</code>命令让vcpkg自动集成，它会修改VS的配置文件，使其自动搜索vcpkg安装的库</p><h1 id="第二个示例">5. 第二个示例</h1><p><strong>目的：</strong>使用命令行方法安装依赖（这样项目使用的就是共享库），CMake构建项目</p><p><strong>步骤：</strong></p><ol type="1"><li><p>创建一个新目录</p></li><li><p>创建helloworld.cpp文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fmt/core.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fmt::<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>安装依赖项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vcpkg.exe install <span class="hljs-built_in">fmt</span>:x64-mingw-static<br></code></pre></td></tr></table></figure></li><li><p>创建CMakeLists.txt文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br><span class="hljs-keyword">project</span>(HelloWorld)<br><br><span class="hljs-comment"># VCPKG集成，指定工具链文件和设置vcpkg共享库的路径</span><br><span class="hljs-keyword">set</span>(CMAKE_TOOLCHAIN_FILE D:/software6/vcpkg/scripts/buildsystems/vcpkg.cmake)<br><span class="hljs-keyword">set</span>(CMAKE_PREFIX_PATH D:/software6/vcpkg/installed/x64-mingw-static/share)<br><br><span class="hljs-keyword">find_package</span>(fmt CONFIG REQUIRED)<br><br><span class="hljs-keyword">add_executable</span>(HelloWorld helloworld.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(HelloWorld PRIVATE fmt::fmt)<br></code></pre></td></tr></table></figure></li><li><p>按下<code>ctrl+shirt+p</code>输入<code>CMake: Configure</code>，会让你选择编译器环境，选择我们安装的mingw-gcc就行（图中第三行）<img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241101114717412.png" class=""></p></li><li><p>按下<code>ctrl+shirt+p</code>输入<code>CMake: Build</code>（可以自己配置预设编译器环境，也可以让CMake去猜测要使用的编译器环境，这种方式就是没有指定预设，而是让CMake去猜，因为前面配置了编译器，所以也不算猜？）</p></li><li><p>找到vscode左侧中的CMake图标并打开： <img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241031124904553.png" class=""></p></li><li><p>选中项目右键选择“在终端中运行”： <img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241031163736935.png" class=""></p></li><li><p>成功！ <img src="/2024/10/31/Windows%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/image-20241031163752677.png" class=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cmake</tag>
      
      <tag>c++</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust的迭代器——collect</title>
    <link href="/2024/10/05/rust%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94collect/"/>
    <url>/2024/10/05/rust%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E2%80%94%E2%80%94collect/</url>
    
    <content type="html"><![CDATA[<p><strong>概述：</strong>它能够将一个迭代器转换为各种集合类型，例如向量、哈希集、哈希映射等，能够将迭代器的所有元素收集到一个集合中</p><p><strong>常见的用法：</strong></p><p>将迭代器转换为Vec：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">Vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = (<span class="hljs-number">1</span>..<span class="hljs-number">5</span>).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><p>将迭代器转换为HashSet：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashSet;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">set</span>: HashSet&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><p>将迭代器转换为HashMap：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">map</span>: HashMap&lt;&amp;<span class="hljs-type">str</span>, <span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>)].<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure><p><strong>collect的类型推导：</strong></p><p>collect是泛型的，通常需要通过上下文推导出类型目标，但是有时，如果没有足够的上下文，rust无法推导出目标类型，可能需要显式指定。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span> = (<span class="hljs-number">1</span>..<span class="hljs-number">4</span>).collect::&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;();<br></code></pre></td></tr></table></figure><p><strong>内部工作原理：</strong></p><p>collect之所以通用，是因为它依赖于FromIteratortrait，该trait定义了如何从一个迭代器构建某个集合类型。Vec、HashMap、HashSet等类型都实现了FromIterator</p><p>FromIterator定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">FromIterator</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from_iter</span>&lt;T: <span class="hljs-built_in">IntoIterator</span>&lt;Item = A&gt;&gt;(iter: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>常见的使用场景：</strong></p><ol type="1"><li><p>可以使用filter_map结合collect，从一个可能包含None的迭代器中收集有效的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>), <span class="hljs-literal">None</span>, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>)];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = values.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">filter_map</span>(|x| x).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, result); <span class="hljs-comment">// 输出: [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p>去重和排序：将元素收集到HashMap中去重，再收集到Vec来排序</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashSet;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">set</span>: HashSet&lt;_&gt; = vec.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = set.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>vec.<span class="hljs-title function_ invoke__">sort</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, vec); <span class="hljs-comment">// 输出: [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li><p>将字符迭代器收集为字符串：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">chars</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: <span class="hljs-type">String</span> = chars.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s); <span class="hljs-comment">// 输出: Rust</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>性能考虑：</strong></p><p>collect通常是高效的，因为它能够预知迭代器的大小并进行优化，提前分配足够的空间，避免不必要的内存重新分配。此外，对于较大的数据集，rust还可以通过并行化迭代器（rayoncrate）来进一步提升性能。</p>]]></content>
    
    
    <categories>
      
      <category>rust迭代器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用rust写一个Web服务器——async-std版本</title>
    <link href="/2024/10/03/%E4%BD%BF%E7%94%A8rust%E5%86%99%E4%B8%80%E4%B8%AAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94async-std%E7%89%88%E6%9C%AC/"/>
    <url>/2024/10/03/%E4%BD%BF%E7%94%A8rust%E5%86%99%E4%B8%80%E4%B8%AAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94async-std%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>使用rust实现一个异步运行时是async-std的单线程Web服务器。</p><p><strong>仓库地址：</strong> <ahref="https://github.com/1037827920/web-server">1037827920/web-server:使用rust编写的简单web服务器 (github.com)</a></p><p>在之前的单线程版本的Web服务器代码上进行修改，具体代码在给的仓库地址中。</p><h2 id="实现异步代码">实现异步代码</h2><p><strong>首先将handle_connection修改为async实现：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;&#125;<br></code></pre></td></tr></table></figure><p>该修改会将函数的返回值从()变成Future&lt;Output =()&gt;，因此直接运行将不再有任何效果，只用通过.await或执行器的poll。</p><p><strong>使用async-std作为异步运行时：</strong></p><p>async-std运行时允许使用属性#[async_std::main]将我们的fnmain函数变成async fnmain，这样就可以在main函数中直接调用其他async函数，否则你得用block_on方法来让main去阻塞等待异步函数的完成，但是这种简单粗暴的阻塞等待方式并不灵活</p><p><strong>Cargo.toml：</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">futures</span> = <span class="hljs-string">&quot;0.3&quot;</span><br><br><span class="hljs-section">[dependencies.async-std]</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;1.6&quot;</span><br><span class="hljs-attr">features</span> = [<span class="hljs-string">&quot;attributes&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>下面将main函数修改为异步的，并在其中调用前面修改的异步版本handle_connection：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    io::&#123;prelude::*, BufReader&#125;,<br>    net::&#123;TcpListener, TcpStream&#125;,<br>    fs,<br>    time::Duration,<br>&#125;;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> async_std;<br><span class="hljs-keyword">use</span> async_std::task;<br><br><span class="hljs-meta">#[async_std::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-comment">// 这里还是无法并发</span><br>        <span class="hljs-title function_ invoke__">handle_connection</span>(stream).<span class="hljs-keyword">await</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实现异步版本的handle_connection：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// # 函数作用</span><br><span class="hljs-comment">/// 处理连接：读取请求，回应请求</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-comment">// 使用next而不是lines，因为我们只需要读取第一行，判断具体的request方法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">request_line</span> = buf_reader.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 根据请求的不同，返回不同的响应</span><br>    <span class="hljs-keyword">let</span> (status_line, filename) = <span class="hljs-keyword">match</span> &amp;request_line[..] &#123;<br>        <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> =&gt; (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>), <span class="hljs-comment">// 请求 / 资源</span><br>        <span class="hljs-string">&quot;GET /sleep HTTP/1.1&quot;</span> =&gt; &#123; <span class="hljs-comment">// 请求 /sleep 资源</span><br>            <span class="hljs-comment">// 没有使用std::thread::sleep进行睡眠，原因是该函数是阻塞的，它会让当前线程陷入睡眠中，导致其他任务无法继续运行</span><br>            task::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>)).<span class="hljs-keyword">await</span>;<br>            (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>)<br>        &#125;<br>        _ =&gt; (<span class="hljs-string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="hljs-string">&quot;404.html&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(filename).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = contents.<span class="hljs-title function_ invoke__">len</span>();<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;status_line&#125;\r\nContent-Length: &#123;length&#125;\r\n\r\n&#123;contents&#125;&quot;</span>);<br><br>    <span class="hljs-comment">// write_all接收&amp;[u8]类型作为参数，这里需要用as_bytes将字符串转换为字节数组</span><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，只是把函数变成async往往是不够的，还需要将它内部的代码也都变成异步兼容，阻塞线程绝对是不可行的</p><p>但是线程web服务器还是不能进行并发处理请求，原因是listener.incoming()是阻塞的迭代器。当listener在等待连接时，执行器是无法执行其他Future的，而且只有当我们处理完已有的连接后，才能接收新的连接。</p><h2 id="并发地处理连接">并发地处理连接</h2><p>上面的解决方法是将listener.incoming()从一个阻塞的迭代器变成一个非阻塞的Stream</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    fs,<br>    time::Duration,<br>&#125;;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> async_std;<br><span class="hljs-keyword">use</span> async_std::&#123;<br>    net::&#123;TcpListener, TcpStream&#125;,<br>    io::&#123;prelude::*, BufReader&#125;,<br>    task,<br>&#125;;<br><span class="hljs-keyword">use</span> futures::StreamExt;<br><br><span class="hljs-meta">#[async_std::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    listener<br>        .<span class="hljs-title function_ invoke__">incoming</span>()<br>        .for_each_concurrent(<span class="hljs-literal">None</span>, |tcpstream| <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">tpcstream</span> = tcpstream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-title function_ invoke__">handle_connection</span>(tpcstream).<span class="hljs-keyword">await</span>;<br>        &#125;)<br>        .<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>异步版本的TcpListener为listener.incoming()实现了Streamtrait，这样listener.incoming()不再阻塞，且使用for_each_concurrent可以并发地处理从Stream获取的元素。</p><p>现在关键在于handle_connection不能再阻塞：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// # 函数作用</span><br><span class="hljs-comment">/// 处理连接：读取请求，回应请求</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-comment">// 使用next而不是lines，因为我们只需要读取第一行，判断具体的request方法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">request_line</span> = buf_reader.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 根据请求的不同，返回不同的响应</span><br>    <span class="hljs-keyword">let</span> (status_line, filename) = <span class="hljs-keyword">match</span> &amp;request_line[..] &#123;<br>        <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> =&gt; (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>), <span class="hljs-comment">// 请求 / 资源</span><br>        <span class="hljs-string">&quot;GET /sleep HTTP/1.1&quot;</span> =&gt; &#123; <span class="hljs-comment">// 请求 /sleep 资源</span><br>            <span class="hljs-comment">// 没有使用std::thread::sleep进行睡眠，原因是该函数是阻塞的，它会让当前线程陷入睡眠中，导致其他任务无法继续运行</span><br>            task::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>)).<span class="hljs-keyword">await</span>;<br>            (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>)<br>        &#125;<br>        _ =&gt; (<span class="hljs-string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="hljs-string">&quot;404.html&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(filename).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = contents.<span class="hljs-title function_ invoke__">len</span>();<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;status_line&#125;\r\nContent-Length: &#123;length&#125;\r\n\r\n&#123;contents&#125;&quot;</span>);<br><br>    <span class="hljs-comment">// write_all接收&amp;[u8]类型作为参数，这里需要用as_bytes将字符串转换为字节数组</span><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在将数据读写改造成异步后，现在该函数也彻底变成了异步版本，可以并发地处理连接</p><h2 id="使用多线程提升性能">使用多线程提升性能</h2><p>async并发和多线程其实并不冲突，async-std包也允许我们使用多个线程去处理，由于handle_connection实现了Sendtrait不会阻塞，因此使用async_std::task::spawn是非常安全的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> async_std::task::spawn;<br><br><span class="hljs-meta">#[async_std::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwarp</span>():<br>    listener<br>    .<span class="hljs-title function_ invoke__">incoming</span>()<br>    .for_each_concurrent(<span class="hljs-literal">None</span>, |stream| <span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-title function_ invoke__">handle_connection</span>(stream));<br>    &#125;)<br>    .<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这里是为每个请求都单独创建了一个线程，实际上需要限制创建线程的数量，可以通过线程池来实现。具体可以看<ahref="https://1037827920.github.io/2024/10/01/使用rust写一个Web服务器——单线程版本/">这篇无async的多线程版本的Web服务器</a></p>]]></content>
    
    
    <categories>
      
      <category>rust项目学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用rust写一个Web服务器——多线程版本</title>
    <link href="/2024/10/02/%E4%BD%BF%E7%94%A8rust%E5%86%99%E4%B8%80%E4%B8%AAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC/"/>
    <url>/2024/10/02/%E4%BD%BF%E7%94%A8rust%E5%86%99%E4%B8%80%E4%B8%AAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p><strong>仓库地址：</strong> <ahref="https://github.com/1037827920/web-server">1037827920/web-server:使用rust编写的简单web服务器 (github.com)</a></p><h2 id="模拟慢请求">模拟慢请求</h2><p>一个单线程版本的web服务器只能一次处理一个请求，可是如果一个请求持续的时间太长，就会导致其他请求有可能饥饿，下面使用sleep方式让每次请求持续5s，模拟真实的慢请求：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    fs,<br>    io::&#123;prelude::*, BufReader&#125;,<br>    net::&#123;TcpListener, TcpStream&#125;,<br>    thread,<br>    time::Duration,<br>&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 监听本地8080端口</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <br>        <span class="hljs-comment">// 处理连接</span><br>        <span class="hljs-title function_ invoke__">handle_connection</span>(stream);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-comment">// 使用next而不是lines，因为我们只需要读取第一行，判断具体的request方法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">request_line</span> = buf_reader.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br><span class="hljs-comment">// match方法不会像之前的方法那样自动做引用或解引用，因此我们需要显式调用</span><br>    <span class="hljs-keyword">let</span> (status_line, filename) = <span class="hljs-keyword">match</span> &amp;request_line[..] &#123;<br>        <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> =&gt; (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>), <span class="hljs-comment">// 请求 / 资源</span><br>        <span class="hljs-string">&quot;GET /sleep HTTP/1.1&quot;</span> =&gt; &#123; <span class="hljs-comment">// 请求 /sleep 资源</span><br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>));<br>            (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>)<br>        &#125;<br>        _ =&gt; (<span class="hljs-string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="hljs-string">&quot;404.html&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-comment">// 读取文件内容</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(filename).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = contents.<span class="hljs-title function_ invoke__">len</span>();<br><br>    <span class="hljs-comment">// 格式化HTTP Response</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> =<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;status_line&#125;\r\nContent-Length: &#123;length&#125;\r\n\r\n&#123;contents&#125;&quot;</span>);<br><br>    <span class="hljs-comment">// 将response写入stream</span><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码后访问localhost:8080/sleep，然后紧接着继续运行localhost:8080，会发现后者的请求必须等待前者完成后才能被处理，下面使用线程池改善吞吐量</p><h2 id="多线程web服务器实现">多线程Web服务器实现</h2><p><strong>线程池：</strong>包含一组已经生成的线程，它们时刻等待着接收并处理新的任务，当程序接收到新任务时，它会将线程池中的一个线程指派给该任务，在该线程忙着处理时，新来的任务交给池中剩余的线程进行处理，最终，当执行任务的线程处理完后，它会被重新放入到线程池中，准备处理新任务。<strong>注意：</strong>需要限制线程池中的线程数量，以保护服务器免受拒绝服务攻击(DoS)的影响：如果针对每个请求创建一个新线程，那么一个人向我们的服务器发出1000万个请求，会直接耗尽资源，导致后续用户的请求无法被处理，这也是拒绝服务名称的来源。</p><p>因此，需要对线程池进行一定的架构设计，首先是设定最大线程数的上限，其次是维护一个请求队列。池中的线程去队列中依次弹出请求并处理。</p><h3 id="为每个请求单独生成一个线程">为每个请求单独生成一个线程</h3><p>修改main函数，每次处理一个任务就创建一个新的线程并执行任务</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    fs,<br>    io::&#123;prelude::*, BufReader&#125;,<br>    net::&#123;TcpListener, TcpStream&#125;,<br>    thread,<br>    time::Duration,<br>&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>            <span class="hljs-title function_ invoke__">handle_connection</span>(stream);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-comment">// 使用next而不是lines，因为我们只需要读取第一行，判断具体的request方法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">request_line</span> = buf_reader.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br><span class="hljs-comment">// match方法不会像之前的方法那样自动做引用或解引用，因此我们需要显式调用</span><br>    <span class="hljs-keyword">let</span> (status_line, filename) = <span class="hljs-keyword">match</span> &amp;request_line[..] &#123;<br>        <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> =&gt; (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>), <span class="hljs-comment">// 请求 / 资源</span><br>        <span class="hljs-string">&quot;GET /sleep HTTP/1.1&quot;</span> =&gt; &#123; <span class="hljs-comment">// 请求 /sleep 资源</span><br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">5</span>));<br>            (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>)<br>        &#125;<br>        _ =&gt; (<span class="hljs-string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="hljs-string">&quot;404.html&quot;</span>),<br>    &#125;;<br><br>    <span class="hljs-comment">// 读取文件内容</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(filename).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = contents.<span class="hljs-title function_ invoke__">len</span>();<br><br>    <span class="hljs-comment">// 格式化HTTP Response</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> =<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;status_line&#125;\r\nContent-Length: &#123;length&#125;\r\n\r\n&#123;contents&#125;&quot;</span>);<br><br>    <span class="hljs-comment">// 将response写入stream</span><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样简单粗暴就能实现多线程的Web服务器，但是这样不能达到限制线程池中线程数的效果</p><h3 id="限制创建线程的数量">限制创建线程的数量</h3><p>利用线程池，继续修改main函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-comment">// 首先创建一个包含4个线程的线程池</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pool</span> = ThreadPool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">4</span>);<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <br>        <span class="hljs-comment">// 分发执行请求</span><br>        pool.<span class="hljs-title function_ invoke__">execute</span>(|| &#123;<br>            <span class="hljs-title function_ invoke__">handle_connection</span>(stream)<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，我们至少要实现ThreadPool这个结构体和execute方法</p><h3 id="threadpool的初始化">ThreadPool的初始化</h3><p>首先要确定使用new还是build来初始化ThreadPool实例，new往往用于简单初始化一个实例，而build往往会完成更加复杂的构建工作，我们并不需要在初始化线程池的同时创建相应的线程，因此new更合适。</p><p>在src/lib.rs写入以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadPool</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">/// # 函数功能</span><br>    <span class="hljs-comment">/// 创建一个新的线程池</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(size: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ThreadPool &#123;<br>        <span class="hljs-built_in">assert!</span>(size &gt; <span class="hljs-number">0</span>);<br><br>        ThreadPool<br>    &#125;<br>    <br>    <span class="hljs-comment">/// # 函数功能</span><br>    <span class="hljs-comment">/// 执行传入的函数f</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">execute</span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span><br>    &#123;<br>        todo!();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在src/main.rs中导入lib.rs的ThreadPool：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> &lt;project_name&gt;::ThreadPool;<br></code></pre></td></tr></table></figure><h3 id="threadpool的存储">ThreadPool的存储</h3><p>ThreadPool作为一个线程池，肯定是要能够存储线程的对吧，继续修改ThreadPool，添加<code>threads</code>字段，使其能够存储线程</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread::&#123;<span class="hljs-keyword">self</span>, Thread&#125;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    threads: <span class="hljs-type">Vec</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">/// # 函数功能</span><br>    <span class="hljs-comment">/// 创建一个新的线程池</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(size: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ThreadPool &#123;<br>        <span class="hljs-built_in">assert!</span>(size &gt; <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 使用with_capacity可以提前分配好内存空间，比Vec::new的性能好</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">threads</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(size);<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..size &#123;<br>            <span class="hljs-comment">// 创建线程并将其存储在vector中</span><br>            todo!();<br>        &#125;<br><br>        ThreadPool &#123; threads &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/// # 函数功能</span><br>    <span class="hljs-comment">/// 执行传入的函数f</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">execute</span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span><br>    &#123;<br>        todo!();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadpool的设计">ThreadPool的设计</h3><p>使用thread::spawn是生成线程的最好方式，但是它会立即执行传入的任务，我们需要的是创建线程和执行任务是要分离的。也就是说，我们可以先创建线程后这个线程就进入loop循环等待，直到有执行任务的信号过来这个线程才会执行任务。</p><p>可以考虑创建一个Worker结构体，存放id和对应的线程。作为ThreadPool和任务线程联系的桥梁，通过channel，ThreadPool持有Sender，通过execute方法将任务发送给Worker，而Worker持有Receiver，在loop循环中接收ThreadPool发送过来的任务。</p><p>ThreadPool结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    sync::&#123;mpsc, Arc, Mutex&#125;,<br>    thread,<br>&#125;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    workers: <span class="hljs-type">Vec</span>&lt;Worker&gt;,<br>    sender: mpsc::Sender&lt;Job&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">/// # 函数功能</span><br>    <span class="hljs-comment">/// 创建一个新的线程池</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(size: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ThreadPool &#123;<br>        <span class="hljs-built_in">assert!</span>(size &gt; <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 获得Sender和Receiver</span><br>        <span class="hljs-keyword">let</span> (sender, receiver) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>        <br>        <span class="hljs-comment">// receiver会在多线程中移动，因此要保证线程安全，需要使用Arc和Mutex。Arc可以允许多个Worker同时持有Receiver，而Mutex可以确保一次只有一个Worker能从Receiver中获取任务，防止任务被多次执行</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">receiver</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(receiver));<br>        <br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">workers</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(size);<br>        <br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">id</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..size &#123;<br>            workers.<span class="hljs-title function_ invoke__">push</span>(Worker::<span class="hljs-title function_ invoke__">new</span>(id, Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;receiver)));<br>        &#125;<br>        <br>        ThreadPool &#123; workers, sender &#125;<br>    &#125;    <br>    <span class="hljs-comment">/// # 函数功能</span><br>    <span class="hljs-comment">/// 执行传入的函数f</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">execute</span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F) <br>    <span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">job</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(f);<br>        <span class="hljs-comment">// Sender往通道中发送任务</span><br>        <span class="hljs-keyword">self</span>.sender.<span class="hljs-title function_ invoke__">send</span>(job).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Worker结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 闭包的大小编译是未知的，使用Box可以在堆上动态分配内存，从而存储闭包</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Job</span> = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Worker</span> &#123;<br>    id: <span class="hljs-type">usize</span>,<br>    thread: thread::JoinHandle&lt;()&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(id: <span class="hljs-type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> Worker &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-comment">// Receiver会阻塞直到有任务</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">job</span> = receiver.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Workder &#123;id&#125; got a job; executing&quot;</span>);<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-title function_ invoke__">job</span>();<br>        &#125;);<br>        <span class="hljs-comment">// 让每个Worker都拥有自己的唯一id</span><br>        Worker &#123; id, thread &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关闭和资源清理">关闭和资源清理</h2><h3 id="为threadpool实现drop">为ThreadPool实现Drop</h3><p>当线程池被Drop时，需要等待所有的子线程完成它们的工作，然后再退出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Worker</span> &#123;<br>    id: <span class="hljs-type">usize</span>,<br>    <span class="hljs-comment">// 因为Worker中的thread字段的JoinHandle类型没有实现copy trait,可以修改Worker的thread字段，使用Option，然后通过take可以拿走内部值的所有权，同时留下一个None</span><br>    thread: <span class="hljs-type">Option</span>&lt;thread::JoinHandle&lt;()&gt;&gt;,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(id: <span class="hljs-type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> Worker &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">job</span> = receiver.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Workder &#123;id&#125; got a job; executing&quot;</span>);<br>            <span class="hljs-title function_ invoke__">job</span>();<br>        &#125;);<br>        <span class="hljs-comment">// 让每个Worker都拥有自己的唯一id</span><br>        Worker &#123; <br>            id, <br>            thread: <span class="hljs-title function_ invoke__">Some</span>(thread)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">worker</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.workers &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Shuting down worker &#123;&#125;&quot;</span>, worker.id);<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(thread) = worker.thread.<span class="hljs-title function_ invoke__">take</span>() &#123;<br>                thread.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="停止工作线程">停止工作线程</h3><p>虽然调用了join，但是目标线程依然不会停止，原因在于它们在无限地loop循环等待，需要channel的drop机制：释放sender后，receiver会收到错误，然后再退出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    workers: <span class="hljs-type">Vec</span>&lt;Worker&gt;,<br>    <span class="hljs-comment">// 增加Option封装，这样可以用take拿走所有权</span><br>    sender: <span class="hljs-type">Option</span>&lt;mpsc::Sender&lt;Job&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(size: <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> ThreadPool &#123;<br>        <span class="hljs-built_in">assert!</span>(size &gt; <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">let</span> (sender, receiver) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>        <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">receiver</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(receiver));<br>        <br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">workers</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(size);<br>        <br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">id</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..size &#123;<br>            workers.<span class="hljs-title function_ invoke__">push</span>(Worker::<span class="hljs-title function_ invoke__">new</span>(id, Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;receiver)));<br>        &#125;<br>        <br>        ThreadPool &#123; <br>            workers, <br>            sender: <span class="hljs-title function_ invoke__">Some</span>(sender)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">execute</span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F) <br>    <span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnOnce</span>() + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">job</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(f);<br>        <span class="hljs-keyword">self</span>.sender.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">send</span>(job).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 主动调用drop关闭sender</span><br>        <span class="hljs-title function_ invoke__">drop</span>(<span class="hljs-keyword">self</span>.sender.<span class="hljs-title function_ invoke__">take</span>());<br>        <br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">worker</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.workers &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Shuting down worker &#123;&#125;&quot;</span>, worker.id);<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(thread) = worker.thread.<span class="hljs-title function_ invoke__">take</span>() &#123;<br>                thread.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当sender被关闭后，将关闭对应的channel，所以loop的receiver就会收到一个错误，根据错误再进一步的错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(id: <span class="hljs-type">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> Worker &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = receiver.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">recv</span>();<br>            <br>            <span class="hljs-keyword">match</span> message &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(job) =&gt; &#123;<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Worker &#123;id&#125; got a job; executing&quot;</span>);<br>                    <span class="hljs-title function_ invoke__">job</span>();<br>                &#125;<br>                <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; &#123;<br>                    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Worker &#123;id&#125; disconnected; shutting down.&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <br>        Worker &#123;<br>            id,<br>            thread: <span class="hljs-title function_ invoke__">Some</span>(thread),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试">测试</h3><p>为了验证代码的正确性，修改main：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pool</span> = ThreadPool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">4</span>);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>().<span class="hljs-title function_ invoke__">take</span>(<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>        pool.<span class="hljs-title function_ invoke__">execute</span>(|| &#123;<br>            <span class="hljs-title function_ invoke__">handle_connection</span>(stream);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Shutting down.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust项目学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用rust写一个Web服务器——单线程版本</title>
    <link href="/2024/10/01/%E4%BD%BF%E7%94%A8rust%E5%86%99%E4%B8%80%E4%B8%AAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC/"/>
    <url>/2024/10/01/%E4%BD%BF%E7%94%A8rust%E5%86%99%E4%B8%80%E4%B8%AAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>使用rust编写一个基于HTTP协议的Web服务器。HTTP是更高层的通信协议，一般来说都基于TCP来构建的，除了HTTP/3，后者是基于UDP构建的协议</p><p><strong>仓库地址：</strong> <ahref="https://github.com/1037827920/web-server">1037827920/web-server:使用rust编写的简单web服务器 (github.com)</a></p><p><strong>下面分为五个步骤去完成这个单线程Web服务器：</strong></p><ol type="1"><li>监听TCP连接</li><li>读取HTTP Reqeust</li><li>返回HTTP Response</li><li>返回HTML页面</li><li>验证Request和选择性Response</li></ol><h2 id="监听tcp连接">监听TCP连接</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::net::TcpListener;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 监听端口</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;localhost:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-comment">// incoming返回一个迭代器，它每一次迭代会返回一个新的连接stream（客户端发起的连接，Web服务器负责监听接收），因此，接下来做的就是从stream中读取数据，然后返回处理的结果</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Connection established!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码后访问localhost:8080，可以看到如下结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Connection established!<br>Connection established!<br>Connection established!<br></code></pre></td></tr></table></figure><p><strong>为啥浏览器访问依次，会在终端打印多次连接建立的信息？</strong></p><p>原因在于stream超出作用域时，会触发drop的扫尾工作，其中包含了关闭连接。但是，浏览器可能会存在自动重试的情况，因此还会重新建立连接，最终打印了多次。</p><p><strong>注意：</strong>由于listener.incoming()会在当前阻塞式监听，所以main线程会被阻塞。</p><h2 id="读取http-reqeust">读取HTTP Reqeust</h2><p>连接建立后，就可以开始读取客户端传来请求数据，先了解一下HTTPReqeust</p><p><strong>HTTP Request格式：</strong></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Method</span> <span class="hljs-title function_">Request</span>-<span class="hljs-title function_">URI</span> <span class="hljs-title function_">HTTP</span>-<span class="hljs-title function_">Version</span><br><span class="hljs-title function_">headers</span> <span class="hljs-title function_">CRLF</span><br><span class="hljs-title function_">message</span>-<span class="hljs-title function_">body</span><br></code></pre></td></tr></table></figure><ul><li>Method是请求的方法，例如GET、POST等，Reqeust-URI是该请求希望访问的目标资源路径，例如/、/sleep</li><li>类似JSON格式的数据都是HTTP请求报头headers，例如“Host:localhost:8080”</li><li>message-body是消息体，它包含了用户请求携带的具体数据，例如更改用户名的请求，就要提交新的用户名数据，而GET请求是没有message-body的</li></ul><p>代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;<br>    <span class="hljs-comment">// 帮助我们读取和写入数据</span><br>    <span class="hljs-comment">// BufReader可以实现缓冲区读取，底层其实是基于std::io::Read实现，可以使用lines方法获取一个迭代器，可以对传输的内容流进行按行迭代读取，要使用该方法，需引入std::io::BufRead</span><br>    io::&#123;prelude::*, BufReader&#125;,<br>    net::&#123;TcpListener, TcpStream&#125;,<br>&#125;;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;192.168.218.128:8080&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <br>        <span class="hljs-title function_ invoke__">handle_connection</span>(stream);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/// # 函数作用</span><br><span class="hljs-comment">/// 处理连接：读取请求</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">http_request</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = buf_reader<br>    .<span class="hljs-title function_ invoke__">lines</span>()<br>    .<span class="hljs-title function_ invoke__">map</span>(|result| result.<span class="hljs-title function_ invoke__">unwrap</span>())<br>    .<span class="hljs-title function_ invoke__">take_while</span>(|line| !line.<span class="hljs-title function_ invoke__">is_empty</span>()) <span class="hljs-comment">// 从迭代器中获取元素，直到闭包返回false为止</span><br>    .<span class="hljs-title function_ invoke__">collect</span>(); <span class="hljs-comment">// 使用collect消费掉迭代器</span><br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Request: &#123;:#?&#125;&quot;</span>, http_request);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码后访问localhost:8080，可以看到如下结果：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Request:</span> [<br>    <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span>,<br>    <span class="hljs-string">&quot;Host: 192.168.218.128:8080&quot;</span>,<br>    <span class="hljs-string">&quot;Connection: keep-alive&quot;</span>,<br>    <span class="hljs-string">&quot;Cache-Control: max-age=0&quot;</span>,<br>    <span class="hljs-string">&quot;Upgrade-Insecure-Requests: 1&quot;</span>,<br>    <span class="hljs-string">&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.0.0&quot;</span>,<br>    ...<br>]<br></code></pre></td></tr></table></figure><p><strong>如何判断客户端发来的HTTP数据是否读取完成：</strong></p><p>客户端会在请求数据的结尾附上两个换行符，放我们检测某一行字符串为空时，就意味着请求数据已经传输完毕了，可以collect了。</p><h2 id="返回http-response">返回HTTP Response</h2><p>客户端请求后，服务端需要给予相应的请求应答</p><p><strong>HTTP Response格式：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HTTP-Version Status-Code Reason-Phrase <span class="hljs-keyword">CRLF</span><br>headers <span class="hljs-keyword">CRLF</span><br>message-body<br></code></pre></td></tr></table></figure><p>Status-Code用于告诉客户端，当前的请求是否成功，若失败，大概是什么原因</p><p><strong>Response示例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK\r\n\r\n<br></code></pre></td></tr></table></figure><p>修改handle_conneciton，将Response发送回客户端：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// # 函数作用</span><br><span class="hljs-comment">/// 处理连接：读取请求，回应请求</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">http_request</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = buf_reader<br>    .<span class="hljs-title function_ invoke__">lines</span>()<br>    .<span class="hljs-title function_ invoke__">map</span>(|result| result.<span class="hljs-title function_ invoke__">unwrap</span>())<br>    .<span class="hljs-title function_ invoke__">take_while</span>(|line| !line.<span class="hljs-title function_ invoke__">is_empty</span>()) <span class="hljs-comment">// 从迭代器中获取元素，直到闭包返回false为止</span><br>    .<span class="hljs-title function_ invoke__">collect</span>(); <span class="hljs-comment">// 使用collect消费掉迭代器</span><br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n\r\n&quot;</span>;<br>    <span class="hljs-comment">// write_all接收&amp;[u8]类型作为参数，这里需要用as_bytes将字符串转换为字节数组</span><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码后访问localhost:8080，浏览器已经不会再报错，已经收到了来自服务器的Response，虽然是空白页面</p><h2 id="返回html页面">返回HTML页面</h2><p>hello.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hi from Web Server<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加导包：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs;<br></code></pre></td></tr></table></figure><p>修改handle_connection函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// # 函数作用</span><br><span class="hljs-comment">/// 处理连接：读取请求，回应请求</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_http_request</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = buf_reader<br>    .<span class="hljs-title function_ invoke__">lines</span>()<br>    .<span class="hljs-title function_ invoke__">map</span>(|result| result.<span class="hljs-title function_ invoke__">unwrap</span>())<br>    .<span class="hljs-title function_ invoke__">take_while</span>(|line| !line.<span class="hljs-title function_ invoke__">is_empty</span>()) <span class="hljs-comment">// 从迭代器中获取元素，直到闭包返回false为止</span><br>    .<span class="hljs-title function_ invoke__">collect</span>(); <span class="hljs-comment">// 使用collect消费掉迭代器</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">status_line</span> = <span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>; <span class="hljs-comment">// 状态行</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(<span class="hljs-string">&quot;hello.html&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>(); <span class="hljs-comment">// 读取文件内容</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = contents.<span class="hljs-title function_ invoke__">len</span>();<br>    <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;status_line&#125;\r\nContent-Length: &#123;length&#125;\r\n\r\n&#123;contents&#125;&quot;</span>);<br><br>    <span class="hljs-comment">// write_all接收&amp;[u8]类型作为参数，这里需要用as_bytes将字符串转换为字节数组</span><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码后访问localhost:8080，浏览器会显示hello.html页面</p><h2 id="验证request和选择性response">验证Request和选择性Response</h2><p>404.html内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is 404 Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Sorry!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>继续修改handle_connection，针对客户端不同的Request给出相应的Response</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">handle_connection</span>(<span class="hljs-keyword">mut</span> stream: TcpStream) &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">buf_reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-comment">// 使用next而不是lines，因为我们只需要读取第一行，判断具体的request方法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">request_line</span> = buf_reader.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <br>    <span class="hljs-keyword">let</span> (status_line, filename) = <span class="hljs-keyword">if</span> request_line == <span class="hljs-string">&quot;GET / HTTP/1.1&quot;</span> &#123;<br>        (<span class="hljs-string">&quot;HTTP/1.1 200 OK&quot;</span>, <span class="hljs-string">&quot;hello.html&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        (<span class="hljs-string">&quot;HTTP/1.1 404 NOT FOUND&quot;</span>, <span class="hljs-string">&quot;404.html&quot;</span>)<br>    &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(filename).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = contents.<span class="hljs-title function_ invoke__">len</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">response</span> =<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;status_line&#125;\r\nContent-Length: &#123;length&#125;\r\n\r\n&#123;contents&#125;&quot;</span>);<br><br>    stream.<span class="hljs-title function_ invoke__">write_all</span>(response.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码后访问localhost:8080，浏览器会显示hello.html页面，范围localhost:8080/sleep，会显示404.html页面</p>]]></content>
    
    
    <categories>
      
      <category>rust项目学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
